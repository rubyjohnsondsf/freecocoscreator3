window.apeng = {versionCode:4};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**cc模块导入 */

(function (apeng) {
    apeng.CCFloat = _cc_.CCFloat, apeng.math = _cc_.math, apeng.ViewGroup = _cc_.ViewGroup, apeng.CCInteger = _cc_.CCInteger, apeng.native = _cc_.native, apeng.sys = _cc_.sys, apeng.input = _cc_.input, apeng.assetManager = _cc_.assetManager, apeng.AudioSource = _cc_.AudioSource, apeng.director = _cc_.director, apeng.Size = _cc_.Size, apeng.view = _cc_.view, apeng.Vec2 = _cc_.Vec2, apeng.Director = _cc_.Director, apeng.Canvas = _cc_.Canvas, apeng.sp = _cc_.sp, apeng.js = _cc_.js, apeng.game = _cc_.game, apeng.Game = _cc_.Game, apeng.TextAsset = _cc_.TextAsset, apeng.Color = _cc_.Color, apeng.Vec3 = _cc_.Vec3, apeng.ccenum = _cc_.ccenum, apeng.Graphics = _cc_.Graphics, apeng.Animation = _cc_.Animation, apeng.Node = _cc_.Node, apeng.Widget = _cc_.Widget, apeng.BlockInputEvents = _cc_.BlockInputEvents, apeng.Camera = _cc_.Camera, apeng.Collider2D = _cc_.Collider2D, apeng.Component = _cc_.Component, apeng.dragonBones = _cc_.dragonBones, apeng.EditBox = _cc_.EditBox, apeng.EventKeyboard = _cc_.EventKeyboard, apeng.EventMouse = _cc_.EventMouse, apeng.EventTouch = _cc_.EventTouch, apeng.Input = _cc_.Input, apeng.isValid = _cc_.isValid, apeng.Label = _cc_.Label, apeng.Layout = _cc_.Layout, apeng.Mask = _cc_.Mask, apeng.MeshRenderer = _cc_.MeshRenderer, apeng.MotionStreak = _cc_.MotionStreak, apeng.PageView = _cc_.PageView, apeng.RigidBody2D = _cc_.RigidBody2D, apeng.Scene = _cc_.Scene, apeng.ScrollBar = _cc_.ScrollBar, apeng.ScrollView = _cc_.ScrollView, apeng.Sprite = _cc_.Sprite, apeng.UIOpacity = _cc_.UIOpacity, apeng.UIRenderer = _cc_.UIRenderer, apeng.UITransform = _cc_.UITransform, apeng.warn = _cc_.warn, apeng.lerp = _cc_.lerp, apeng.instantiate = _cc_.instantiate, apeng.CCObject = _cc_.CCObject, apeng.Asset = _cc_.Asset, apeng.Prefab = _cc_.Prefab, apeng.SpriteFrame = _cc_.SpriteFrame, apeng.Material = _cc_.Material, apeng._decorator = _cc_._decorator, apeng.EventHandler = _cc_.EventHandler, apeng.Quat = _cc_.Quat, apeng.Mat4 = _cc_.Mat4, apeng.RenderTexture = _cc_.RenderTexture, apeng.Tween = _cc_.Tween, apeng.TweenSystem = _cc_.TweenSystem, apeng.AudioClip = _cc_.AudioClip, apeng.Layers = _cc_.Layers, apeng.macro = _cc_.macro, apeng.SubContextView = _cc_.SubContextView, apeng.ParticleSystem2D = _cc_.ParticleSystem2D;
})(apeng || (apeng = {}));
/**常量定义 */

(function (apeng) {
    /**初始化框架状态 */
    let EInitCoreState;
    (function (EInitCoreState) {
        /**初始化 */
        EInitCoreState[EInitCoreState["init"] = 0] = "init";
        /**隐私协议打开 */
        EInitCoreState[EInitCoreState["private"] = 1] = "private";
        /**配置表解析 */
        EInitCoreState[EInitCoreState["config"] = 2] = "config";
        /**首页打开 */
        EInitCoreState[EInitCoreState["openIndex"] = 3] = "openIndex";
        /**场景打开 */
        EInitCoreState[EInitCoreState["openScene"] = 4] = "openScene";
    })(EInitCoreState = apeng.EInitCoreState || (apeng.EInitCoreState = {}));
    /**
     * 模块类型 不可中途插入
     * 方便使用类型 缓存
     */
    let EModuleType;
    (function (EModuleType) {
        /**都可以写入的 */
        EModuleType[EModuleType["none"] = 2] = "none";
        EModuleType[EModuleType["platform"] = 3] = "platform";
        EModuleType[EModuleType["language"] = 4] = "language";
        EModuleType[EModuleType["timer"] = 5] = "timer";
        EModuleType[EModuleType["resouces"] = 6] = "resouces";
        EModuleType[EModuleType["ui"] = 7] = "ui";
        EModuleType[EModuleType["audio"] = 8] = "audio";
        EModuleType[EModuleType["scene"] = 9] = "scene";
        EModuleType[EModuleType["login"] = 10] = "login";
        EModuleType[EModuleType["main"] = 11] = "main";
        EModuleType[EModuleType["privacy"] = 12] = "privacy";
        EModuleType[EModuleType["gm"] = 13] = "gm";
        EModuleType[EModuleType["guide"] = 14] = "guide";
        EModuleType[EModuleType["prop"] = 15] = "prop";
        EModuleType[EModuleType["rank"] = 16] = "rank";
    })(EModuleType = apeng.EModuleType || (apeng.EModuleType = {}));
    /**平台逻辑模块 */
    let EPlatformLogicType;
    (function (EPlatformLogicType) {
        EPlatformLogicType[EPlatformLogicType["banner"] = 100] = "banner";
        EPlatformLogicType[EPlatformLogicType["blockOnce"] = 101] = "blockOnce";
        EPlatformLogicType[EPlatformLogicType["interstitial"] = 102] = "interstitial";
        EPlatformLogicType[EPlatformLogicType["nativeTemp"] = 103] = "nativeTemp";
        EPlatformLogicType[EPlatformLogicType["record"] = 104] = "record";
        EPlatformLogicType[EPlatformLogicType["rewardedVideo"] = 105] = "rewardedVideo";
        EPlatformLogicType[EPlatformLogicType["share"] = 106] = "share";
        EPlatformLogicType[EPlatformLogicType["vibrate"] = 107] = "vibrate";
    })(EPlatformLogicType = apeng.EPlatformLogicType || (apeng.EPlatformLogicType = {}));
    /**底层平台 */
    let EPlatformType;
    (function (EPlatformType) {
        EPlatformType[EPlatformType["web"] = 99] = "web";
        EPlatformType[EPlatformType["wx"] = 1] = "wx";
        EPlatformType[EPlatformType["qq"] = 2] = "qq";
        EPlatformType[EPlatformType["tt"] = 3] = "tt";
        EPlatformType[EPlatformType["vivo"] = 4] = "vivo";
        EPlatformType[EPlatformType["oppo"] = 5] = "oppo";
        /**华为 */
        EPlatformType[EPlatformType["hbs"] = 7] = "hbs";
        EPlatformType[EPlatformType["xiaomi"] = 8] = "xiaomi";
        /**海外xgame */
        EPlatformType[EPlatformType["overseas_android_xgame"] = 10] = "overseas_android_xgame";
        EPlatformType[EPlatformType["a360"] = 11] = "a360";
        /**快手海外 */
        EPlatformType[EPlatformType["overseas_kwai"] = 12] = "overseas_kwai";
        /**微游h5 */
        EPlatformType[EPlatformType["overseas_weiyou"] = 13] = "overseas_weiyou";
        /**国内快手 */
        EPlatformType[EPlatformType["ks"] = 14] = "ks";
        EPlatformType[EPlatformType["ios"] = 15] = "ios";
    })(EPlatformType = apeng.EPlatformType || (apeng.EPlatformType = {}));
    let ELanguageType;
    (function (ELanguageType) {
        /**中文 */
        ELanguageType[ELanguageType["chinese"] = 0] = "chinese";
        /**繁体 */
        ELanguageType[ELanguageType["traditional"] = 1] = "traditional";
        /**英语 */
        ELanguageType[ELanguageType["english"] = 2] = "english";
        /**西班牙 */
        ELanguageType[ELanguageType["spanish"] = 3] = "spanish";
        /**越南 */
        ELanguageType[ELanguageType["vietnamese"] = 4] = "vietnamese";
        /**巴西葡萄牙 */
        ELanguageType[ELanguageType["portuguese"] = 5] = "portuguese";
        /**印尼 */
        ELanguageType[ELanguageType["indonesia"] = 6] = "indonesia";
    })(ELanguageType = apeng.ELanguageType || (apeng.ELanguageType = {}));
    /**切换语言ui里面 显示的文本 */
    apeng.CLanguageName = {
        [ELanguageType.chinese]: "简体中文",
        [ELanguageType.traditional]: "繁体中文",
        [ELanguageType.english]: "English",
    };
})(apeng || (apeng = {}));

(function (apeng) {
    const CValueByString = [
        [1e3, "K"],
        [1e6, "M"],
        [1e9, "B"],
        [1e12, "T"],
        [1e15, "Q"],
    ];
    class Maths {
        /**
         *
         * @param num
         * @param fixed 小数后几位
         * @returns
         */
        static valueByString(num, fixed = 1) {
            if (num < 1000)
                return num + "";
            for (let i = 0; i < CValueByString.length; i++) {
                let cur = CValueByString[i];
                let last = CValueByString[i + 1];
                if (num >= cur[0] && (!last || num < last[0])) {
                    let v = num / cur[0];
                    if (v < 100)
                        return Maths.toFixed(v, fixed) + cur[1];
                    else
                        return Math.floor(v) + cur[1];
                }
            }
            return "";
        }
        /**
         * 两个数是否在范围内
         * @param value1
         * @param value2
         * @param range
         */
        static isRange(value1, value2, range) {
            return Math.abs(value1 - value2) <= range;
        }
        /**
         * 判断一个数是否为偶数
         * @param {number} value
         * @returns {boolean}
         */
        static isEven(value) {
            return value % 2 == 0;
        }
        /**
         * 把角度换算成弧度
         * @param a
         */
        static toRadian(a) {
            return a * Maths._d2r;
        }
        /**
         * 取value的小数部分
         * @param value
         */
        static decimal(value) {
            value = value - (Math.floor(value));
            return value;
        }
        /**
         * 把弧度换算成角度。
         * @param a
         */
        static toDegree(a, is_ormalize = true) {
            if (a == undefined)
                return 0;
            if (is_ormalize)
                a = this.normalizeRadian(a);
            return a * Maths._r2d;
        }
        /**归一化弧度 转换为 0~2PI*/
        static normalizeRadian(angle) {
            angle = angle % Maths.PI2;
            if (angle < 0)
                angle += Maths.PI2;
            return angle;
        }
        /**归一化角度 转换为 0~360*/
        static normalizeAngle(angle) {
            angle %= 360;
            if (angle < 0)
                angle = angle + 360;
            return angle;
        }
        /**
         * 两个数字之间的线性插值，比率设置其偏向每一端的程度
         * a + (b - a) * r
         * @method lerp
         * @param {Number} a number A
         * @param {Number} b number B
         * @param {Number} r ratio between 0 and 1
         * @param {Number} fuzzyEquals 校验ab范围 如达到了 返回null
         * @return {Number}
         * @example
         * var a = Maths.lerp(0, 1, .2); // .2
         * var b = Maths.lerp(1, 2, .5); // 1.5
         * var b = Maths.lerp(1, 2, .2); // 1.2
         */
        static lerp(a, b, r) {
            return a + (b - a) * r;
        }
        /**
         * 限定浮点数的取值范围为 0 ~ 1 之间
         * @method clamp01
         * @param {Number} value
         * @return {Number}
         * @example
         * var v1 = Maths.clamp01(20);  // 1;
         * var v2 = Maths.clamp01(-1);  // 0;
         * var v3 = Maths.clamp01(0.5); // 0.5;
         */
        static clamp01(value) {
            return value < 0 ? 0 : value < 1 ? value : 1;
        }
        /**
         * 限定浮点数的最大最小值
         * 数值大于 max 则返回 max
         * 数值小于 min 则返回 min
         * 否则返回自身
         * @method clampf
         * @param {Number} value
         * @param {Number} min
         * @param {Number} max
         * @return {Number}
         * @example
         * var v1 = Maths.clampf(20, 0, 20); // 20;
         * var v2 = Maths.clampf(-1, 0, 20); //  0;
         * var v3 = Maths.clampf(10, 0, 20); // 10;
         */
        static clampf(value, min, max) {
            if (min > max) {
                var temp = min;
                min = max;
                max = temp;
            }
            return value < min ? min : value < max ? value : max;
        }
        /**
         * true  在范围内
         * @param value
         * @param min
         * @param max
         */
        static isClampf(value, min, max) {
            if (min > max) {
                var temp = min;
                min = max;
                max = temp;
            }
            if (value <= max && value >= min)
                return true;
            else
                return false;
        }
        /**
         * 随机值与`value`比较
         * 数值 0 ～ value 返回true
         * 数值 1 ～ value 返回false
         * @param {number} value
         * @returns {boolean}
         * @example
         * var a = Maths.isRandom(0.5);
         */
        static isRandom(value, random) {
            if (!value)
                return false;
            if (value >= 1)
                return true;
            if (value <= 0)
                return false;
            if (!random)
                random = Math.random();
            return value > random;
        }
        /**
         * @param min
         * @param max
         * @param is_int 默认转换为整型
         * @returns 返回 min - max 的值， 包括 min max
         */
        static minToMax(min, max, isInt = true, random) {
            if (min == max)
                return min;
            if (!random)
                random = Math.random();
            if (min < 0) {
                if (isInt)
                    return Math.round(random * (Math.abs(min) + max)) + min;
                else
                    return random * (Math.abs(min) + max) + min;
            }
            if (isInt)
                return Math.round(random * (max - min)) + min;
            else
                return random * (max - min) + min;
        }
        /**
         * 返回 0 到 max
         * @param max
         * @returns {0 ~ max} 不包括 max
         * @example
         * var a = Maths.zeroToMax(10); // 3
         * var b = Maths.zeroToMax(1); // 0
         */
        static zeroToMax(max, random) {
            if (max <= 1)
                return 0;
            if (!random)
                random = Math.random();
            return Math.floor((random == 1 ? 0.5 : random) * max);
        }
        static toFixed(value, count) {
            let mul = Math.pow(10, count);
            return Math.floor(value * mul) / mul;
        }
        static arrAdd(value) {
            let count = 0;
            for (let num of value)
                count += num;
            return count;
        }
        /**
         * 找到num在arr所在的区间
         * @param arr
         * @param num
         * @param num
         * @param isContainNum 是否=
         */
        static findNumSection(arr, num, out, isContainNum = false) {
            if (!out)
                out = { i: 0, count: 0 };
            out.i = arr.length;
            out.count = 0;
            for (let i = 0; i < arr.length; i++) {
                out.count += arr[i];
                if (isContainNum) {
                    if (num <= out.count) {
                        out.i = i;
                        return out;
                    }
                }
                else if (num < out.count) {
                    out.i = i;
                    return out;
                }
            }
            return out;
        }
        /**
         * 权重随机
         * @param arr
         * @returns 数组索引
         */
        static widgetRandom(arr) {
            let rand = this.arrAdd(arr) * Math.random();
            let last = 0;
            for (let i = 0; i < arr.length; i++) {
                let value = arr[i];
                if (rand >= last && rand < last + value)
                    return i;
                last += value;
            }
            return arr.length - 1;
        }
        static keep2Decimal(val) {
            return (Math.floor(val * 100)) / 100;
        }
    }
    Maths.PI = Math.PI;
    Maths.PI2 = Math.PI * 2;
    Maths._d2r = Maths.PI / 180.0;
    Maths._r2d = 180.0 / Maths.PI;
    apeng.Maths = Maths;
})(apeng || (apeng = {}));
/// <reference path="./Maths.ts" />

(function (apeng) {
    /**
     * 数组的二次封装
     * 内置去重处理
     * @export
     * @class Sets
     * @template T
     */
    class Sets {
        /**
         *
         * @param {boolean} [isRepeat=true] 去重
         * @param {...T[]} values
         * @memberof Sets
         */
        constructor(isRepeat = true, ...values) {
            this.values = [];
            /**是否对数组进行去重处理 */
            this.isRepeat = true;
            this.isRepeat = isRepeat;
            this.add(...values);
        }
        static forEach(arr, cb, isLast = false) {
            if (isLast) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (cb(arr[i], i))
                        break;
                }
            }
            else {
                for (let i = 0; i < arr.length; i++) {
                    if (cb(arr[i], i))
                        break;
                }
            }
        }
        /**
         * 更新个数
         * @param curCount
         * @param oldCount
         * @param itemCb
         */
        static updateItemCount(curCount, oldCount, itemCb) {
            if (curCount < 0 || oldCount < 0)
                return;
            if (curCount == oldCount)
                return;
            let sub = curCount - oldCount;
            if (sub > 0)
                for (let i = 0; i < sub; i++)
                    itemCb(true);
            else
                for (let i = 0, length = Math.abs(sub); i < length; i++)
                    itemCb(false);
        }
        static pop(arr, remove = false) {
            if (remove)
                return arr.pop();
            return arr[arr.length - 1];
        }
        static delete(arr, value) {
            if (value == undefined || value == null)
                return false;
            if (arr.length == 0)
                return false;
            let index = arr.indexOf(value);
            if (index == -1)
                return false;
            arr.splice(index, 1);
            return true;
        }
        /**
         * 冒泡排序
         * @param arr
         * @param cb
         */
        static bubblingSort(arr, cb) {
            let size = arr.length;
            for (let i = 0; i < size - 1; i++)
                for (let j = 0; j < size - 1 - i; j++) {
                    if (cb(arr[j], arr[j + 1])) {
                        let temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
        }
        static reverse(arr) {
            for (var i = 0; i < arr.length / 2; i++) {
                var temp = arr[i];
                arr[i] = arr[arr.length - 1 - i];
                arr[arr.length - 1 - i] = temp;
            }
            return arr;
        }
        static map(arr, cb) {
            let set = [];
            for (let i = 0; i < arr.length; i++) {
                let data = cb(arr[i], i, arr);
                set.push(data);
            }
            return set;
        }
        static has(arr, value, stringCompare = false) {
            if (!arr)
                return false;
            if (arr.length == 0)
                return false;
            let index;
            if (stringCompare)
                index = this.map(arr, v => v.toString()).indexOf(value.toString());
            else
                index = arr.indexOf(value);
            return index != -1;
        }
        static add(arr, ...values) {
            for (let i = 0; i < values.length; i++) {
                let value = values[i];
                if (this.has(arr, value))
                    continue;
                arr.push(value);
            }
        }
        /**
         * 随机一个自身的值
         * @param value
         * @param exclude  ture 排除
         */
        static random(value, exclude, random) {
            if (value.length == 0)
                return null;
            // 从排除的数据中查找
            if (exclude) {
                let values = [];
                for (let i = 0, l = value.length; i < l; i++)
                    if (!exclude(value[i], i))
                        values.push(value[i]);
                return this.random(values);
            }
            return value[apeng.Maths.zeroToMax(value.length, random ? random() : Math.random())];
        }
        /**
     * 随机一个自身的值
     * @param value
     * @param exclude 排除
     */
        static randomOf(value, exclude, random) {
            if (value.length == 0)
                return null;
            // 从排除的数据中查找
            if (exclude) {
                let values = [];
                for (let i = 0, l = value.length; i < l; i++)
                    if (!exclude(value[i], i))
                        values.push(value[i]);
                return this.randomOf(values);
            }
            return apeng.Maths.zeroToMax(value.length, random ? random() : Math.random());
        }
        /**获取值如index超出个数 则取最后一个 */
        static getAt(value, index) {
            index = apeng.Maths.clampf(index, 0, value.length - 1);
            return value[index];
        }
        /**
         * 筛选 cb => true 的值 如没有 返回 null!
         * @param {(value: T, index: number) => boolean} cb
         * @returns {T}
         * @memberof Sets
         */
        static filterValue(values, cb, isLast = false) {
            let idx = this.filterOf(values, cb, isLast);
            if (idx == -1)
                return null;
            return values[idx];
        }
        /**
         * 插入值
         * @param values
         * @param insertIndex
         * @param getIndex
         */
        static insert(values, value, index) {
            let back = values.splice(index);
            values.push(value);
            values.push(...back);
            return values;
        }
        /**
         * 筛选 cb => true 的索引
         * @param {(value: T, index: number) => boolean} cb
         * @returns {number}
         * @memberof Sets
         */
        static filterOf(arr, cb, isLast = false) {
            if (isLast) {
                for (let i = arr.length - 1; i >= 0; i--)
                    if (arr[i] !== undefined && cb(arr[i], i))
                        return i;
            }
            else {
                for (let i = 0; i < arr.length; i++)
                    if (arr[i] !== undefined && cb(arr[i], i))
                        return i;
            }
            return -1;
        }
        static filter(values, cb, out) {
            if (!out)
                out = [];
            for (let i = 0; i < values.length; i++) {
                if (values[i] !== undefined && cb(values[i], i)) {
                    out.push(values[i]);
                }
            }
            return out;
        }
        static push(values, push) {
            if (Array.isArray(push))
                for (let value of push)
                    values.push(value);
            else
                values.push(push);
            return values;
        }
        /**越大的越在前 */
        static sortMax(values, cb) {
            return values.sort((a, b) => cb(b) - cb(a));
        }
        /**越小的越在前 */
        static sortMin(values, cb) {
            return values.sort((a, b) => cb(a) - cb(b));
        }
        /**
         * 打乱数组, 默认改变
         * @param {boolean} [isChangeOriginal=true] 是否改变原数组
         * @returns {any[]}
         */
        static shuffle(arr, isChangeOriginal = true, random) {
            if (!random)
                random = Math.random;
            if (!isChangeOriginal) {
                let tmp = arr.concat();
                tmp.sort((a, b) => {
                    return random() > .5 ? 1 : -1;
                });
                return tmp;
            }
            else {
                arr.sort((a, b) => {
                    return random() > .5 ? 1 : -1;
                });
                return arr;
            }
        }
        /**
         * 随机取count个数据
         * @param vlaues
         * @param count
         */
        static randomArray(values, count = 1) {
            let res = this.shuffle(values, false), arr = [];
            for (let i = 0; i < count; i++)
                if (res[i])
                    arr.push(res[i]);
            return arr;
        }
        get size() {
            return this.values.length;
        }
        indexOf(value) {
            return this.values.indexOf(value);
        }
        clear() {
            this.values.length = 0;
        }
        ;
        /**
         * 拿下标第一个的值 默认删除第一个
         * @param {boolean} [isOrign=true] 是否删除第一个
         * @returns {T}
         * @memberof Sets
         */
        shift(isOrign = true) {
            if (isOrign)
                return this.values.shift();
            else
                return this.values.concat()[0];
        }
        toString() { return this.values.toString(); }
        forEach(cb, isLast = false) { Sets.forEach(this.values, cb, isLast); return this; }
        add(...values) { Sets.add(this.values, ...values); return this; }
        delete(value) { return Sets.delete(this.values, value); }
        has(value, stringCompare = false) { return Sets.has(this.values, value, stringCompare); }
        map(cb) { return Sets.map(this.values, cb); }
        filterOf(cb) { return Sets.filterOf(this.values, cb); }
        filterValue(cb) { return Sets.filterValue(this.values, cb); }
        filter(cb) { return Sets.filter(this.values, cb, []); }
    }
    apeng.Sets = Sets;
})(apeng || (apeng = {}));

(function (apeng) {
    /**单个池子 */
    class PoolOnce {
        constructor(maxCount, onObj, onClear, onDestroy) {
            this.maxCount = maxCount;
            this.onObj = onObj;
            this.onClear = onClear;
            this.onDestroy = onDestroy;
            this.data = [];
        }
        /**实例化个数 */
        instantiate(size) {
            for (let i = 0; i < size; i++) {
                let obj = this.onObj();
                this.data[this.data.length] = obj;
            }
        }
        get() {
            let data = this.data.pop();
            if (!data)
                data = this.onObj();
            this.onClear(data);
            return data;
        }
        put(data) {
            this.onClear(data);
            let length = this.data.length;
            if (length > this.maxCount) {
                let destroyValue = this.data.shift();
                if (destroyValue) {
                    this.onClear(destroyValue);
                    if (this.onDestroy)
                        this.onDestroy(destroyValue);
                }
                this.put(data);
            }
            else
                this.data[length] = data;
        }
        clear() {
            for (let _data of this.data) {
                this.onClear(_data);
                if (this.onDestroy)
                    this.onDestroy(_data);
            }
            this.data.length = 0;
        }
        size() { return this.data.length; }
    }
    apeng.PoolOnce = PoolOnce;
    /**多池子 */
    class Pool {
        constructor(maxCount, onObj, onClear, onDestroy) {
            this.maxCount = maxCount;
            this.onObj = onObj;
            this.onClear = onClear;
            this.onDestroy = onDestroy;
            this.datas = new Map();
        }
        /**实例化个数 */
        instantiate(url, size) { return this.pool(url).instantiate(size); }
        get(url) { return this.pool(url).get(); }
        put(data) { return this.pool(data.poolLoadUrl).put(data); }
        clear() {
            this.datas.forEach((pool, k) => pool.clear());
            this.datas.clear();
        }
        size() {
            let count = 0;
            this.datas.forEach(pool => {
                count += pool.size();
            });
            return count;
        }
        pool(url) {
            let data = this.datas.get(url);
            if (!data) {
                data = new PoolOnce(this.maxCount, () => {
                    let obj = this.onObj(url);
                    obj.poolLoadUrl = url;
                    return obj;
                }, (_data) => this.onClear(_data, url), this.onDestroy ? (_data) => this.onDestroy(_data, url) : null);
                // 默认池子
                this.datas.set(url || "pool", data);
            }
            return data;
        }
    }
    apeng.Pool = Pool;
    /**池子数组 */
    class PoolArray {
        constructor(pool) {
            this.pool = pool;
            this.data = [];
        }
        clear() {
            for (let _data of this.data)
                this.pool.put(_data);
            this.data.length = 0;
        }
        add() {
            let data = this.pool.get();
            this.data[this.data.length] = data;
            return data;
        }
        size() {
            return this.data.length;
        }
        get(index) { return this.data[index]; }
    }
    apeng.PoolArray = PoolArray;
    apeng.CPoolArray = new PoolOnce(100000, () => [], data => data.length = 0);
})(apeng || (apeng = {}));

(function (apeng) {
    /**异步计数 */
    class LoadDir {
        constructor(count, onFinish, onSub, logPrefix = "") {
            this.count = 0;
            this.onFinish = null;
            this.onSub = null;
            this.logPrefix = "";
            this.count = count;
            this.onSub = onSub;
            this.onFinish = onFinish;
            this.logPrefix = logPrefix;
        }
        subCount(data) {
            return () => {
                this.count--;
                if (this.count < 0) {
                    console.error("引用计数错误");
                    // debugger
                }
                if (this.logPrefix)
                    console.log("引用计数:" + this.logPrefix + "-" + this.count);
                if (this.onSub)
                    this.onSub(data);
                if (this.count <= 0)
                    if (this.onFinish)
                        this.onFinish();
            };
        }
    }
    apeng.LoadDir = LoadDir;
})(apeng || (apeng = {}));
/// <reference path="./Sets.ts" />
/// <reference path="./Pool.ts" />
/// <reference path="./LoadDir.ts" />

(function (apeng) {
    class Queue {
        constructor(complete = null, interval = -1, log = "") {
            this.complete = complete;
            this.interval = interval;
            this.log = log;
            this.loadDir = new apeng.LoadDir(0, null);
            this.values = [];
            this._values = [];
            this.isRun = false;
        }
        add(cb, run = false) {
            this.values.push(cb);
            if (run)
                this._values.push(cb);
            return this;
        }
        remove(index) {
            let value = this.values[index];
            if (value) {
                apeng.Sets.delete(this._values, value);
                this.values[index] = null;
            }
        }
        remove2(cb) {
            let index = this.values.indexOf(cb);
            if (index != -1)
                this.remove(index);
        }
        has(index) {
            return !!this.values[index];
        }
        runIndex(index, complete = () => { }) {
            let value = this.values[index];
            if (value) {
                value(complete);
                this.remove(index);
            }
        }
        /**
         * 开始运行
         * @param count 并发个数
         * @returns
         */
        run(count = 1) {
            if (!this.isRun) {
                this._values.length = 0;
                for (let value of this.values)
                    if (value)
                        this._values.push(value);
            }
            this.isRun = true;
            let value = this._values.splice(0, count);
            if (value.length == 0) {
                this.isRun = false;
                if (this.complete)
                    this.complete();
                return;
            }
            if (this.log) {
                if (typeof this.log == "function")
                    console.log("Queue run " + this.log(this.values.length - this._values.length - 1));
                else
                    console.log("Queue run " + this.log, this.values.length - this._values.length);
            }
            let complete = () => {
                if (this.interval != 0)
                    setTimeout(this.run.bind(this, count), this.interval * 1000);
                else
                    this.run(count);
            };
            if (count == 1)
                value[0](complete);
            else {
                this.loadDir.onFinish = complete;
                this.loadDir.count = value.length;
                for (let _value of value)
                    _value(this.loadDir.subCount());
            }
        }
        clear() {
            // TimerMgr.clearAll(this)
            this.values.length = 0;
        }
        dispose() {
            this.clear();
            this.complete = null;
            this.interval = -1;
            this.isRun = false;
            this.log = "";
        }
    }
    Queue.pool = new apeng.PoolOnce(100, () => new Queue(), (data) => data.dispose());
    apeng.Queue = Queue;
})(apeng || (apeng = {}));
/// <reference path="./Sets.ts" />
/// <reference path="./Queue.ts" />

(function (apeng) {
    apeng.EventDispatcherEventType = {
        ON: "ON",
        OFF: "OFF",
        CLEAR: "CLEAR",
    };
    class EventDispatcher {
        constructor() {
            this.eventMap = new Map();
        }
        /**
         * 注册事件
         * @param eventName
         * @param callBack 派发队列事件 则( 按照优先级一个一个派发  第一个参数回调 complete 完成了后进行下一个)
         * @param caller
         * @param priority 优先级 由小往大执行
         */
        on(eventName, callBack, caller, priority = 0) {
            if (typeof priority != "number")
                throw new Error("检查注册事件");
            let handler = this.eventMap.get(eventName);
            if (!handler) {
                handler = [];
                this.eventMap.set(eventName, handler);
            }
            handler.push({ callBack, caller, priority });
            apeng.Sets.sortMin(handler, a => a.priority);
            this.emit(apeng.EventDispatcherEventType.ON);
            return callBack;
        }
        /**
         * 如不返回 或返回为true则注销
         * @param eventName
         * @param callBack
         * @param caller
         * @returns
         */
        once(eventName, callBack, caller, priority = 0) {
            let _this = this;
            let _callBack = function () {
                let isOff = callBack.apply(caller, arguments);
                if (isOff == undefined || isOff)
                    _this.off(eventName, _callBack, caller);
            };
            this.on(eventName, _callBack, caller, priority);
            return _callBack;
        }
        off(eventName, callBack, caller) {
            let handler = this.eventMap.get(eventName);
            if (!handler)
                return;
            for (let i = 0; i < handler.length; i++) {
                let event = handler[i];
                if (event && event.callBack == callBack && event.caller == caller) {
                    handler.splice(i, 1);
                    this.emit(apeng.EventDispatcherEventType.OFF);
                    return;
                }
            }
        }
        offAll(eventName) {
            return this.eventMap.delete(eventName);
        }
        emit(eventName, ...param) {
            let handler = this.eventMap.get(eventName);
            let res = [];
            if (!handler)
                return res;
            // 拷贝数组 以免中途删除
            handler = [...handler];
            for (let event of handler)
                res.push(event.callBack.apply(event.caller, param));
            return res;
        }
        /**
         * 派发队列事件
         * @param eventName
         * @param complete
         * @param param
         * @returns
         */
        emitQueue(eventName, interval = -1, complete, log = "", ...param) {
            let handler = this.eventMap.get(eventName);
            if (!handler) {
                if (complete)
                    complete();
                return null;
            }
            // 拷贝数组 以免中途删除
            handler = [...handler];
            if (handler.length == 0) {
                if (complete)
                    complete();
                return null;
            }
            let queue = apeng.Queue.pool.get();
            queue.interval = interval;
            queue.log = log;
            queue.complete = () => {
                if (complete)
                    complete();
                apeng.Queue.pool.put(queue);
            };
            for (let event of handler)
                queue.add((queueComplete) => {
                    event.callBack.call(event.caller, queueComplete, ...param);
                });
            queue.run();
            return queue;
        }
        hasEvent(eventName, callBack, caller) {
            let handler = this.eventMap.get(eventName);
            if (!handler)
                return false;
            for (let event of handler) {
                if (event && event.callBack == callBack && event.caller == caller)
                    return true;
            }
            return false;
        }
        hasEventName(eventName) {
            let handler = this.eventMap.get(eventName);
            if (!handler)
                return false;
            if (handler.length == 0)
                return false;
            return true;
        }
        clearEvent() {
            this.eventMap.clear();
            this.emit(apeng.EventDispatcherEventType.CLEAR);
        }
    }
    apeng.EventDispatcher = EventDispatcher;
})(apeng || (apeng = {}));
/// <reference path="./Maths.ts" />
/// <reference path="./Sets.ts" />

(function (apeng) {
    /**
     * Object 二次封装
     * 优化增删改查操作
     *  key 只能是 number | string
     * @export
     * @class Maps
     * @template K
     * @template V
     */
    class Maps {
        /**
         *Creates an instance of Maps.
         * @param {Object} [obj] 将一个对象转换为 Maps结构
         * @memberof Maps
         */
        constructor(obj) {
            this._values = {};
            /**判断key是number类型 */
            this.isKeyNumber = false;
            this._onceValue = null;
            this._lastKey = null;
            this._curKey = null;
            this.keyArray = [];
            this.setCount = 0;
            if (obj)
                for (let key in obj)
                    this.set(key, obj[key]);
        }
        /**
         * 筛选 cb => true 的值 如没有 返回 null
         * @param {(value: T, index: number) => boolean} cb
         * @returns {T}
         * @memberof Sets
         */
        static filterValue(values, cb) {
            let key = this.filterKey(values, cb);
            if (!key) {
                return null;
            }
            return values[key];
        }
        /**
         * 对象的个数
         * @param value
         */
        static size(value) {
            let count = 0;
            for (let k in value)
                count++;
            return count;
        }
        /**
         * 筛选 cb => true 的索引
         * @param {(value: T, index: number) => boolean} cb
         * @param isLast 倒着循环
         * @returns {number}
         * @memberof Sets
         */
        static filterKey(values, cb, isLast = false) {
            if (!isLast) {
                for (let key in values)
                    if (cb(values[key], key))
                        return key;
            }
            else {
                let keys = Maps.keys(values);
                for (let i = keys.length - 1; i >= 0; i--) {
                    let key = keys[i];
                    if (cb(values[key], key))
                        return key;
                }
            }
            return null;
        }
        /**取第一个value */
        static shiftKey(value) {
            for (let k in value)
                return k;
            return "";
        }
        /**取第一个value */
        static shiftValue(value) {
            for (let k in value)
                return value[k];
            return null;
        }
        /**
         * 将对象value值转换为数组
         * @param value
         */
        static converValueArray(value) {
            let values = [];
            for (let key in value)
                values.push(value[key]);
            return values;
        }
        /**
         *
         * @param value 数据
         * @param cb 每次循环回调 返回true终止循环
         * @param isDeleteChild 循环中删除了子节点也会进入循环
         */
        static forEach(value, cb, isDeleteChild = false) {
            if (isDeleteChild) {
                let values = [];
                let keys = [];
                // 防止循环删除数据
                for (let k in value) {
                    values.push(value[k]);
                    keys.push(k);
                }
                for (let i = 0; i < values.length; i++) {
                    if (!values[i])
                        continue;
                    if (cb)
                        if (cb(values[i], keys[i], i))
                            break;
                }
            }
            else {
                let i = -1;
                for (let k in value) {
                    i++;
                    if (!value[k])
                        continue;
                    if (cb)
                        if (cb(value[k], k, i))
                            break;
                }
            }
        }
        /**随机取一个 V */
        static randomValue(values, exclude) {
            if (this.size(values) == 0)
                return null;
            let res = this.values(values, exclude);
            return res[apeng.Maths.zeroToMax(res.length)];
        }
        /**随机取一个 V */
        static randomKey(values, exclude) {
            if (this.size(values) == 0)
                return null;
            let res = this.keys(values, exclude);
            return res[apeng.Maths.zeroToMax(res.length)];
        }
        static values(values, exclude, out) {
            if (out == undefined)
                out = [];
            for (let key in values)
                if (exclude) {
                    if (!exclude(values[key], key))
                        out.push(values[key]);
                }
                else
                    out.push(values[key]);
            return out;
        }
        static map(values, cb) {
            let _value = {};
            for (let key in values)
                _value[key] = cb(values[key], key);
            return _value;
        }
        static keys(values, exclude, out) {
            if (out == undefined)
                out = [];
            for (let key in values)
                if (exclude) {
                    if (!exclude(values[key], key))
                        out.push(key);
                }
                else
                    out.push(key);
            return out;
        }
        static valuesMap(values, cb) {
            let res = [];
            for (let k in values) {
                res.push(cb(k, values[k]));
            }
            return res;
        }
        get length() {
            return this.keyArray.length;
        }
        set(key, value) {
            this.isKeyNumber = (typeof key == "number");
            if (this._curKey != null)
                this._lastKey = this._curKey;
            this._curKey = key;
            this._values[key] = value;
            if (!this._onceValue)
                this._onceValue = value;
            apeng.Sets.add(this.keyArray, key);
            this.setCount++;
            return this;
        }
        has(key) {
            let value = this._values[key];
            return !(value == null || value == undefined || value === false);
        }
        get(key) {
            return this._values[key];
        }
        gets(keys) {
            let values = [];
            for (let i = 0; i < keys.length; i++) {
                let value = this.get(keys[i]);
                if (value)
                    values.push(value);
            }
            return values;
        }
        /**通过value 获取添加时的索引 */
        getValueByIndex(value) {
            return apeng.Sets.filterOf(this.keyArray, v => this.get(v) == value);
        }
        delete(key) {
            apeng.Sets.delete(this.keyArray, key);
            let value = this._values[key];
            if (value == this._onceValue)
                this._onceValue = null;
            if (this._curKey == key) {
                this._curKey = this._lastKey;
                this._lastKey = null;
            }
            delete this._values[key];
        }
        clear() {
            this.keyArray.length = 0;
            this._onceValue = null;
            this._lastKey = null;
            this._curKey = null;
            this._values = {};
            this.setCount = 0;
        }
        /**取第一个value */
        shiftValue() {
            if (this._onceValue)
                return this._onceValue;
            return Maps.shiftValue(this._values);
        }
        /**取上一个value */
        lastValue() {
            return this.get(this._lastKey);
        }
        /**取上当前value */
        curValue() {
            return this.get(this._curKey);
        }
        converKey(key) {
            return this.isKeyNumber ? Number(key) : key;
        }
        /**
         *
         * @param cb
         * @param isLast 从后往前便利
         */
        forEachArray(cb, isLast = false) {
            apeng.Sets.forEach(this.keyArray, (value, index) => {
                if (cb(this._values[value], value, index))
                    return true;
                return false;
            }, isLast);
        }
        get size() { return Maps.size(this._values); }
        filterValue(cb) { return Maps.filterValue(this._values, cb); }
        filterKey(cb) { return Maps.filterKey(this._values, cb); }
        randomValue() { return Maps.randomValue(this._values); }
        values(exclude, out) { return Maps.values(this._values, exclude, out); }
        keys() { return Maps.keys(this._values); }
        valuesMap(cb) { return Maps.valuesMap(this._values, cb); }
        forEach(cb, isDeleteChild = false) {
            Maps.forEach(this._values, (value, key) => {
                key = this.isKeyNumber ? Number(key) : key;
                return cb(value, key);
            }, isDeleteChild);
            return this;
        }
    }
    apeng.Maps = Maps;
})(apeng || (apeng = {}));

(function (apeng) {
    class JS {
        /**
         * 获取枚举 value为number的值
         * @param enums
         * @param cb
         * @returns
         */
        static getEnumValue(enums, cb) {
            let values = [];
            for (let key in enums) {
                let value = enums[key];
                if (typeof value == "number") {
                    values.push(value);
                    if (cb)
                        cb(value);
                }
            }
            return values;
        }
        static getEnumByNums(enums) {
            if (!enums["__num__"]) {
                enums["__num__"] = [];
                for (let key in enums) {
                    let value = enums[key];
                    if (typeof value == "number")
                        enums["__num__"].push(value);
                }
                // 越小的越在前
                enums["__num__"].sort((a, b) => a - b);
            }
            return enums["__num__"];
        }
        static promiseDelay(delay) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise(res => setTimeout(res, delay * 1000));
            });
        }
        /**深拷贝类 只拷贝一层 */
        static minxi(value) {
            if (value === null || value === undefined || value === 0 || value === "")
                return value;
            let target = null;
            if (typeof value === "object")
                target = this._mixin(Array.isArray(value) ? [] : {}, value);
            else
                target = value;
            return target;
        }
        static deep(value) {
            if (value == null)
                return value;
            if (typeof value == "object")
                return JSON.parse(JSON.stringify(value));
            return value;
        }
        static parseArray(str) {
            if (!str)
                return [];
            return JSON.parse(str);
        }
        static _copyprop(name, source, target) {
            let pd = this._getPropertyDescriptor(source, name);
            Object.defineProperty(target, name, pd);
        }
        static _getPropertyDescriptor(obj, name) {
            while (obj) {
                let pd = Object.getOwnPropertyDescriptor(obj, name);
                if (pd)
                    return pd;
                obj = Object.getPrototypeOf(obj);
            }
            return null;
        }
        /**
       * 判断是否为空对象
       * @param {Object} obj
       * @returns {boolean}
       * @memberof Maps
       */
        static isNullObj(obj) {
            if (!obj)
                return false;
            // if (Object.keys(obj).length != 0)
            // 	return false;
            for (let key in obj)
                return false;
            return true;
        }
        static isValid(value) {
            if (value == null || value == undefined || value === false)
                return false;
            return true;
        }
        static _mixin(obj, ...sourceObj) {
            obj = obj || {};
            for (let i = 1, length = arguments.length; i < length; i++) {
                let source = arguments[i];
                if (source) {
                    if (typeof source !== "object")
                        continue;
                    for (let name in source)
                        this._copyprop(name, source, obj);
                }
            }
            return obj;
        }
        /**
     * @param filename  文件名   a.txt
     * @param content 内容
     * @param contentType  头部
     */
        static download(filename, content, contentType) {
            if (!contentType)
                contentType = 'application/octet-stream';
            var a = document.createElement('a');
            var blob = new Blob([content], { 'type': contentType });
            a.href = window.URL.createObjectURL(blob);
            a.download = filename;
            a.click();
        }
        static isPromise(obj) {
            return !!obj //有实际含义的变量才执行方法，变量null，undefined和''空串都为false
                && (typeof obj === 'object' || typeof obj === 'function') // 初始promise 或 promise.then返回的
                && typeof obj.then === 'function';
        }
        /**写入文本到粘贴板 */
        static copyContent(text) {
            let fn = () => {
                // 复制结果
                let copyResult = true;
                // 创建一个input元素
                let inputDom = document.createElement('textarea');
                // 设置为只读 防止移动端手机上弹出软键盘  
                inputDom.setAttribute('readonly', 'readonly');
                // 给input元素赋值
                inputDom.value = text;
                // 将创建的input添加到body
                document.body.appendChild(inputDom);
                // 选中input元素的内容
                inputDom.select();
                // 执行浏览器复制命令
                // 复制命令会将当前选中的内容复制到剪切板中（这里就是创建的input标签中的内容）
                // Input要在正常的编辑状态下原生复制方法才会生效
                const result = document.execCommand('copy');
                // 判断是否复制成功
                if (result) {
                    console.log('复制成功');
                }
                else {
                    console.log('复制失败');
                    copyResult = false;
                }
                // 复制操作后再将构造的标签 移除
                document.body.removeChild(inputDom);
                // 返回复制操作的最终结果
                return copyResult;
            };
            // 复制结果
            let copyResult = true;
            // 判断是否支持clipboard方式
            if (!!window.navigator.clipboard) {
                // 利用clipboard将文本写入剪贴板（这是一个异步promise）
                window.navigator.clipboard.writeText(text).then((res) => {
                    console.log('复制成功');
                    // 返回复制操作的最终结果
                    return copyResult;
                }).catch((err) => {
                    console.log('复制失败--采取第二种复制方案', err);
                    // clipboard方式复制失败 则采用document.execCommand()方式进行尝试
                    fn();
                });
            }
            else {
                // 不支持clipboard方式 则采用document.execCommand()方式
                fn();
            }
        }
    }
    apeng.JS = JS;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Sets.ts" />
/// <reference path="./../utils/JS.ts" />

(function (apeng) {
    class BaseInstanceStorage {
        constructor(type, storage) {
            this.type = type;
            this.storage = storage;
        }
        set(key, value, isDelay) {
            this.storage.set(this.type, key, value, isDelay);
        }
        get(key, defaultValue) {
            return this.storage.get(this.type, key, defaultValue);
        }
        delete(key) {
            this.storage.delete(this.type, key);
        }
        getPrefixKeys(str) {
            return this.storage.getPrefixKeys(BaseStorage.getKey(this.type, str));
        }
    }
    apeng.BaseInstanceStorage = BaseInstanceStorage;
    class BaseStorage {
        constructor(
        /**缓存接口 */
        localStorage, 
        /**延迟多长时间调用系统接口缓存(秒) */
        delayCache = .4, getObjData) {
            this.localStorage = localStorage;
            this.delayCache = delayCache;
            this.getObjData = getObjData;
            this.cache = {};
            /**需要更新的缓存 */
            this.updateCache = [];
            this.timeId = -1;
        }
        static getKey(type, key) { return type + "-" + key; }
        static parse(value) {
            if (value === undefined)
                return null;
            // 解析类型
            let type = value[0];
            value = value.substring(1);
            switch (type) {
                case "b":
                    value = value == "true";
                    break;
                case "n":
                    value = Number(value);
                    break;
                case "o":
                    value = JSON.parse(value);
                    break;
                case "s":
                    break;
                default:
                    value = null;
                    break;
            }
            return value;
        }
        byteSize(type) {
            let keys = this.getPrefixKeys(type + "-");
            let obj = {};
            let orgin = this.getObjData();
            for (let key of keys)
                obj[key] = orgin[key];
            let str = JSON.stringify(obj);
            return (str.length / 1024).toFixed(2) + "kb";
        }
        getPrefixKeys(prefix) {
            let obj = this.getObjData();
            let keys = [];
            for (let key in obj)
                if (key.indexOf(prefix) == 0)
                    keys.push(key);
            return keys;
        }
        /**
         * 设置缓存
         * @param {string} key
         * @param {string} value 与 get时类型保持一致 不能为 null undefined "null"
         * @param {boolean} isDelay 延迟缓存
         * @param {boolean} toServer 推送到服务端
         */
        set(type, key, value, isDelay = true) {
            key = BaseStorage.getKey(type, key);
            if (!this.checkCacheValue(value))
                return;
            this.cache[key] = value;
            apeng.Sets.add(this.updateCache, key);
            if (isDelay) {
                // 延迟调用系统缓存 避免高速存取耗费性能
                apeng._timer.once(this, this.onSet, this.delayCache);
            }
            else
                this.onSet();
        }
        /**
         * 拿缓存 如没 返回 null
         * @param {string} key
         * @param {T} defaultValue 返回当前值
         * @param {boolean} save 默认没有缓存时 写入本地
         */
        get(type, key, defaultValue) {
            key = BaseStorage.getKey(type, key);
            let value = this.cache[key];
            // 当前没缓存
            if (!this.checkCacheValue(value)) {
                value = this.localStorage.getItem(key);
                // 系统也没缓存
                if (!this.checkCacheValue(value))
                    value = apeng.JS.deep(defaultValue);
                else {
                    value = BaseStorage.parse(value);
                    if (value === null)
                        value = apeng.JS.deep(defaultValue);
                }
                this.cache[key] = value;
            }
            return this.cache[key];
        }
        has(type, key) {
            return !!this.get(type, key, null);
        }
        /**
         * 删除缓存
         * @param {string} key
         */
        delete(type, key) {
            key = BaseStorage.getKey(type, key);
            delete this.cache[key];
            this.localStorage.removeItem(key);
        }
        /**清除全部缓存 */
        clear(cb) {
            this.cache = {};
            if (cb)
                this.localStorage.clear(cb);
            else
                this.localStorage.clear();
        }
        checkCacheValue(value) {
            if (value === null || value === "null" || value === undefined || value === "")
                return false;
            return true;
        }
        onSet() {
            for (let key of this.updateCache) {
                let value = this.cache[key];
                let valueType = typeof value;
                switch (valueType) {
                    case "boolean":
                        value = value + "";
                        break;
                    case "number":
                        value = value + "";
                        break;
                    case "object":
                        value = JSON.stringify(value);
                        break;
                    case "string":
                        break;
                    default:
                        value = null;
                        break;
                }
                if (value != null)
                    // 加上类型缓存 方便解析
                    this.localStorage.setItem(key, valueType[0] + value);
            }
            this.updateCache.length = 0;
        }
    }
    apeng.BaseStorage = BaseStorage;
})(apeng || (apeng = {}));
/// <reference path="./BaseStorage.ts" />
/// <reference path="./../Main.ts" />

(function (apeng) {
    /**缓存接口 支持每帧调用*/
    apeng.StorageMgr = new apeng.BaseStorage(apeng.sys.localStorage, undefined, () => apeng.sys.localStorage);
    apeng.CStorageDefaultType = 1;
    /**不需要填写type字段的缓存接口 */
    apeng.StorageOnceMgr = new apeng.BaseInstanceStorage(apeng.CStorageDefaultType, apeng.StorageMgr);
    apeng.CDataStorage = new class {
        constructor() {
            this._data = {};
        }
        setItem(key, value) {
            // 有改变才进入
            if (value === this._data[key])
                return;
            this._data[key] = value;
        }
        removeItem(key) {
            delete this._data[key];
        }
        clear() {
            for (let key in this._data)
                delete this._data[key];
        }
        getItem(key) {
            return this._data[key];
        }
    };
    apeng.DataStorageMgr = new apeng.BaseStorage(apeng.CDataStorage, undefined, () => apeng.CDataStorage);
    /**临时变量 不写入缓存 */
    apeng.DataStorageOnceMgr = new apeng.BaseInstanceStorage(apeng.CStorageDefaultType, apeng.DataStorageMgr);
})(apeng || (apeng = {}));
/// <reference path="./../storage/BaseStorage.ts" />
/// <reference path="./../storage/StorageMgr.ts" />
/// <reference path="./../utils/EventDispatcher.ts" />

(function (apeng) {
    class BaseModule {
        constructor() {
            /**模块缓存 */
            this.storage = null;
        }
    }
    apeng.BaseModule = BaseModule;
    class BaseModuleEvent extends apeng.EventDispatcher {
        constructor() {
            super(...arguments);
            this.storage = null;
        }
    }
    apeng.BaseModuleEvent = BaseModuleEvent;
})(apeng || (apeng = {}));
/// <reference path="./../utils/EventDispatcher.ts" />
/// <reference path="./../utils/Maps.ts" />
/// <reference path="./BaseModule.ts" />
/// <reference path="./../storage/BaseStorage.ts" />
/// <reference path="./../storage/StorageMgr.ts" />

(function (apeng) {
    /**数据管理 避免数据模块之间循环引用 */
    class ModuleMgr extends apeng.EventDispatcher {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**实例化完成 */
                INSTANCE: "INSTANCE",
                /**启动队列 */
                START_UP: "START_UP",
                /**run完成 */
                RUN_COMLETE: "RUN_COMLETE",
            };
            this.modules = {};
            this.modelTypeOrgin = null;
            this._adds = {};
        }
        add(type) {
            let _this = this;
            return function (target) {
                _this._adds[type] = target;
            };
        }
        /**获取实例化后的模块 */
        get(moduleType) {
            return this.modules[moduleType];
        }
        instanceOnce(moduleType) {
            let module = this._adds[moduleType];
            let value = this.modules[moduleType] = new module();
            if (value.storage === null)
                value.storage = new apeng.BaseInstanceStorage(apeng.CStorageDefaultType, apeng.StorageMgr);
            if (value.onBeforeInstance)
                value.onBeforeInstance();
            if (value.onInstance)
                value.onInstance();
            return value;
            this.emit(this.EventType.INSTANCE);
        }
        /**实例化时 */
        instance(useCacheType, newComplete) {
            let modules = this._adds;
            if (apeng.initData.isLog)
                console.log("module count:" + apeng.Maps.size(modules));
            apeng.Maps.forEach(modules, (module, moduleName) => {
                let value = this.modules[moduleName] = new module();
                if (value.storage === null)
                    value.storage = new apeng.BaseInstanceStorage(useCacheType ? Number(moduleName) : apeng.CStorageDefaultType, apeng.StorageMgr);
                if (value.onBeforeInstance)
                    value.onBeforeInstance();
            });
            if (newComplete)
                newComplete();
            apeng.Maps.forEach(this.modules, module => {
                if (module.onInstance)
                    module.onInstance();
            });
            this.emit(this.EventType.INSTANCE);
        }
        forEach(cb) {
            apeng.Maps.forEach(this.modules, cb);
        }
        run(complete, _enum) {
            if (apeng.initData.isLog)
                console.log("module START_UP start");
            this.emitQueue(this.EventType.START_UP, -1, () => {
                if (apeng.initData.isLog)
                    console.log("module START_UP complete");
                apeng.Maps.forEach(this.modules, module => {
                    if (module.onCreate)
                        module.onCreate();
                });
                apeng.Maps.forEach(this.modules, module => {
                    if (module.onLogic)
                        module.onLogic();
                });
                apeng.Maps.forEach(this.modules, module => {
                    if (module.onComplete)
                        module.onComplete();
                });
                complete();
                this.emit(this.EventType.RUN_COMLETE);
            }, _enum ? ((index) => "START_UP " + _enum[index]) : "START_UP");
        }
    }
    apeng.ModuleMgr = ModuleMgr;
})(apeng || (apeng = {}));
/// <reference path="./CCImport.ts" />
/// <reference path="./module/ModuleMgr.ts" />
/// <reference path="./Define.ts" />
const startTime = Date.now();
/**启动入口 主逻辑运行处*/

(function (apeng) {
    /**主 事件 全局处理 */
    apeng._main = null;
    /**多语言管理 */
    apeng._language = null;
    /**平台 */
    apeng._platform = null;
    /**定时器 帧循环 */
    apeng._timer = null;
    /**资源 */
    apeng._resouces = null;
    /**ui管理 */
    apeng._ui = null;
    /**音频 */
    apeng._audio = null;
    /**场景 */
    apeng._scene = null;
    /**隐私协议 */
    apeng._privacy = null;
    /**gm窗口 */
    apeng._gm = null;
    /**引导 */
    apeng._guide = null;
    /**登录 */
    apeng._login = null;
    /**道具 */
    apeng._prop = null;
    /**排行 */
    apeng._rank = null;
    /**是编辑器环境 */
    apeng.EDITOR = _cc_.EDITOR;
    /**框架模块管理 */
    apeng.moduleMgr = new apeng.ModuleMgr();
    /**平台实例 */
    apeng.platformMgr = new apeng.ModuleMgr();
    /**平台逻辑模块 */
    apeng.platformLogicMgr = new apeng.ModuleMgr();
    /**传入的静态初始化数据 */
    apeng.initData = null;
    /**配置表数据 */
    apeng._config_ = null;
    /**
     * 初始化主框架
     * @param data 静态数据
     * @param dataConfig 配置表数据
     */
    function initCore(data, complete) {
        apeng.initData = data;
        if (apeng.EDITOR) {
            apeng.game.once(apeng.Game.EVENT_ENGINE_INITED, editorRunSpine, this);
            return;
        }
        else {
            console.log("apeng core versionCode:" + apeng.versionCode);
            // 修改音频组件 切换场景 导致生命周期方法执行
            apeng.AudioSource.prototype.onDisable = function () {
            };
            apeng.AudioSource.prototype.onEnable = function () {
            };
        }
        // 停止输入事件优化 原生端touch目标已被销毁
        apeng.input._dispatchImmediately = true;
        // 默认赋值
        apeng.Move.setPosition = apeng.NodeHelper.setPosition.bind(apeng.NodeHelper);
        apeng.Move.getPosition = apeng.NodeHelper.getPosition.bind(apeng.NodeHelper);
        apeng.Move.lookAt = apeng.NodeHelper.lookAt.bind(apeng.NodeHelper);
        apeng.Move.getDeltaTime = isSlowMotion => isSlowMotion ? apeng._timer.dt : apeng._timer.dtDefault;
        apeng.EventHandlerCC.clickSoundUrl = apeng.initData.audioClickUrl;
        // app场景加载完毕
        let fn = (scene) => {
            if (scene.name != "App")
                return;
            // 加载模块
            apeng.moduleMgr.instance(apeng.initData.useModuleStorageType, () => {
                apeng._language = apeng.moduleMgr.get(apeng.EModuleType.language);
                apeng._platform = apeng.moduleMgr.get(apeng.EModuleType.platform);
                apeng._timer = apeng.moduleMgr.get(apeng.EModuleType.timer);
                apeng._resouces = apeng.moduleMgr.get(apeng.EModuleType.resouces);
                apeng._ui = apeng.moduleMgr.get(apeng.EModuleType.ui);
                apeng._audio = apeng.moduleMgr.get(apeng.EModuleType.audio);
                apeng._scene = apeng.moduleMgr.get(apeng.EModuleType.scene);
                apeng._main = apeng.moduleMgr.get(apeng.EModuleType.main);
                apeng._privacy = apeng.moduleMgr.get(apeng.EModuleType.privacy);
                apeng._gm = apeng.moduleMgr.get(apeng.EModuleType.gm);
                apeng._guide = apeng.moduleMgr.get(apeng.EModuleType.guide);
                apeng._login = apeng.moduleMgr.get(apeng.EModuleType.login);
                apeng._prop = apeng.moduleMgr.get(apeng.EModuleType.prop);
                apeng._rank = apeng.moduleMgr.get(apeng.EModuleType.rank);
            });
            let canvas = scene.getComponentInChildren(apeng.Canvas);
            let loadingNode = canvas.node.getChildByName("Loading");
            loadingNode.setSiblingIndex(apeng._ui.stageUp.getSiblingIndex() - 1);
            let newUseEnterGame = apeng.initData.newUseEnterGame && apeng._login.isNewUser;
            let dir = new apeng.LoadDir(8, () => {
                // 基础资源加载完成
                apeng._ui.open(apeng.initData.uiUrl.indexBg, undefined, undefined, undefined, false);
                let _fn = () => {
                    let isWaitScene = apeng.initData.isWaitScene;
                    let closeLoading = () => {
                        var _a;
                        apeng._ui.Loading.screen(false, new apeng.Color().fromHEX(apeng.initData.loadingCompleteColorAnim));
                        (_a = canvas.getComponent("App")) === null || _a === void 0 ? void 0 : _a.destroy();
                        loadingNode.destroy();
                        if (complete)
                            complete(apeng.EInitCoreState.openIndex);
                    };
                    if (!isWaitScene)
                        if (apeng.initData.loadingDuration > 0)
                            setTimeout(closeLoading, apeng.initData.loadingDuration * 1000);
                        else
                            closeLoading();
                    let sceneDir = new apeng.LoadDir(2, () => {
                        if (complete)
                            complete(apeng.EInitCoreState.openScene);
                    });
                    apeng.assetManager.getBundle("main2").loadDir("texture/preload", sceneDir.subCount());
                    apeng._scene.change(apeng.initData.initSceneUrl, () => {
                        sceneDir.subCount()();
                        if (isWaitScene)
                            closeLoading();
                    });
                };
                if (newUseEnterGame)
                    _fn();
                else {
                    apeng._ui.open(apeng.initData.uiUrl.index, null, _fn, undefined, false);
                    if (apeng.initData.uiUrl.prop)
                        apeng._ui.open(apeng.initData.uiUrl.prop, undefined, undefined, undefined, false);
                }
            });
            apeng._privacy.show(
            // ui打开完毕
            () => {
                if (newUseEnterGame)
                    dir.subCount()();
                else {
                    apeng._ui.load(apeng.initData.uiUrl.index, dir.subCount());
                    if (apeng.initData.uiUrl.prop) {
                        dir.count++;
                        apeng._ui.load(apeng.initData.uiUrl.prop, dir.subCount());
                    }
                }
                apeng._ui.load(apeng.initData.uiUrl.indexBg, dir.subCount());
                if (apeng._platform.isOverseas)
                    apeng.assetManager.loadBundle("languageTexture", dir.subCount());
                else
                    dir.subCount()();
                apeng._resouces.loadDefaultSpriteFrame(dir.subCount());
                //加载配置表
                apeng.assetManager.getBundle("main2").load(apeng.initData.configUrl, apeng.TextAsset, (err, res) => {
                    dir.subCount()();
                    apeng._config_ = new apeng.ConfigHelper(JSON.parse(res.text), apeng.initData.configDefine);
                    if (complete)
                        complete(apeng.EInitCoreState.config);
                    apeng._platform.init(dir.subCount());
                    apeng.moduleMgr.run(dir.subCount(), apeng.EModuleType);
                });
                if (complete)
                    complete(apeng.EInitCoreState.private);
            }, 
            // 确认通过
            dir.subCount());
            if (complete)
                complete(apeng.EInitCoreState.init);
        };
        let scene = apeng.director.getScene();
        if (scene)
            setTimeout(() => fn(scene));
        else
            apeng.director.once(apeng.Director.EVENT_AFTER_SCENE_LAUNCH, fn);
        if (apeng.initData.isLog)
            console.log("apeng core complete duration:" + (Date.now() - startTime));
    }
    apeng.initCore = initCore;
    /**编辑器运行spine */
    function editorRunSpine() {
        if (apeng.sp && apeng.sp.Skeleton && apeng.sp.Skeleton.prototype) {
            apeng.js.mixin(apeng.sp.Skeleton.prototype, {
                update(dt) {
                    if (this.paused)
                        return;
                    dt *= this._timeScale * 1;
                    if (this.isAnimationCached()) {
                        // Cache mode and has animation queue.
                        if (this._isAniComplete) {
                            if (this._animationQueue.length === 0 && !this._headAniInfo) {
                                const frameCache = this._frameCache;
                                if (frameCache && frameCache.isInvalid()) {
                                    frameCache.updateToFrame();
                                    const frames = frameCache.frames;
                                    this._curFrame = frames[frames.length - 1];
                                }
                                return;
                            }
                            if (!this._headAniInfo) {
                                this._headAniInfo = this._animationQueue.shift();
                            }
                            this._accTime += dt;
                            if (this._accTime > this._headAniInfo.delay) {
                                const aniInfo = this._headAniInfo;
                                this._headAniInfo = null;
                                this.setAnimation(0, aniInfo.animationName, aniInfo.loop);
                            }
                            return;
                        }
                        this._updateCache(dt);
                    }
                    else {
                        this._updateRealtime(dt);
                    }
                }
            });
        }
    }
    const _winSize = new apeng.Size();
    const _winCenterPostion = new apeng.Vec2();
    const _winCenterPostionT = new apeng.Vec2();
    const _winSizeT = new apeng.Size();
    /**屏幕尺寸 */
    function winSize(addW, addH) {
        if (apeng.EDITOR)
            return apeng.view.getVisibleSize();
        if (_winSize.width == 0 && _winSize.height == 0)
            _winSize.set(apeng.view.getVisibleSize());
        _winSizeT.set(_winSize);
        if (addW != undefined)
            _winSizeT.width += addW;
        if (addH != undefined)
            _winSizeT.height += addH;
        return _winSizeT;
    }
    apeng.winSize = winSize;
    /**屏幕中心点 */
    function winCenterPostion(addX, addY) {
        if (_winCenterPostion.x == 0 && _winCenterPostion.y == 0) {
            _winCenterPostion.x = winSize().width / 2;
            _winCenterPostion.y = winSize().height / 2;
        }
        if (addX || addY) {
            _winCenterPostionT.x = _winCenterPostion.x + (addX || 0);
            _winCenterPostionT.y = _winCenterPostion.y + (addY || 0);
            return _winCenterPostionT;
        }
        return _winCenterPostion;
    }
    apeng.winCenterPostion = winCenterPostion;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 基于位运算的分组控制
     */
    class ColliderGroup {
        constructor() {
            this.groups = {};
            this.colliders = {};
            this._checkGroup = {};
        }
        /**
         * 添加分组
         * @param groupName
         */
        add(groupName) {
            if (this.groups[groupName] == undefined)
                this.groups[groupName] = Math.pow(2, apeng.Maps.size(this.groups));
        }
        /**
         * 设置可发生碰撞的分组
         * @param self 当前分组
         * @param collider 可发生碰撞的组
         */
        setCollider(self, collider) {
            if (this.colliders[self] == undefined)
                this.colliders[self] = [];
            apeng.Sets.add(this.colliders[self], collider);
        }
        /**
         * 设置可发生碰撞的分组配对
         * @param self
         * @param other
         */
        setColliders(self, other) {
            for (let collider of other) {
                this.setCollider(self, collider);
            }
        }
        /**
         * 校验分组
         * @param self
         * @param other
         * @returns 能发生碰撞
         */
        has(self, other) {
            let mask = this._checkGroup[self];
            if (mask == undefined) {
                mask = 0;
                let group = this.colliders[self];
                if (group) {
                    for (let value of group)
                        mask |= (this.groups[value]);
                }
                this._checkGroup[self] = mask;
            }
            if ((mask & (this.groups[other])) == 0)
                return false;
            return true;
        }
    }
    apeng.ColliderGroup = ColliderGroup;
})(apeng || (apeng = {}));

(function (apeng) {
    let ECollider2DShapeType;
    (function (ECollider2DShapeType) {
        ECollider2DShapeType[ECollider2DShapeType["None"] = 0] = "None";
        ECollider2DShapeType[ECollider2DShapeType["Circle"] = 1] = "Circle";
        ECollider2DShapeType[ECollider2DShapeType["Point"] = 2] = "Point";
        ECollider2DShapeType[ECollider2DShapeType["Polygon"] = 3] = "Polygon";
    })(ECollider2DShapeType = apeng.ECollider2DShapeType || (apeng.ECollider2DShapeType = {}));
    class Collider2DShape {
        constructor() {
            this.Collider2DRoot = null;
            /**碰撞框倍率 */
            this.mul = 1;
            this.owner = null;
            this.position = new apeng.Vector2();
            /**当前分组 */
            this.group = null;
            /**开启碰撞 */
            this._isCollider = true;
            /**偏移 */
            this.offset = new apeng.Vector2();
            /**弧度 */
            this.angle = null;
            this.onColliderEnter = null;
            this.onColliderExit = null;
            this.onColliderUpdate = null;
            this.onSetCollider = null;
            this.onClear = null;
            this.id = null;
            /**进入的其他碰撞id */
            this.otherCollider = [];
            /**被其他碰撞的引用 */
            this.selfCollider = [];
            /**脏标记 防止同帧重复调用 */
            this.dataDirty = true;
            /**动态更新 return{boolean} 是否更新节点树 */
            this.updateShape = null;
            this.octree = [];
            this.root = null;
            /**正在碰撞中 */
            this.isColliderEnter = false;
        }
        set isCollider(value) {
            if (this._isCollider == value)
                return;
            this._isCollider = value;
            if (this.onSetCollider)
                this.onSetCollider(this._isCollider);
        }
        get isCollider() { return this._isCollider; }
        /**清空所有引用 */
        clear() {
            // 删除自己被其他引用的 id
            for (let other of this.selfCollider)
                if (other)
                    other.hasExit(this);
            this.selfCollider.length = 0;
            this.otherCollider.length = 0;
            this.dataDirty = true;
            this.isColliderEnter = false;
            this.removeFormOctreeItem();
            this.id = null;
            if (this.onClear)
                this.onClear();
        }
        // public hasEnter(other: Collider2DShape): boolean {
        //     // 派发开始回调
        //     if (!Sets.has(this.otherCollider, other)) {
        //         this.otherCollider.push(other)
        //         other.selfCollider.push(this)
        //         if (this.onColliderEnter)
        //             this.onColliderEnter(this, other)
        //         return true
        //     }
        //     return false
        // }
        hasExit(other) {
            if (apeng.Sets.has(this.otherCollider, other)) {
                apeng.Sets.delete(this.otherCollider, other);
                apeng.Sets.delete(other.selfCollider, this);
                if (this.onColliderExit)
                    this.onColliderExit(this, other);
                // if (other.onColliderExit)
                //     other.onColliderExit(other, this)
            }
        }
        /**是否正在与其他物体产生碰撞 */
        hasColliderOther() {
            if (this.otherCollider.length > 0)
                return true;
            return false;
        }
        updatePosition(x, y) {
            this.position.set(x, y);
            this.dataDirty = true;
        }
        updateAngle(angle) {
            this.angle = apeng.Maths.toRadian(angle);
            this.dataDirty = true;
        }
        setOffset(x, y) {
            this.offset.set(x, y);
        }
        /**从树中删除当前数据 */
        removeFormOctreeItem() {
            if (this.octree.length > 0) {
                for (let value of this.octree)
                    value.remove(this);
                this.octree.length = 0;
            }
        }
    }
    apeng.Collider2DShape = Collider2DShape;
})(apeng || (apeng = {}));
/// <reference path="./Maths.ts" />
/// <reference path="./Pool.ts" />

(function (apeng) {
    let _x = 0.0;
    let _y = 0.0;
    class Vector2 {
        /**
         * 创建一个 <code>Vector2</code> 实例。
         * @param	x  X轴坐标。
         * @param	y  Y轴坐标。
         */
        constructor(x, y) {
            /**X轴坐标*/
            this.x = 0;
            /**Y轴坐标*/
            this.y = 0;
            this.set(x, y);
        }
        /**逐元素向量最小值 */
        static min(out, a, b) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            return out;
        }
        /**逐元素向量最大值 */
        static max(out, a, b) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            return out;
        }
        /**
         * 两个向量的夹角角度
         * @param a
         * @param b
         * @param orgin
         * @param dot 加上方向 顺时针为负
         * @returns
         */
        static twoAngle(a, b, orgin = Vector2.ZERO, dot = false) {
            let x1 = a.x - orgin.x;
            let y1 = a.y - orgin.y;
            let x2 = b.x - orgin.x;
            let y2 = b.y - orgin.y;
            // 余弦定理
            //            C(0,0)
            //           /θ\
            //         b/   \a
            //         /     \
            // (x1,y1)A_______B(x2,y2)
            //            c
            // c^2 = a^2 + b^2 - 2*a*b*cosθ
            let cosRadian = (Math.pow(x1, 2) +
                Math.pow(y1, 2) +
                Math.pow(x2, 2) +
                Math.pow(y2, 2) -
                (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))) /
                (2 *
                    Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2)) *
                    Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
            let mul = 1;
            if (dot) {
                let _dot = (x2 * y1) - (y2 * x1);
                if (_dot > 0)
                    mul = -1;
            }
            return apeng.Maths.toDegree(Math.acos(cosRadian)) * mul;
        }
        static sort(points) {
            v2T.set();
            for (let point of points)
                v2T.addSelf(point);
            let size = points.length;
            v2T.x /= size;
            v2T.y /= size;
            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size - 1 - i; j++) {
                    if (this.sortItem(points[j], points[j + 1], v2T)) {
                        let temp = points[j];
                        points[j] = points[j + 1];
                        points[j + 1] = temp;
                    }
                }
            }
            return points;
        }
        static sortItem(a, b, center) {
            v2T2.set(a).subSelf(center);
            v2T3.set(b).subSelf(center);
            let dot = this.dot(v2T2, v2T3);
            if (dot > 0)
                return false;
            return true;
        }
        static distance(value1, value2) {
            _x = value1.x - value2.x;
            _y = value1.y - value2.y;
            return Math.sqrt(_x * _x + _y * _y);
        }
        /**
        * 两个三维向量距离。 不开方
        * @param	value1 向量1。
        * @param	value2 向量2。
        * @return	距离。
        */
        static distanceSqr(value1, value2) {
            _x = value1.x - value2.x;
            _y = value1.y - value2.y;
            return _x * _x + _y * _y;
        }
        /**
       * 缩放当前向量。如果你想结果保存到另一个向量，可使用 mul() 代替。
       * @method mulSelf
       * @param {number} num
       * @return {Vec2} returns this
       * @chainable
       * @example
       * v.mulSelf(5);// return Vec2 {x: 50, y: 50};
       */
        static mul(out, value, num) {
            Vector2.set(out, value);
            if (typeof num == "number") {
                out.x *= num;
                out.y *= num;
            }
            else {
                out.x *= num.x;
                out.y *= num.y;
            }
            return out;
        }
        static equals(a, b, offset = 0.01) {
            if (Math.abs(a.x - b.x) <= offset && Math.abs(a.y - b.y) <= offset)
                return true;
            return false;
        }
        static equalsZero(a, b) {
            return a.x == b.x && a.y == b.y;
        }
        static equals2f(value1, x, y) {
            return value1.x === x && value1.y === y;
        }
        /**
       * 以自身为原点 获取 另外点同自身的角度 0~360
       * @param other
       * @param rotate 0~360 默认 0度=>正右方； 逆时针旋转角度
       */
        static angle360(self, other, rotate = 0) {
            // 获取到角度
            let sub = v2T.set(other).subSelf(self);
            return Vector2.angle(sub, rotate);
        }
        static angle(value, rotate = 0) {
            // 改成逆时针方向
            if (rotate != 0) {
                rotate = 360 - rotate;
                Vector2.rotate(value, value, apeng.Maths.toRadian(rotate));
            }
            let angle = apeng.Maths.toDegree(Math.atan2(value.y, value.x));
            // 转换成 0 ~ 360
            angle = apeng.Maths.normalizeAngle(angle);
            return angle;
        }
        /**
         * 缩放二维向量。
         * @param	a 源二维向量。
         * @param	b 缩放值。
         * @param	out 输出二维向量。
         */
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
        }
        /**
        * 求两个二维向量的点积。
        * @param	a left向量。
        * @param	b right向量。
        * @return   点积。
        */
        static dot(a, b) {
            return (a.x * b.y) - (a.y * b.x);
        }
        /**
         * 归一化二维向量。
         * @param	s 源三维向量。
         * @param	out 输出三维向量。
         */
        static normalize(out, value) {
            var x = value.x, y = value.y;
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
            }
            return out;
        }
        /**
         * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
         * @param to 目标向量。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        static lerp(out, from, to, ratio) {
            _x = from.x;
            _y = from.y;
            out.x = _x + ratio * (to.x - _x);
            out.y = _y + ratio * (to.y - _y);
            return out;
        }
        /**
          * 转换为方便阅读的字符串。
          * @method toString
          * @return {string}
          */
        static toString(value) {
            return "(" + value.x.toFixed(2) + ", " + value.y.toFixed(2) + ")";
        }
        /**
         * @zh 将当前向量的旋转
         * @param radians 旋转角度（弧度制）。
         */
        static rotate(out, value, radians) {
            _x = value.x;
            _y = value.y;
            const sin = Math.sin(radians);
            const cos = Math.cos(radians);
            out.x = cos * _x - sin * _y;
            out.y = sin * _x + cos * _y;
            return out;
        }
        /**
         * 向量减法，并返回新结果
         * @param vector
         * @param out
         */
        static sub(out, a, b) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            return out;
        }
        /**
         * 求向量长度
         */
        static len(value) {
            return Math.sqrt(Vector2.lengthSqr(value));
        }
        /**
         * 求向量长度平方
         */
        static lengthSqr(value) {
            return value.x * value.x + value.y * value.y;
        }
        /**
         * 向量减法，并返回新结果
         * @param vector
         * @param out
         */
        static add(out, a, b) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            return out;
        }
        /**两个向量的中心点 */
        static center(out, a, b) {
            return Vector2.lerp(out, a, b, .5);
        }
        static clampf(out, value, min, max) {
            out.x = apeng.Maths.clampf(value.x, min.x, max.x);
            out.y = apeng.Maths.clampf(value.y, min.y, max.y);
            return out;
        }
        static set(self, x, y) {
            if (x && x[0] !== undefined) {
                self.x = x[0];
                self.y = x[1];
            }
            else if (x && typeof x === "object") {
                self.x = x.x;
                self.y = x.y;
            }
            else {
                self.x = (x || 0);
                self.y = y || 0;
            }
            return self;
        }
        /**
         * 找到多边形的中心点
         * @param polygon
         */
        static polygonByCenterPoint(out, polygon) {
            let minX = polygon[0].x;
            let maxX = polygon[0].x;
            let minY = polygon[0].y;
            let maxY = polygon[0].y;
            for (let value of polygon) {
                if (minX > value.x)
                    minX = value.x;
                if (maxX < value.x)
                    maxX = value.x;
                if (minY > value.y)
                    minY = value.y;
                if (maxY < value.y)
                    maxY = value.y;
            }
            out.x = minX + Math.abs(maxX - minX) / 2;
            out.y = minY + Math.abs(maxY - minY) / 2;
            return out;
        }
        /**
         * 近似判断两个点是否相等。<br/>
         * 判断 2 个向量是否在指定数值的范围之内，如果在则返回 true，反之则返回 false。
         * @method fuzzyEquals
         * @param {Vec2s} other
         * @param {Number} variance
         * @return {Boolean}
         */
        static fuzzyEquals(self, other, variance) {
            if (self.x - variance <= other.x && other.x <= self.x + variance) {
                if (self.y - variance <= other.y && other.y <= self.y + variance)
                    return true;
            }
            return false;
        }
        mul(out, num) { return Vector2.mul(out, this, num); }
        mulSelf(num) { return Vector2.mul(this, this, num); }
        len() { return Vector2.len(this); }
        lengthSqr() { return Vector2.lengthSqr(this); }
        equals(other) { return Vector2.equals(this, other); }
        equals2f(x, y) { return Vector2.equals2f(this, x, y); }
        set(x, y) { return Vector2.set(this, x, y); }
        sub(out, value) { return Vector2.sub(out, this, value); }
        subSelf(value) { return Vector2.sub(this, this, value); }
        rotate(out, radians) { return Vector2.rotate(out, this, radians); }
        rotateSelf(radians) { return Vector2.rotate(this, this, radians); }
        normalize(out) { return Vector2.normalize(out, this); }
        normalizeSelf() { return Vector2.normalize(this, this); }
        add(out, value) { return Vector2.add(out, this, value); }
        addSelf(value) { return Vector2.add(this, this, value); }
        toString() { return Vector2.toString(this); }
        clampf(out, min, max) { return Vector2.clampf(out, this, min, max); }
        clampfSelf(min, max) { return Vector2.clampf(this, this, min, max); }
    }
    Vector2.pool = new apeng.PoolOnce(1000, () => new Vector2(), (data) => { data.set(); });
    /**零向量,禁止修改*/
    Vector2.ZERO = new Vector2(0.0, 0.0);
    /**一向量,禁止修改*/
    Vector2.ONE = new Vector2(1.0, 1.0);
    /**一向量,禁止修改*/
    Vector2.UP = new Vector2(0, 1);
    /**一向量,禁止修改*/
    Vector2.RIGHT = new Vector2(1, 0);
    /**一向量,禁止修改*/
    Vector2.LEFT = new Vector2(-1, 0);
    /**一向量,禁止修改*/
    Vector2.DOWN = new Vector2(0, -1);
    apeng.Vector2 = Vector2;
    const v2T = new Vector2(1.0, 1.0);
    const v2T2 = new Vector2(1.0, 1.0);
    const v2T3 = new Vector2(1.0, 1.0);
})(apeng || (apeng = {}));
/// <reference path="./Collider2DShape.ts" />
/// <reference path="./../../utils/Vector2.ts" />

(function (apeng) {
    const v2T = new apeng.Vector2();
    class Collider2DPolygon extends apeng.Collider2DShape {
        constructor(position, group, polygon) {
            super();
            this.type = apeng.ECollider2DShapeType.Polygon;
            /**存储方向与长度 方便计算放大缩小 */
            this.polygon = [];
            this._polygon = [];
            this.group = group;
            this.updatePolygon(position, polygon);
        }
        /**
         * 使用 rectange 创建多边形碰撞盒
         * @param rectange
         */
        static createByRectange(rectange, group, out) {
            if (!out)
                out = new Collider2DPolygon(apeng.Vector2.ZERO, group, rectange.angleCenter());
            else
                out.updatePolygon(apeng.Vector2.ZERO, rectange.angleCenter());
            return out;
        }
        updatePolygon(position, polygon) {
            apeng.Vector2.set(this.position, position);
            let length = polygon.length;
            this._polygon.length = length;
            this.polygon.length = length;
            for (let i = 0; i < length; i++) {
                if (!this.polygon[i]) {
                    this.polygon[i] = {
                        dir: new apeng.Vector2(),
                        offsetDir: new apeng.Vector2(),
                        len: 0,
                        offsetLen: 0
                    };
                    this._polygon[i] = new apeng.Vector2();
                }
                apeng.Vector2.normalize(v2T, polygon[i]);
                let len = apeng.Vector2.len(polygon[i]);
                this.polygon[i].dir.set(v2T);
                this.polygon[i].offsetDir.set(v2T);
                this.polygon[i].len = len;
                this.polygon[i].offsetLen = len;
            }
            this.dataDirty = true;
        }
        getPolygon() {
            if (!this.dataDirty)
                return this._polygon;
            this.dataDirty = false;
            // 偏移 旋转(绕偏移前) 缩放
            for (let i = 0; i < this.polygon.length; i++) {
                let value = this.polygon[i];
                // 偏移
                this._polygon[i].set(value.offsetDir);
                if (this.angle) {
                    // 绕未偏移原点旋转
                    this._polygon[i].rotateSelf(this.angle);
                }
                this._polygon[i].mulSelf(value.offsetLen * this.mul);
                this._polygon[i].addSelf(this.position);
            }
            return this._polygon;
        }
        /**更新未偏移的原点 */
        setOffset(x, y) {
            super.setOffset(x, y);
            for (let i = 0; i < this.polygon.length; i++) {
                let value = this.polygon[i];
                // 当前相对坐标
                value.dir.mul(v2T, value.len);
                v2T.addSelf(this.offset);
                v2T.normalize(value.offsetDir);
                value.offsetLen = v2T.len();
            }
        }
    }
    apeng.Collider2DPolygon = Collider2DPolygon;
})(apeng || (apeng = {}));
/// <reference path="./Collider2DPolygon.ts" />

(function (apeng) {
    class Collider2DBox extends apeng.Collider2DPolygon {
        constructor(position, group, width, height) {
            super(position, group, [
                new apeng.Vector2(-width / 2, -height / 2),
                new apeng.Vector2(width / 2, -height / 2),
                new apeng.Vector2(width / 2, height / 2),
                new apeng.Vector2(-width / 2, height / 2),
            ]);
        }
    }
    apeng.Collider2DBox = Collider2DBox;
})(apeng || (apeng = {}));
/// <reference path="./Collider2DShape.ts" />
/// <reference path="./../../utils/Vector2.ts" />

(function (apeng) {
    const v2T = new apeng.Vector2();
    class Collider2DCircle extends apeng.Collider2DShape {
        constructor(position, group, radius) {
            super();
            this.type = apeng.ECollider2DShapeType.Circle;
            this.radius = 0;
            this.circle = new apeng.Circle();
            apeng.Vector2.set(this.position, position);
            this.group = group;
            this.radius = radius;
        }
        getCircle() {
            if (!this.dataDirty)
                return this.circle;
            this.dataDirty = false;
            v2T.set(this.offset);
            // 绕偏移旋转
            if (this.angle != 0)
                if (!this.offset.equals(apeng.Vector2.ZERO)) {
                    v2T.rotateSelf(this.angle);
                }
            v2T.addSelf(this.position);
            return this.circle.set(v2T.x, v2T.y, this.radius * this.mul);
        }
    }
    apeng.Collider2DCircle = Collider2DCircle;
})(apeng || (apeng = {}));
/// <reference path="./../Main.ts" />
/// <reference path="./../utils/Vector2.ts" />

(function (apeng) {
    /**
     * 引擎部分重写
     * 声明提示文件
     * 方便使用 vscode 导入
     */
    apeng.ccclass = apeng._decorator.ccclass;
    apeng.menu = apeng._decorator.menu;
    function menuComponent(compName) {
        return apeng._decorator.menu("apeng/" + compName);
    }
    apeng.menuComponent = menuComponent;
    function menuUI(compName) {
        return apeng._decorator.menu("apeng/ui扩展/" + compName);
    }
    apeng.menuUI = menuUI;
    function menuAnim(compName) {
        return apeng._decorator.menu("apeng/动画/" + compName);
    }
    apeng.menuAnim = menuAnim;
    function menuList(compName) {
        return apeng._decorator.menu("apeng/列表/" + compName);
    }
    apeng.menuList = menuList;
    function menuBtn(compName) {
        return apeng._decorator.menu("apeng/按钮/" + compName);
    }
    apeng.menuBtn = menuBtn;
    function menuScene(compName) {
        return apeng._decorator.menu("apeng/场景/" + compName);
    }
    apeng.menuScene = menuScene;
    function menuController(compName) {
        return apeng._decorator.menu("apeng/控制器/" + compName);
    }
    apeng.menuController = menuController;
    function menuShape(compName) {
        return apeng._decorator.menu("apeng/形状/" + compName);
    }
    apeng.menuShape = menuShape;
    function menuEntity(compName) {
        return apeng._decorator.menu("apeng/entity/" + compName);
    }
    apeng.menuEntity = menuEntity;
    function menuP2(compName) {
        return apeng._decorator.menu("apeng/p2/" + compName);
    }
    apeng.menuP2 = menuP2;
    apeng.requireComponent = apeng._decorator.requireComponent;
    apeng.executeInEditMode = apeng._decorator.executeInEditMode;
    apeng.property = apeng._decorator.property;
})(apeng || (apeng = {}));
/// <reference path="./../helper/DirectorHelper.ts" />

(function (apeng) {
    let BaseComponent = class BaseComponent extends _cc_.Component {
        constructor() {
            super(...arguments);
            /**关闭组件生命周期方法 */
            this.CLOSE_ON_CC = false;
            this.backupDescribe = "";
            /**update执行间隔时间 */
            this.onUpdateInterval = null;
            /**暂停update */
            this.isUpdate = true;
            this._cacheComponents = new Map();
            this._eventMap = [];
            this.isEventOn = false;
            this._autoMember = false;
            this.__isPreload = false;
            this.orginLabelColor = null;
            this.orginLabel2Color = null;
            this.isEventSelf = true;
            this._isPersistRootNode = null;
            this._coordinateTracker = null;
        }
        set editorUpdateData(value) {
            if (this.onEditorUpdateData)
                this.onEditorUpdateData();
        }
        get editorUpdateData() { return false; }
        set editorClearData(value) {
            if (this.onEditorClearData)
                this.onEditorClearData();
        }
        get editorClearData() { return false; }
        /**当前节点是否处于常驻节点 */
        get isPersistRootNode() {
            if (this._isPersistRootNode === null) {
                this._isPersistRootNode = false;
                let parent = this.node.parent;
                while (parent) {
                    if (parent._persistNode) {
                        this._isPersistRootNode = true;
                        break;
                    }
                    parent = parent.parent;
                }
            }
            return this._isPersistRootNode;
        }
        /**在场景显示 */
        get isVisible() {
            if (!apeng.isValid(this, true) || !apeng.isValid(this.node, true) || !this.enabledInHierarchy)
                return false;
            return true;
        }
        /**
         * @deprecated 已停用
         * 子类不可使用
        */
        __preload() {
            // 处理update 必须在最开始赋值
            if (apeng.EDITOR) {
                if (this.onPreLoad)
                    this.onPreLoad();
                return;
            }
            if (this.__isPreload)
                return;
            this.__isPreload = true;
            if (this.update && this.update != this._update)
                console.error("勿使用update，请使用onUdate(内置全局管理 暂停恢复 帧率控制)");
            if (this.onUpdate || this._onUpdate)
                this.update = this._update;
            this._onLoad = this.onLoad;
            this.onLoad = function () {
                if (!this.CLOSE_ON_CC)
                    this._onLoad();
            };
            // 处理常驻节点时 切换场景不执行
            this._onEnable = this.onEnable;
            this._onDisable = this.onDisable;
            this.onEnable = function () {
                if (!this.CLOSE_ON_CC) {
                    if (this.isPersistRootNode) {
                        if (!apeng._scene.isChange)
                            this._onEnable();
                    }
                    else
                        this._onEnable();
                }
            };
            this.onDisable = function () {
                if (!this.CLOSE_ON_CC) {
                    if (this.isPersistRootNode) {
                        if (!apeng._scene.isChange)
                            this._onDisable();
                    }
                    else
                        this._onDisable();
                }
            };
            if (this.onPreLoad)
                this.onPreLoad();
        }
        /**赋值成员属性跟事件 */
        autoMember() {
            if (this._autoMember)
                return;
            if (!apeng.EDITOR)
                apeng.AutoMemberNodeAttribute.init(this.node, this);
            this._autoMember = true;
        }
        onLoad() {
            this.isEventSelf = true;
            if (apeng.NodeHelper.getUITransform(this.node)) {
                // 注册事件
                this.addEvent(apeng.Node.EventType.SIZE_CHANGED, this.onSizeChange, this, this.node);
                this.addEvent(apeng.Node.EventType.ANCHOR_CHANGED, this.onAnchorChange, this, this.node);
                if (!apeng.EDITOR) {
                    this.addEvent(apeng.Node.EventType.TOUCH_START, this.onTouchStart, this, this.node);
                    this.addEvent(apeng.Node.EventType.TOUCH_MOVE, this.onTouchMove, this, this.node);
                    this.addEvent(apeng.Node.EventType.TOUCH_END, this.onTouchEnd, this, this.node);
                    this.addEvent(apeng.Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this, this.node);
                    this.addEvent(apeng.Node.EventType.MOUSE_WHEEL, this.onMouseWheel, this, this.node);
                    if (this.onClickCatch)
                        this.addEvent(apeng.Node.EventType.TOUCH_END, this.onClickCatch, this, this.node, true);
                    if (this.onClick)
                        apeng.EventHandlerCC.onClick(this.node, this.onClick, this);
                }
            }
            if (!apeng.EDITOR) {
                this.addEvent(apeng.Input.EventType.TOUCH_START, this.onStageTouchStart, this, apeng.EventHandlerCC.touchEvent);
                this.addEvent(apeng.Input.EventType.TOUCH_MOVE, this.onStageTouchMove, this, apeng.EventHandlerCC.touchEvent);
                this.addEvent(apeng.Input.EventType.TOUCH_END, this.onStageTouchEnd, this, apeng.EventHandlerCC.touchEvent);
                this.addEvent(apeng.Input.EventType.TOUCH_END, this.onStageClick, this, apeng.EventHandlerCC.touchEvent);
                if (this.onKeyDown)
                    this.addEvent(apeng.Input.EventType.KEY_DOWN, this.onKeyDown, this, apeng.input);
                if (this.onKeyUp)
                    this.addEvent(apeng.Input.EventType.KEY_UP, this.onKeyUp, this, apeng.input);
            }
            if (this.onPositionChange)
                this.addEvent(apeng.Node.EventType.TRANSFORM_CHANGED, (transformBit) => {
                    if (transformBit & apeng.Node.TransformBit.POSITION)
                        this.onPositionChange();
                }, this, this.node);
            if (this.onScaleChange)
                this.addEvent(apeng.Node.EventType.TRANSFORM_CHANGED, (transformBit) => {
                    if (transformBit & apeng.Node.TransformBit.SCALE)
                        this.onScaleChange();
                }, this, this.node);
            if (this.onRotationChange)
                this.addEvent(apeng.Node.EventType.TRANSFORM_CHANGED, (transformBit) => {
                    if (transformBit & apeng.Node.TransformBit.ROTATION)
                        this.onRotationChange();
                }, this, this.node);
            this.isEventSelf = false;
            this.autoMember();
        }
        start() {
        }
        onEnable() {
            if (!this.isEventOn) {
                this.isEventOn = true;
                for (let value of this._eventMap)
                    // 注册节点事件
                    this._addEventRegist(value, true);
            }
        }
        onDisable() {
            if (this.isEventOn) {
                this.isEventOn = false;
                for (let value of this._eventMap)
                    this._addEventRegist(value, false);
            }
            if (apeng.EDITOR)
                return;
            // 清除定时器
            apeng._timer.clearAll(this);
            this.unscheduleAllCallbacks();
        }
        onDestroy() {
            apeng.AutoMemberNodeAttribute.clearMember(this);
            this.clearCacheComponent();
            this.isEventOn = false;
            this.isUpdate = true;
            this._autoMember = false;
            this._eventMap.length = 0;
        }
        clearCacheComponent() {
            this._cacheComponents.clear();
        }
        _update() {
            if (apeng.EDITOR)
                return;
            if (this.isUpdate) {
                if (this.onUpdate) {
                    if (this.onUpdateInterval != null) {
                        if (apeng._timer.hasUpdateIntervale(this.uuid + "onUpdate", this.onUpdateInterval, true))
                            this.onUpdate();
                    }
                    else
                        this.onUpdate();
                }
                if (this._onUpdate)
                    this._onUpdate();
            }
        }
        /**设置点击 只有最新的一个生效 */
        setClick(callBack, caller) {
            // 清除所有点击事件
            apeng.EventHandlerCC.offAllClick(this.node);
            apeng.EventHandlerCC.onClick(this.node, callBack, caller);
        }
        clearEventMap() {
            apeng.Sets.forEach(this._eventMap, value => {
                if (!value.isSelf) {
                    this._addEventRegist(value, false);
                    apeng.Sets.delete(this._eventMap, value);
                }
            }, true);
        }
        /**
         * 覆盖延迟定时器
         * 会覆盖上一次的执行
         * @param callBack 不能是箭头函数
         * @param delay 延迟时间
         */
        scheduleOnceCover(callBack, delay = 0) {
            this.unschedule(callBack);
            this.scheduleOnce(callBack, delay);
        }
        /**
         * 添加一个事件
         * @param type
         * @param callBack
         * @param caller
         * @param registTarget
         * @param fourByarg
         * @returns
         */
        addEvent(
        /**事件类型 */
        type, 
        /**事件回调 */
        callBack, 
        /**默认使用 this */
        caller, 
        /**注册到节点 反之注册到事件中心 */
        registTarget, 
        /**注册接口的第四个参数 */
        fourByarg, 
        /**执行一次销毁 */
        once = false) {
            if (!callBack)
                return null;
            let value = { type, callBack, caller, registTarget, fourByarg, once, isSelf: this.isEventSelf };
            this._eventMap.push(value);
            if (this.isEventOn)
                this._addEventRegist(value, true);
            return callBack;
        }
        _addEventRegist(value, on) {
            (typeof value.registTarget == "function" ? value.registTarget() : value.registTarget)[on ? (value.once ? "once" : "on") : "off"](value.type, value.callBack, value.caller, value.fourByarg);
        }
        setSize(width = null, height = null) { apeng.NodeHelper.setSize(this.node, width, height); }
        getChildByCreate(nodeName, createCb, addChildIndex = -1, editorShow = false) { return apeng.NodeHelper.getChildByCreate(this.node, nodeName, createCb, addChildIndex, editorShow); }
        getNodeComponents(comps) { return apeng.NodeHelper.getNodeComponents(this.node, comps); }
        getParentByName(parentName) { return apeng.NodeHelper.getParentByName(this.node, parentName); }
        getParentByNameChild(parentName) { return apeng.NodeHelper.getParentByNameChild(this.node, parentName); }
        walkAllChild(cb, deep = true) { apeng.NodeHelper.walkAllChild(this.node, cb, deep); }
        walkAllDeepChild(cb) { apeng.NodeHelper.walkAllDeepChild(this.node, cb); }
        followTarget(target, speed, rotate = null, isWorld = true, defaultRotate) { return apeng.NodeHelper.followTarget(this.node, target, speed, rotate, isWorld, defaultRotate); }
        lerpScaleTarget(target, ratio, isWorld = true) { return apeng.NodeHelper.lerpScaleTarget(this.node, target, ratio, isWorld); }
        lerpTarget(target, ratio, rotate = null, isWorld = true, defaultRotate) { return apeng.NodeHelper.lerpTarget(this.node, target, ratio, rotate, isWorld, defaultRotate); }
        lookAt(target, rotate = null) { apeng.NodeHelper.lookAt(this.node, target, rotate); }
        getPosition(isWorld, offsetX, offsetY, offsetZ) { return apeng.NodeHelper.getPosition(this.node, isWorld, offsetX, offsetY, offsetZ); }
        getRotate(isWorld) { return apeng.NodeHelper.getRotate(this.node, isWorld); }
        getRotateV3(isWorld) { return apeng.NodeHelper.getRotateV3(this.node, isWorld); }
        setRotate(value, isWorld) { apeng.NodeHelper.setRotate(this.node, value, isWorld); }
        setRotateX(x, isWorld) { apeng.NodeHelper.setRotateX(this.node, x, isWorld); }
        setRotateY(y, isWorld) { apeng.NodeHelper.setRotateY(this.node, y, isWorld); }
        setRotateZ(z, isWorld) { apeng.NodeHelper.setRotateZ(this.node, z, isWorld); }
        rotateX(angle, isWorld) { apeng.NodeHelper.rotateX(this.node, angle, isWorld); }
        rotateY(angle, isWorld) { apeng.NodeHelper.rotateY(this.node, angle, isWorld); }
        rotateZ(angle, isWorld) { apeng.NodeHelper.rotateZ(this.node, angle, isWorld); }
        setPosition(value, isWorld, offsetX, offsetY, offsetZ) { apeng.NodeHelper.setPosition(this.node, value, isWorld, offsetX, offsetY, offsetZ); }
        setPositionXY(value, isWorld) { apeng.NodeHelper.setPositionXY(this.node, value, isWorld); }
        setPositionX(x, isWorld) { apeng.NodeHelper.setPositionX(this.node, x, isWorld); }
        setPositionY(y, isWorld) { apeng.NodeHelper.setPositionY(this.node, y, isWorld); }
        setPositionZ(z, isWorld) { apeng.NodeHelper.setPositionZ(this.node, z, isWorld); }
        getScale(isWorld) { return apeng.NodeHelper.getScale(this.node, isWorld); }
        setScale(value, isWorld) { apeng.NodeHelper.setScale(this.node, value, isWorld); }
        setScaleNum(num, isWorld) { apeng.NodeHelper.setScaleNum(this.node, num, isWorld); }
        setScaleX(x, isWorld) { apeng.NodeHelper.setScaleX(this.node, x, isWorld); }
        setScaleY(y, isWorld) { apeng.NodeHelper.setScaleY(this.node, y, isWorld); }
        setScaleZ(z, isWorld) { apeng.NodeHelper.setScaleZ(this.node, z, isWorld); }
        getYMin(isWorld) { return apeng.NodeHelper.getYMin(this.node, isWorld); }
        getYMax(isWorld) { return apeng.NodeHelper.getYMax(this.node, isWorld); }
        getXMax(isWorld) { return apeng.NodeHelper.getXMax(this.node, isWorld); }
        getXMin(isWorld) { return apeng.NodeHelper.getXMin(this.node, isWorld); }
        getChildrenByComponents(comp, cb, out) { return apeng.NodeHelper.getChildrenByComponents(this.node, comp, cb, out); }
        getChildrenByComponent(comp) { return apeng.NodeHelper.getChildrenByComponent(this.node, comp); }
        getParentByComponent(comp) { return apeng.NodeHelper.getParentByComponent(this.node.parent, comp); }
        findChildrenByNameOnce(childrenName) { return apeng.NodeHelper.findChildrenByNameOnce(this.node, childrenName); }
        findChildrenByNamePrefixs(prefixName, cb) { return apeng.NodeHelper.findChildrenByNamePrefixs(this.node, prefixName, cb); }
        findChildrenByPrefixNameOnce(prefixName) { return apeng.NodeHelper.findChildrenByPrefixNameOnce(this.node, prefixName); }
        convertSelfToOtherNodeSpaceAR(out, other, point) { return apeng.NodeHelper.convertSelfToOtherNodeSpaceAR(out, this.node, other, point); }
        convertToNodeSpaceAR(out, point) { return apeng.NodeHelper.convertToNodeSpaceAR(out, this.node, point); }
        convertToWorldSpaceAR(out, point) { return apeng.NodeHelper.convertToWorldSpaceAR(out, this.node, point); }
        distance(other, type = "xyz") { return apeng.NodeHelper.distance(this.node, other, type); }
        move(dir, speed, isWorld) { return apeng.NodeHelper.move(this.node, dir, speed, isWorld); }
        setOpacity(opacity) { return apeng.NodeHelper.setOpacity(this.node, opacity); }
        getOpacity() { return apeng.NodeHelper.getOpacity(this.node); }
        isHit(point) { return apeng.NodeHelper.isHit(this.node, point); }
        getRectangle(out, isWorld, ignoreSclae = false) { return apeng.NodeHelper.getRectangle(out, this.node, isWorld, ignoreSclae); }
        gray(isGray) { return apeng.NodeHelper.gray(this.node, isGray); }
        zIndexSort(fn) { return apeng.NodeHelper.zIndexSort(this.node.children, fn); }
        coordinateTracker(uiParent, converNode, camera, distance, useScale) {
            if (!this._coordinateTracker)
                this._coordinateTracker = {
                    converPosition: new apeng.Vec3(),
                    scale: 1
                };
            return apeng.NodeHelper.coordinateTracker(this._coordinateTracker, uiParent, converNode, camera, distance, useScale);
        }
        /**
         * 获取当前节点或子节点第一个匹配的组件
         * 存入缓存中 方便高速取值
         * 如未找到 返回 null
         */
        getCacheComponent(comp) {
            let value = this._cacheComponents.get(comp);
            if (value === undefined) {
                value = apeng.NodeHelper.getAllByComponent(this.node, comp);
                this._cacheComponents.set(comp, value);
            }
            return value;
        }
        /**当前节点或子节点挂载的第一个 动画组件 */
        get AnimtorCC() { return this.getCacheComponent("AnimtorCC"); }
        get AutoTargetSizeCC() { return this.getCacheComponent("AutoTargetSizeCC"); }
        get ButtonCC() { return this.getCacheComponent("ButtonCC"); }
        get ControllerCC() { return this.getCacheComponent("ControllerCC"); }
        get MoveCC() { return this.getCacheComponent("MoveCC"); }
        get SwitchChildrenCC() { return this.getCacheComponent("SwitchChildrenCC"); }
        get SwitchSpriteCC() { return this.getCacheComponent("SwitchSpriteCC"); }
        get ListCC() { return this.getCacheComponent("ListCC"); }
        get DragonBonesCC() { return this.getCacheComponent("DragonBonesCC"); }
        get SpriteLoaderCC() { return this.getCacheComponent("SpriteLoaderCC"); }
        get AnimtorByTweenCC() { return this.getCacheComponent("AnimtorByTweenCC"); }
        get LayoutCC() { return this.getCacheComponent("LayoutCC"); }
        get CreatePrefabToEditorCC() { return this.getCacheComponent("CreatePrefabToEditorCC"); }
        get CreatePrefabToEditorOnceCC() { return this.getCacheComponent("CreatePrefabToEditorOnceCC"); }
        get RenderOpacityAnimCC() { return this.getCacheComponent("RenderOpacityAnimCC"); }
        get SpineCC() { return this.getCacheComponent("SpineCC"); }
        get ListRollCC() { return this.getCacheComponent("ListRollCC"); }
        get FontCC() { return this.getCacheComponent("FontCC"); }
        get ClickChangeViewCC() { return this.getCacheComponent("ClickChangeViewCC"); }
        get SubContextViewCC() { return this.getCacheComponent("SubContextViewCC"); }
        get LevelRollCC() { return this.getCacheComponent("LevelRollCC"); }
        get LayoutCircleCC() { return this.getCacheComponent("LayoutCircleCC"); }
        get DragViewCC() { return this.getCacheComponent("DragViewCC"); }
        get CameraOrbitControlCC() { return this.getCacheComponent("CameraOrbitControlCC"); }
        get JoystickCC() { return this.getCacheComponent("JoystickCC"); }
        get SpriteFrameAnimCC() { return this.getCacheComponent("SpriteFrameAnimCC"); }
        get P2ConstraintEditorCC() { return this.getCacheComponent("P2ConstraintEditorCC"); }
        get P2ShapeEditorCC() { return this.getCacheComponent("P2ShapeEditorCC"); }
        get ProgressCC() { return this.getCacheComponent("ProgressCC"); }
        get CameraTouchMoveCC() { return this.getCacheComponent("CameraTouchMoveCC"); }
        get LabelNumRollCC() { return this.getCacheComponent("LabelNumRollCC"); }
        get ParticleSystem2DCC() { return this.getCacheComponent("ParticleSystem2DCC"); }
        get Collider2DEditorCC() { return this.getCacheComponent("ParticleSystem2DCC"); }
        get Label() { return this.getCacheComponent(apeng.Label); }
        get Sprite() { return this.getCacheComponent(apeng.Sprite); }
        get MotionStreak() { return this.getCacheComponent(apeng.MotionStreak); }
        get Collider2D() { return this.getCacheComponent(apeng.Collider2D); }
        get Layout() { return this.getCacheComponent(apeng.Layout); }
        get Widget() { return this.getCacheComponent(apeng.Widget); }
        get RigidBody2D() { return this.getCacheComponent(apeng.RigidBody2D); }
        get ScrollView() { return this.getCacheComponent(apeng.ScrollView); }
        get ScrollBar() { return this.getCacheComponent(apeng.ScrollBar); }
        get Mask() { return this.getCacheComponent(apeng.Mask); }
        get PageView() { return this.getCacheComponent(apeng.PageView); }
        get UITransform() { return this.getCacheComponent(apeng.UITransform); }
        get UIOpacity() { return this.getCacheComponent(apeng.UIOpacity); }
        get Camera() { return this.getCacheComponent(apeng.Camera); }
        get MeshRenderer() { return this.getCacheComponent(apeng.MeshRenderer); }
        get Graphics() { return this.getCacheComponent(apeng.Graphics); }
        get UIRenderer() { return this.getCacheComponent(apeng.UIRenderer); }
        get spSkeleton() { return this.getCacheComponent(apeng.sp.Skeleton); }
        get BlockInputEvents() { return this.getCacheComponent(apeng.BlockInputEvents); }
        get DragonBonesArmatureDisplay() { return this.getCacheComponent(apeng.dragonBones.ArmatureDisplay); }
        get EditBox() { return this.getCacheComponent(apeng.EditBox); }
        get Animation() { return this.getCacheComponent(apeng.Animation); }
        get ParticleSystem2D() { return this.getCacheComponent(apeng.ParticleSystem2D); }
    };
    __decorate([
        apeng.property({
            tooltip: "对组件进行的备注 功能之类",
            displayName: "组件备注",
            readonly: true,
            visible() { return this.backupDescribe; },
        })
    ], BaseComponent.prototype, "backupDescribe", void 0);
    __decorate([
        apeng.property({
            displayName: "更新数据",
            visible() { return this.onEditorUpdateData; },
        })
    ], BaseComponent.prototype, "editorUpdateData", null);
    __decorate([
        apeng.property({
            displayName: "清除数据",
            visible() { return this.onEditorClearData; },
        })
    ], BaseComponent.prototype, "editorClearData", null);
    BaseComponent = __decorate([
        apeng.ccclass("BaseComponent"),
        apeng.menuComponent("BaseComponent")
    ], BaseComponent);
    apeng.BaseComponent = BaseComponent;
})(apeng || (apeng = {}));
/// <reference path="./Collider2DShape.ts" />
/// <reference path="./../../component/BaseComponent.ts" />
/// <reference path="./../../helper/DirectorHelper.ts" />

(function (apeng) {
    var Collider2DEditorCC_1;
    const sizeT = new apeng.Size();
    const v3T = new apeng.Vec3();
    let ECollider2DShapeTypeCC;
    (function (ECollider2DShapeTypeCC) {
        ECollider2DShapeTypeCC[ECollider2DShapeTypeCC["None"] = 0] = "None";
        ECollider2DShapeTypeCC[ECollider2DShapeTypeCC["Circle"] = 1] = "Circle";
        ECollider2DShapeTypeCC[ECollider2DShapeTypeCC["Point"] = 2] = "Point";
        ECollider2DShapeTypeCC[ECollider2DShapeTypeCC["Polygon"] = 3] = "Polygon";
        ECollider2DShapeTypeCC[ECollider2DShapeTypeCC["Box"] = 4] = "Box";
    })(ECollider2DShapeTypeCC || (ECollider2DShapeTypeCC = {}));
    apeng.ccenum(ECollider2DShapeTypeCC);
    /**
     * 形状编辑器基类
     * 提供基础数据接口
     * 如有复杂功能 多个碰撞管理 可使用此组件
     *
     * 支持节点缩放 节点z轴旋转
     * 偏移加旋转
     */
    let Collider2DEditorCC = Collider2DEditorCC_1 = class Collider2DEditorCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "范围框调试";
            this.editorColor = new apeng.Color(0, 255, 0);
            this.editorLineWidth = 6;
            this.runEditorShow = true;
            this.tag = "";
            this._shapeType = ECollider2DShapeTypeCC.None;
            this._circleRadius = 0;
            this._boxSize = new apeng.Size();
            this._shapeOffset = new apeng.Vec2();
            this._poygonPoints = [];
            this.onEditorUpdateData = this.updateCCGraphics;
            this.shape = null;
        }
        set shapeType(value) {
            if (this._shapeType == value)
                return;
            this._shapeType = value;
            this.updateCCGraphics();
        }
        get shapeType() { return this._shapeType; }
        set circleRadius(value) {
            if (this._circleRadius == value)
                return;
            this._circleRadius = value;
            this.updateCCGraphics();
        }
        get circleRadius() { return this._circleRadius; }
        set boxSize(value) {
            if (this._boxSize.equals(value))
                return;
            this._boxSize.set(value);
            this.updateCCGraphics();
        }
        get boxSize() { return this._boxSize; }
        set poygonPoints(value) {
            this._poygonPoints = value;
            this.updateCCGraphics();
        }
        get poygonPoints() { return this._poygonPoints; }
        set shapeOffset(value) {
            if (this._shapeOffset.equals(value))
                return;
            this._shapeOffset.set(value);
            this.updateCCGraphics();
        }
        get shapeOffset() { return this._shapeOffset; }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                switch (this._shapeType) {
                    case ECollider2DShapeTypeCC.Circle:
                        if (this._circleRadius == 0)
                            this.circleRadius = this.UITransform.width / 2;
                        break;
                    case ECollider2DShapeTypeCC.Box:
                        if (this._boxSize.width == 0 && this._boxSize.height == 0) {
                            sizeT.set(this.UITransform.contentSize);
                            this.boxSize = sizeT;
                        }
                        break;
                    case ECollider2DShapeTypeCC.Polygon:
                        if (this._poygonPoints.length == 0) {
                            let points = [];
                            let size = this.UITransform.contentSize;
                            for (let i = 0; i < 4; i++) {
                                if (i == 0)
                                    points[i] = new apeng.Vec2(-size.width / 2, -size.height / 2);
                                else if (i == 1)
                                    points[i] = new apeng.Vec2(size.width / 2, -size.height / 2);
                                else if (i == 2)
                                    points[i] = new apeng.Vec2(size.width / 2, size.height / 2);
                                else if (i == 3)
                                    points[i] = new apeng.Vec2(-size.width / 2, size.height / 2);
                            }
                            this._poygonPoints = points;
                        }
                        break;
                }
            }
            else
                this.updateCCGraphics();
        }
        onFocusInEditor() {
            this.updateCCGraphics();
        }
        onLostFocusInEditor() {
            if (this._shapeType == ECollider2DShapeTypeCC.None)
                return;
            this.getGraphics().clear();
        }
        updateCCGraphics() {
            if (!apeng.EDITOR) {
                if (!this.runEditorShow)
                    return;
                if (!Collider2DEditorCC_1.debug)
                    return;
            }
            if (this._shapeType == ECollider2DShapeTypeCC.None)
                return;
            let grap = this.getGraphics();
            grap.strokeColor = this.editorColor;
            grap.lineWidth = this.editorLineWidth;
            grap.clear();
            switch (this._shapeType) {
                case ECollider2DShapeTypeCC.Circle:
                    grap.circle(this._shapeOffset.x, this._shapeOffset.y, this._circleRadius);
                    break;
                case ECollider2DShapeTypeCC.Box:
                    grap.rect(this._shapeOffset.x - this._boxSize.width / 2, this._shapeOffset.y - this._boxSize.height / 2, this._boxSize.width, this._boxSize.height);
                    break;
                case ECollider2DShapeTypeCC.Polygon:
                    if (this._poygonPoints.length > 2) {
                        grap.moveTo(this._poygonPoints[0].x + this._shapeOffset.x, this._poygonPoints[0].y + this._shapeOffset.y);
                        for (let i = 1, length = this._poygonPoints.length + 1; i < length; i++) {
                            let index = i == (length - 1) ? 0 : i;
                            let point = this._poygonPoints[index];
                            grap.lineTo(point.x + this._shapeOffset.x, point.y + this._shapeOffset.y);
                        }
                    }
                    break;
                case ECollider2DShapeTypeCC.Point:
                    grap.circle(this._shapeOffset.x, this._shapeOffset.y, 5);
                    grap.fill();
                    break;
            }
            grap.stroke();
        }
        getGraphics() {
            return this.getChildByCreate(this.uuid + "graphics", (node) => {
                node.addComponent(apeng.Graphics);
            }).getComponent(apeng.Graphics);
        }
        /**
         * 创建形状数据
         * @param group
         * @param owner
         * @returns
         */
        getShape(group, point) {
            if (!point)
                point = this.node.position;
            if (this.shape) {
                this.shape.updatePosition(point);
                return this.shape;
            }
            this.shape = this._getShape(group, point);
            this.updateNodeByShape();
            if (Collider2DEditorCC_1.debug && this.runEditorShow) {
                this.shape.onSetCollider = (isCollider) => {
                    if (isCollider)
                        this.onFocusInEditor();
                    else
                        this.onLostFocusInEditor();
                };
                this.shape.onClear = () => {
                    this.onLostFocusInEditor();
                };
            }
            return this.shape;
        }
        _getShape(group, point) {
            let shape = null;
            if (this._shapeType == ECollider2DShapeTypeCC.None)
                return shape;
            switch (this._shapeType) {
                case ECollider2DShapeTypeCC.Circle:
                    shape = new apeng.Collider2DCircle(point, group, this._circleRadius);
                    break;
                case ECollider2DShapeTypeCC.Point:
                    shape = new apeng.Collider2DPoint(point, group);
                    break;
                case ECollider2DShapeTypeCC.Box:
                    shape = new apeng.Collider2DBox(point, group, this._boxSize.width, this._boxSize.height);
                    break;
                case ECollider2DShapeTypeCC.Polygon:
                    if (this._poygonPoints.length > 2)
                        shape = new apeng.Collider2DPolygon(point, group, this._poygonPoints);
                    break;
            }
            return shape;
        }
        updateNodeByShape() {
            if (!this.shape)
                return;
            this.shape.mul = this.node.scale.x;
            this.shape.updateAngle(apeng.Maths.toRadian(this.node.rotation.getEulerAngles(v3T).z));
            this.shape.setOffset(this._shapeOffset);
        }
    };
    /**开启碰撞框调试 */
    Collider2DEditorCC.debug = true;
    __decorate([
        apeng.property({
            displayName: "编辑框颜色"
        })
    ], Collider2DEditorCC.prototype, "editorColor", void 0);
    __decorate([
        apeng.property({
            displayName: "编辑框线宽"
        })
    ], Collider2DEditorCC.prototype, "editorLineWidth", void 0);
    __decorate([
        apeng.property({
            displayName: "运行时显示线框"
        })
    ], Collider2DEditorCC.prototype, "runEditorShow", void 0);
    __decorate([
        apeng.property({
            tooltip: "当有多个组件挂在相同节点时 方便区分"
        })
    ], Collider2DEditorCC.prototype, "tag", void 0);
    __decorate([
        apeng.property({
            type: ECollider2DShapeTypeCC,
            displayName: "碰撞器类型"
        })
    ], Collider2DEditorCC.prototype, "shapeType", null);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "半径",
            visible() { return this._shapeType == ECollider2DShapeTypeCC.Circle; }
        })
    ], Collider2DEditorCC.prototype, "circleRadius", null);
    __decorate([
        apeng.property({
            displayName: "宽高",
            visible() { return this._shapeType == ECollider2DShapeTypeCC.Box; }
        })
    ], Collider2DEditorCC.prototype, "boxSize", null);
    __decorate([
        apeng.property({
            type: [apeng.Vec2],
            displayName: "范围点",
            visible() { return this._shapeType == ECollider2DShapeTypeCC.Polygon; }
        })
    ], Collider2DEditorCC.prototype, "poygonPoints", null);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "形状偏移",
            visible() { return this._shapeType != ECollider2DShapeTypeCC.None; }
        })
    ], Collider2DEditorCC.prototype, "shapeOffset", null);
    __decorate([
        apeng.property({ serializable: true })
    ], Collider2DEditorCC.prototype, "_shapeType", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], Collider2DEditorCC.prototype, "_circleRadius", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], Collider2DEditorCC.prototype, "_boxSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], Collider2DEditorCC.prototype, "_shapeOffset", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], Collider2DEditorCC.prototype, "_poygonPoints", void 0);
    Collider2DEditorCC = Collider2DEditorCC_1 = __decorate([
        apeng.ccclass("Collider2DEditorCC"),
        apeng.executeInEditMode,
        apeng.menuShape("Collider2DEditorCC")
    ], Collider2DEditorCC);
    apeng.Collider2DEditorCC = Collider2DEditorCC;
})(apeng || (apeng = {}));
/// <reference path="./Collider2DShape.ts" />

(function (apeng) {
    class Collider2DPoint extends apeng.Collider2DShape {
        constructor(position, group) {
            super();
            this.type = apeng.ECollider2DShapeType.Point;
            this.point = new apeng.Vector2();
            apeng.Vector2.set(this.position, position);
            this.group = group;
        }
        getPoint() {
            if (!this.dataDirty)
                return this.point;
            this.dataDirty = false;
            this.point.set(this.offset);
            // 绕偏移旋转
            if (this.angle != 0)
                if (!this.offset.equals(apeng.Vector2.ZERO)) {
                    this.point.rotateSelf(this.angle);
                }
            return this.point.addSelf(this.position);
        }
    }
    apeng.Collider2DPoint = Collider2DPoint;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
    * 四叉树叶节点
    */
    class Collider2DQuadtree {
        constructor() {
            this.root = null;
            this.parent = null;
            /**当前空间的范围 */
            this.rect = null;
            /**子包围盒 */
            this.child = null;
            /**当前层级 */
            this.curLevel = 0;
            /**分到当前块的数据 */
            this.colliders = [];
            /**可碰撞的碰撞体数据  减少碰撞基数 */
            this.colliderByGroup = {};
            /**手动更新个数 减少 array.length 消耗 */
            this.colliderSize = 0;
        }
        /**添加数据 */
        addShape(shpae) {
            this.colliders.push(shpae);
            this.colliderSize = this.colliders.length;
            // 添加可碰撞数据
            let groupCollider = this.colliderByGroup[shpae.group];
            if (groupCollider == undefined) {
                groupCollider = [];
                this.colliderByGroup[shpae.group] = groupCollider;
            }
            groupCollider.push(shpae);
        }
        /**
         * 从树中删除一块数据
         * @param shpae
         */
        remove(shpae) {
            apeng.Sets.delete(this.colliders, shpae);
            this.colliderSize = this.colliders.length;
            let groupCollider = this.colliderByGroup[shpae.group];
            if (groupCollider)
                apeng.Sets.delete(groupCollider, shpae);
        }
        /**清除当前树 */
        clear() {
            if (this.child)
                for (let child of this.child)
                    child.clear();
            this.parent = null;
            this.rect = null;
            this.child = null;
            this.curLevel = 0;
            this.colliders.length = 0;
            this.colliderSize = 0;
            for (let key in this.colliderByGroup)
                this.colliderByGroup[key].length = 0;
        }
        /**
         * 添加一个数据
         * 会自动判断进入分块中
         * @param _item
         */
        add(item) {
            if (this.rect && this.hasRect(this.rect, item)) {
                if (this.child == null) {
                    this.addShape(item);
                    // 分裂子节点
                    if (this.curLevel < this.root.maxLevel) {
                        this.child = [];
                        // 创建子节点
                        for (let rect of this.rect.quadtree()) {
                            let tree = new Collider2DQuadtree();
                            tree.rect = rect;
                            tree.parent = this;
                            tree.root = this.root;
                            tree.curLevel = tree.getLevel();
                            for (let items of this.colliders)
                                tree.add(items);
                            this.child.push(tree);
                        }
                        this.colliders.length = 0;
                        this.colliderSize = this.colliders.length;
                    }
                    else {
                        // 根节点不添加
                        if (this.parent) {
                            item.octree.push(this);
                        }
                    }
                }
                else {
                    for (let child of this.child)
                        child.add(item);
                }
            }
        }
        /**
         * 获取当前的深度层
         * @returns
         */
        getLevel() {
            let level = 0;
            let parent = this.parent;
            while (parent) {
                parent = parent.parent;
                level++;
            }
            return level;
        }
        hasRect(rect, shpae) {
            switch (shpae.type) {
                // 矩形与多边形
                case apeng.ECollider2DShapeType.Polygon:
                    return apeng.Polygon.rectPolygon(rect, shpae.getPolygon());
                // 点与矩形
                case apeng.ECollider2DShapeType.Point:
                    return rect.contains(shpae.getPoint());
                // 圆与矩形
                case apeng.ECollider2DShapeType.Circle:
                    return apeng.Polygon.rectCircle(rect, shpae.getCircle());
            }
            return false;
        }
    }
    apeng.Collider2DQuadtree = Collider2DQuadtree;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
    * 碰撞管理
    * 分组
    * 多边形，点， 圆，矩形
    * 旋转(偏移旋转)
    * 四叉树(将所有碰撞块放入最后一层子节点中)
    */
    class Collider2DRoot extends apeng.Collider2DQuadtree {
        constructor() {
            super();
            this._frame = 60;
            this._frameInterval = 1 / 60;
            this._enableQuadTree = false;
            /**分组控制 */
            this.group = new apeng.ColliderGroup();
            /**最大层级深度 */
            this.maxLevel = 3;
            this.ids = 0;
            /**动态更新位置的集合 */
            this.updateShapes = [];
            /**逻辑帧的执行次数 */
            this.cycleCount = 0;
            this._updateAABB = false;
            this.curFrameDelta = 0;
            /**更新前调用 */
            this.preOnUpdate = null;
            this.root = this;
        }
        static has(self, other) {
            let type = self.type;
            let otherType = other.type;
            let isCollider = false;
            let circleType = apeng.ECollider2DShapeType.Circle;
            let polygonType = apeng.ECollider2DShapeType.Polygon;
            let pointType = apeng.ECollider2DShapeType.Point;
            if (type == polygonType) {
                let polygon = self.getPolygon();
                if (otherType == polygonType)
                    isCollider = apeng.Polygon.polygonPolygon(polygon, other.getPolygon());
                else if (otherType == pointType)
                    isCollider = apeng.Polygon.pointInPolygon(other.getPoint(), polygon);
                else if (otherType == apeng.ECollider2DShapeType.Circle)
                    isCollider = apeng.Polygon.polygonCircle(polygon, other.getCircle());
            }
            else if (type == circleType) {
                let circle = self.getCircle();
                if (otherType == polygonType) {
                    isCollider = apeng.Polygon.polygonCircle(other.getPolygon(), circle);
                }
                else if (otherType == pointType)
                    isCollider = circle.contains(other.getPoint());
                else if (otherType == circleType)
                    isCollider = circle.intersects(other.getCircle());
            }
            else if (type == pointType) {
                let point = self.getPoint();
                if (otherType == polygonType) {
                    isCollider = apeng.Polygon.pointInPolygon(point, other.getPolygon());
                }
                else if (otherType == pointType)
                    isCollider = point.equals(other.getPoint());
                else if (otherType == circleType)
                    isCollider = other.getCircle().contains(point);
            }
            return isCollider;
        }
        /**间隔多少帧执行一次循环 值越小 性能越高 */
        set frame(value) {
            this._frame = value;
            this._frameInterval = 1 / this._frame;
        }
        get frame() { return this._frame; }
        /**激活四叉树 */
        set enableQuadTree(value) {
            this._enableQuadTree = value;
            this.cycleCount = 0;
        }
        get enableQuadTree() { return this._enableQuadTree; }
        /**
         * 初始化八叉树
         * 如不初始化 则使用 双层for循环
         * @param maxAABB 根包围盒，应当包含所有子块
         * @param maxLevel 子节点分层
         */
        initQuadtree(x, y, width, height, maxLevel = 3) {
            this.rect = new apeng.Rectangle(x, y, width, height);
            this.maxLevel = maxLevel;
            this.enableQuadTree = true;
        }
        /**添加数据 */
        add(item) {
            this.addShape(item);
            super.add(item);
        }
        addShape(shpae) {
            if (shpae.id !== null)
                return;
            shpae.id = this.ids;
            shpae.root = this;
            this.ids++;
            if (shpae.updateShape)
                this.updateShapes.push(shpae);
            super.addShape(shpae);
        }
        /**
         * 移除数据
         * @param shpae
         */
        remove(shpae) {
            apeng.Sets.delete(this.root.updateShapes, shpae);
            shpae.clear();
            super.remove(shpae);
        }
        /**帧循环 */
        onUpdate(dt) {
            // this.curFrameDelta += dt
            // if (this.curFrameDelta > this._frameInterval) {
            //     this.curFrameDelta -= this._frameInterval
            if (this.preOnUpdate)
                this.preOnUpdate();
            this.updateShape();
            this.cycleCount = 0;
            if (this._enableQuadTree)
                this.quadtreeCollider(this.child);
            else
                this.defaultCollider();
            // 更新形状标记
            for (let shape of this.colliders)
                shape.dataDirty = true;
            // }
        }
        /**
         * 更新需要动态更新aabb
         */
        updateShape() {
            if (this.updateShapes.length == 0)
                return;
            for (let item of this.updateShapes) {
                if (this._enableQuadTree) {
                    if (item.octree.length > 0) {
                        this._updateAABB = item.updateShape(item);
                        if (this._updateAABB)
                            this.updateShapeByQuadtree(item);
                    }
                }
                else
                    item.updateShape(item);
            }
        }
        /**更新形状到树中 */
        updateShapeByQuadtree(shape) {
            if (this._enableQuadTree) {
                shape.removeFormOctreeItem();
                this.add(shape);
            }
        }
        /**双层for循环碰撞 */
        defaultCollider() {
            // 分组碰撞
            if (this.colliderSize < 2)
                return;
            this.groupByCollider(this.colliderByGroup);
        }
        /**分组碰撞 */
        groupByCollider(shapes) {
            let colliders = this.group.colliders, i = 0, otherGroup = 0, curShape = null, otherShape = null, otherColliderGroups = null;
            for (let group in shapes) {
                otherColliderGroups = colliders[group];
                if (otherColliderGroups) {
                    curShape = shapes[group];
                    for (i = 0; i < otherColliderGroups.length; i++) {
                        otherGroup = otherColliderGroups[i];
                        otherShape = shapes[otherGroup];
                        if (otherShape) {
                            this.colliderOther(curShape, otherShape);
                        }
                    }
                }
            }
        }
        /**四叉树碰撞 */
        quadtreeCollider(childs) {
            if (childs)
                for (let child of childs) {
                    if (child.child == null)
                        this.groupByCollider(child.colliderByGroup);
                    else
                        this.quadtreeCollider(child.child);
                }
        }
        /**
         * 清空数据
         */
        clear() {
            for (let value of this.colliders)
                value.clear();
            this.cycleCount = 0;
            this.ids = 0;
            this.updateShapes.length = 0;
            this.curFrameDelta = 0;
            super.clear();
        }
        /**
           * 相交碰撞检测
           * 以性能最高方式编写 使用临时变量 栈高速存取
           * 减少函数调用
           * 减少array.length
           * @param items
           * @param length
           * @returns
           */
        colliderOther(selfs, others) {
            let self = null, other = null, otherCollider = null, selfCollider = null, i = 0, index = -1, onColliderUpdate = null, onColliderEnter = null, onColliderExit = null, isCall = null;
            for (i = 0; i < selfs.length; i++) {
                self = selfs[i];
                if (!self._isCollider)
                    continue;
                if (self.id == null)
                    continue;
                onColliderUpdate = self.onColliderUpdate;
                onColliderEnter = self.onColliderEnter;
                onColliderExit = self.onColliderExit;
                isCall = !(onColliderEnter || onColliderUpdate || onColliderExit);
                // 接受碰撞回调
                if (isCall)
                    continue;
                otherCollider = self.otherCollider;
                for (let j = 0; j < others.length; j++) {
                    other = others[j];
                    if (self == other)
                        continue;
                    if (!other._isCollider)
                        continue;
                    if (other.id == null)
                        continue;
                    selfCollider = other.selfCollider;
                    let isCollider = Collider2DRoot.has(self, other);
                    if (isCollider) {
                        // 派发开始回调
                        index = otherCollider.indexOf(other);
                        if (index == -1) {
                            otherCollider.push(other);
                            other.selfCollider.push(self);
                            if (onColliderEnter)
                                onColliderEnter(self, other);
                            // let otherOnColliderEnter = other.onColliderEnter
                            // if (otherOnColliderEnter)
                            //     otherOnColliderEnter(other, self)
                        }
                        // // 派发开始回调
                        if (onColliderUpdate)
                            onColliderUpdate(self, other);
                        // let otherOnColliderUpdate = other.onColliderUpdate
                        // if (otherOnColliderUpdate)
                        //     otherOnColliderUpdate(other, self)
                    }
                    else {
                        index = otherCollider.indexOf(other);
                        if (index != -1) {
                            otherCollider.splice(index, 1);
                            index = other.selfCollider.indexOf(self);
                            if (index != -1)
                                other.selfCollider.splice(index, 1);
                            if (onColliderExit)
                                onColliderExit(self, other);
                            // let otherOnColliderExit = other.onColliderExit
                            // if (otherOnColliderExit)
                            //     otherOnColliderExit(other, self)
                        }
                    }
                    self.isColliderEnter = isCollider;
                    // other.isColliderEnter = isCollider
                }
                this.cycleCount++;
            }
        }
        /**获取添加到所有块的个数 */
        getItemAllCount() {
            let count = 0;
            let countCall = (childs) => {
                if (childs)
                    for (let child of childs) {
                        count += child.colliders.length;
                        countCall(child.child);
                    }
            };
            countCall(this.child);
            return count;
        }
    }
    apeng.Collider2DRoot = Collider2DRoot;
})(apeng || (apeng = {}));
/// <reference path="./Maths.ts" />
/// <reference path="./Pool.ts" />

(function (apeng) {
    let _x = 0.0;
    let _y = 0.0;
    let _z = 0.0;
    class Vector3 {
        constructor(x, y, z) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.set(x, y, z);
        }
        /**
         *  排除浮点数误差的向量近似等价判断
         */
        static equals(a, b, epsilon = 0.01) {
            return (Math.abs(a.x - b.x)
                <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x))
                && Math.abs(a.y - b.y)
                    <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y))
                && Math.abs(a.z - b.z)
                    <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)));
        }
        static equalsZero(a, b) {
            if (a.z === undefined)
                return a.x == b.x && a.y == b.y;
            return a.x == b.x && a.y == b.y && a.z == b.z;
        }
        /** 逐元素向量加法  */
        static add(out, a, b) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            return out;
        }
        /**逐元素向量减法 */
        static sub(out, a, b) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            return out;
        }
        /**绕X轴旋转向量指定角度度 */
        static rotateX(out, rotate, orgin, angle) {
            const x = rotate.x - orgin.x;
            const y = rotate.y - orgin.y;
            const z = rotate.z - orgin.z;
            const radian = apeng.Maths.toRadian(angle);
            const cos = Math.cos(radian);
            const sin = Math.sin(radian);
            const rx = x;
            const ry = y * cos - z * sin;
            const rz = y * sin + z * cos;
            out.x = rx + orgin.x;
            out.y = ry + orgin.y;
            out.z = rz + orgin.z;
            return out;
        }
        /**绕Y轴旋转向量指定角度度 */
        static rotateY(out, rotate, orgin, angle) {
            const x = rotate.x - orgin.x;
            const y = rotate.y - orgin.y;
            const z = rotate.z - orgin.z;
            const radian = apeng.Maths.toRadian(angle);
            const cos = Math.cos(radian);
            const sin = Math.sin(radian);
            const rx = z * sin + x * cos;
            const ry = y;
            const rz = z * cos - x * sin;
            out.x = rx + orgin.x;
            out.y = ry + orgin.y;
            out.z = rz + orgin.z;
            return out;
        }
        /**绕Z轴旋转向量指定角度度 */
        static rotateZ(out, rotate, orgin, angle) {
            const x = rotate.x - orgin.x;
            const y = rotate.y - orgin.y;
            const z = rotate.z - orgin.z;
            const radian = apeng.Maths.toRadian(angle);
            const cos = Math.cos(radian);
            const sin = Math.sin(radian);
            const rx = x * cos - y * sin;
            const ry = x * sin + y * cos;
            const rz = z;
            out.x = rx + orgin.x;
            out.y = ry + orgin.y;
            out.z = rz + orgin.z;
            return out;
        }
        /**
        * 缩放当前向量。如果你想结果保存到另一个向量，可使用 mul() 代替。
        * @method mulSelf
        * @param {number} num
        * @return {Vec2} returns this
        * @chainable
        * @example
        * var v = _cc_.v2(10, 10)
        * v.mulSelf(5)// return Vec2 {x: 50, y: 50}
        */
        static mul(out, value, num) {
            if (typeof num == "number") {
                out.x = value.x * num;
                out.y = value.y * num;
                out.z = value.z * num;
            }
            else {
                out.x = value.x * num.x;
                out.y = value.y * num.y;
                out.z = value.z * num.z;
            }
            return out;
        }
        static cloneTo(self, out) {
            out.x = self.x;
            out.y = self.y;
            out.z = self.z;
            return out;
        }
        static set(self, x, y, z) {
            if (x && x[0] !== undefined) {
                self.x = x[0];
                self.y = x[1];
                self.z = x[2] || 0;
            }
            else if (x && typeof x === "object") {
                self.x = x.x;
                self.y = x.y;
                self.z = x.z;
            }
            else {
                self.x = (x || 0);
                self.y = y || 0;
                self.z = z || 0;
            }
            return self;
        }
        /**
         * 转换为方便阅读的字符串。
         * @method toString
         * @return {string}
         */
        static toString(value) {
            return "(" + value.x.toFixed(2) + ", " + value.y.toFixed(2) + ", " + value.z.toFixed(2) + ")";
        }
        /**
         * 求向量长度
         */
        static len(value) {
            return Math.sqrt(Vector3.lengthSqr(value));
        }
        /**
         * 求向量长度平方
         */
        static lengthSqr(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        /**
         * 将当前向量归一化
         */
        static normalize(out, value) {
            const x = value.x;
            const y = value.y;
            const z = value.z;
            let len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
                out.z = z * len;
            }
            return out;
        }
        /**
         * 找到多边形的中心点
         * @param polygon
         */
        static polygonByCenterPoint(out, polygon) {
            let minX = polygon[0].x;
            let maxX = polygon[0].x;
            let minY = polygon[0].y;
            let maxY = polygon[0].y;
            let minZ = polygon[0].z;
            let maxZ = polygon[0].z;
            for (let value of polygon) {
                if (minX > value.x)
                    minX = value.x;
                if (maxX < value.x)
                    maxX = value.x;
                if (minY > value.y)
                    minY = value.y;
                if (maxY < value.y)
                    maxY = value.y;
                if (minZ > value.z)
                    minZ = value.z;
                if (maxZ < value.z)
                    maxZ = value.z;
            }
            out.x = minX + Math.abs(maxX - minX) / 2;
            out.y = minY + Math.abs(maxY - minY) / 2;
            out.z = minZ + Math.abs(maxZ - minZ) / 2;
            return out;
        }
        /**
         * 两个三维向量距离。 不开方
         * @param	value1 向量1。
         * @param	value2 向量2。
         * @return	距离。
         */
        static distanceSqr(value1, value2) {
            v3T.x = value1.x - value2.x;
            v3T.y = value1.y - value2.y;
            v3T.z = value1.z - value2.z;
            return (v3T.x * v3T.x) + (v3T.y * v3T.y) + (v3T.z * v3T.z);
        }
        /**
       * 两个三维向量距离。
       * @param	value1 向量1。
       * @param	value2 向量2。
       * @return	距离。
       */
        static distance(value1, value2) {
            return Math.sqrt(this.distanceSqr(value1, value2));
        }
        /**
         * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
         * @param to 目标向量。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        static lerp(out, from, to, ratio) {
            _x = from.x;
            _y = from.y;
            _z = from.z;
            if (typeof ratio === "number")
                v3T.set(ratio, ratio, ratio);
            else
                v3T.set(ratio);
            out.x = _x + v3T.x * (to.x - _x);
            out.y = _y + v3T.y * (to.y - _y);
            out.z = _z + v3T.z * (to.z - _z);
            return out;
        }
        set(x, y, z) { return Vector3.set(this, x, y, z); }
        equals(b, epsilon = 0.01) { return Vector3.equals(this, b, epsilon); }
        sub(out, other) { return Vector3.sub(out, this, other); }
        subSelf(other) { return Vector3.sub(this, this, other); }
        add(out, other) { return Vector3.add(out, this, other); }
        addSelf(other) { return Vector3.add(this, this, other); }
        clone() { return new Vector3(this); }
        len() { return Vector3.len(this); }
        toString() { return Vector3.toString(this); }
        lengthSqr() { return Vector3.lengthSqr(this); }
        mul(out, num) { return Vector3.mul(out, this, num); }
        mulSelf(num) { return Vector3.mul(this, this, num); }
        rotateX(orgin, angle) { return Vector3.rotateX(this, this, orgin, angle); }
        rotateY(orgin, angle) { return Vector3.rotateY(this, this, orgin, angle); }
        rotateZ(orgin, angle) { return Vector3.rotateZ(this, this, orgin, angle); }
        normalize(out) { return Vector3.normalize(out, this); }
        normalizeSelf() { return Vector3.normalize(this, this); }
    }
    Vector3.pool = new apeng.PoolOnce(1000, () => new Vector3(), (data) => { data.set(); });
    /**零向量,禁止修改*/
    Vector3.ZERO = new Vector3(0, 0);
    Vector3.ONE = new Vector3(1, 1, 1);
    apeng.Vector3 = Vector3;
    const v3T = new Vector3();
})(apeng || (apeng = {}));
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    /**轴对齐球 */
    class Sphere {
        constructor(center, radius) {
            /** 本地坐标的中心点 */
            this.center = new apeng.Vector3();
            /**半径 */
            this.radius = 0;
            this.set(center, radius);
        }
        static toAABB(sphere, out) {
            out.center.set(sphere.center);
            out.halfExtents.set(sphere.radius, sphere.radius, sphere.radius);
            return out;
        }
        static set(out, center, radius) {
            if (center)
                apeng.Vector3.set(out.center, center);
            out.radius = radius || 0;
            return out;
        }
        set(center, radius) { return Sphere.set(this, center, radius); }
        toAABB(out) { return Sphere.toAABB(this, out); }
    }
    apeng.Sphere = Sphere;
})(apeng || (apeng = {}));
/// <reference path="./Sphere.ts" />
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    /**轴对齐包围盒形状 */
    let EAabbShape;
    (function (EAabbShape) {
        /**盒子 */
        EAabbShape[EAabbShape["box"] = 0] = "box";
        /**球形 根据最小点最大点的差值取半径 为球形*/
        EAabbShape[EAabbShape["Sphere"] = 1] = "Sphere";
        /**圆柱 y轴为高度 xz最小点与最大点的差值取半径 */
        EAabbShape[EAabbShape["cylinder"] = 2] = "cylinder";
    })(EAabbShape = apeng.EAabbShape || (apeng.EAabbShape = {}));
    const v3T = new apeng.Vector3();
    const v3T2 = new apeng.Vector3();
    const v3T3 = new apeng.Vector3();
    const v3T4 = new apeng.Vector3();
    /**轴对齐包围盒 */
    class AABB {
        constructor(center, halfExtents, shape) {
            /** 本地坐标的中心点 */
            this.center = new apeng.Vector3();
            /** 长宽高的一半 */
            this.halfExtents = new apeng.Vector3();
            /**当前形状 */
            this.shape = EAabbShape.box;
            this._octree = null;
            this._cylindreTemp = null;
            this._sphereTemp = null;
            this._randomPosition = new apeng.Vector3();
            this._min = new apeng.Vector3();
            this._max = new apeng.Vector3();
            this._getBottomPolygon = null;
            this.set(center, halfExtents);
            if (shape != undefined)
                this.shape = shape;
        }
        /**
         * 包围盒转包围球
         * @param aabb
         * @param out
         */
        static toSphere(aabb, out) {
            out.center.set(aabb.center);
            out.radius = Math.min(aabb.halfExtents.x, aabb.halfExtents.y, aabb.halfExtents.z);
            return out;
        }
        /**
         * 包围盒转圆柱
         * @param aabb
         * @param out
         */
        static toCylinder(aabb, out) {
            out.center.set(aabb.center);
            out.radius = Math.min(aabb.halfExtents.x, aabb.halfExtents.z);
            out.height = aabb.halfExtents.y * 2;
            return out;
        }
        /**
         * 计算 aabb 上最接近给定点的点
         * @param {Vec3} point 给定点
         * @param {AABB} aabb 轴对齐包围盒
         * @return {Vec3} 最近点
         */
        static ptPointAabb(aabb, point) {
            v3T.set(point);
            v3T2.set(aabb.min());
            v3T3.set(aabb.max());
            v3T.x = (v3T.x < v3T2.x) ? v3T2.x : v3T.x;
            v3T.y = (v3T.y < v3T2.y) ? v3T2.y : v3T.y;
            v3T.z = (v3T.z < v3T2.z) ? v3T2.z : v3T.z;
            v3T.x = (v3T.x > v3T3.x) ? v3T3.x : v3T.x;
            v3T.y = (v3T.y > v3T3.y) ? v3T3.y : v3T.y;
            v3T.z = (v3T.z > v3T3.z) ? v3T3.z : v3T.z;
            return v3T;
        }
        /**
         * 当前盒子包含指定盒子
         * @param self
         * @param other
         */
        static containsAABB(self, other) {
            v3T2.set(self.min());
            v3T3.set(self.max());
            v3T.set(other.min());
            v3T4.set(other.max());
            return (v3T2.x <= v3T.x && v3T3.x >= v3T4.x)
                && (v3T2.y <= v3T.y && v3T3.y >= v3T4.y)
                && (v3T2.z <= v3T.z && v3T3.z >= v3T4.z);
        }
        static create(center, halfExtents) {
            return new AABB(center, halfExtents);
        }
        /**
         * 从两个点创建一个新的 AABB。
         * @param out - 接受操作的 AABB。
         * @param minPos - AABB 的最小点。
         * @param maxPos - AABB 的最大点。
         * @returns {AABB} out 接受操作的 AABB。
         */
        static fromPoints(out, minPos, maxPos) {
            apeng.Vector3.add(v3T, maxPos, minPos);
            apeng.Vector3.sub(v3T, maxPos, minPos);
            apeng.Vector3.mul(out.center, v3T, 0.5);
            apeng.Vector3.mul(out.halfExtents, v3T, 0.5);
            return out;
        }
        static set(out, center, halfExtents) {
            if (center)
                apeng.Vector3.set(out.center, center);
            if (halfExtents)
                apeng.Vector3.set(out.halfExtents, halfExtents);
            return out;
        }
        /**将当前包围盒分成8等分的包围盒 */
        static octree(out, value) {
            v3T.set(value.halfExtents.x / 2, value.halfExtents.y / 2, value.halfExtents.z / 2);
            for (let i = 0; i < 8; i++)
                out[i].halfExtents.set(v3T);
            // 左前上角
            out[0].center.set(value.center.x - v3T.x, value.center.y + v3T.y, value.center.z + v3T.z);
            // 右前上角
            out[1].center.set(value.center.x + v3T.x, value.center.y + v3T.y, value.center.z + v3T.z);
            // 左前下角
            out[2].center.set(value.center.x - v3T.x, value.center.y - v3T.y, value.center.z + v3T.z);
            // 右前下角
            out[3].center.set(value.center.x + v3T.x, value.center.y - v3T.y, value.center.z + v3T.z);
            //------------z轴后面一排
            // 左后上角
            out[4].center.set(value.center.x - v3T.x, value.center.y + v3T.y, value.center.z - v3T.z);
            // 右后上角
            out[5].center.set(value.center.x + v3T.x, value.center.y + v3T.y, value.center.z - v3T.z);
            // 左后下角
            out[6].center.set(value.center.x - v3T.x, value.center.y - v3T.y, value.center.z - v3T.z);
            // 右后下角
            out[7].center.set(value.center.x + v3T.x, value.center.y - v3T.y, value.center.z - v3T.z);
            return out;
        }
        static randomPosition(out, value) {
            let min = value.min();
            let max = value.max();
            out.x = apeng.Maths.minToMax(min.x, max.x);
            out.y = apeng.Maths.minToMax(min.y, max.y);
            out.z = apeng.Maths.minToMax(min.z, max.z);
            return out;
        }
        static min(out, value) {
            return apeng.Vector3.sub(out, value.center, value.halfExtents);
        }
        static max(out, value) {
            return apeng.Vector3.add(out, value.center, value.halfExtents);
        }
        /**判断当前矩形是否包含指定的点 */
        static contains(self, point) {
            let min = self.min();
            let max = self.max();
            return (min.x <= point.x
                && max.x >= point.x
                && min.y <= point.y
                && max.y >= point.y
                && min.z <= point.z
                && max.z >= point.z);
        }
        static getBottomPolygon(out, value) {
            let min = value.min();
            let max = value.max();
            apeng.Vector2.set(out[0], min.x, min.z);
            apeng.Vector2.set(out[1], max.x, min.z);
            apeng.Vector2.set(out[2], max.x, max.z);
            apeng.Vector2.set(out[3], min.x, max.z);
            return out;
        }
        octree() {
            if (this._octree == null) {
                this._octree = [];
                for (let i = 0; i < 8; i++)
                    this._octree[i] = new AABB();
            }
            return AABB.octree(this._octree, this);
        }
        getCylinder() {
            if (this._cylindreTemp == null)
                this._cylindreTemp = new apeng.Cylinder();
            return AABB.toCylinder(this, this._cylindreTemp);
        }
        getBottomPolygon() {
            if (this._getBottomPolygon == null) {
                this._getBottomPolygon = [];
                for (let i = 0; i < 4; i++)
                    this._getBottomPolygon.push(new apeng.Vector2());
            }
            return AABB.getBottomPolygon(this._getBottomPolygon, this);
        }
        getSphere() {
            if (this._sphereTemp == null)
                this._sphereTemp = new apeng.Sphere();
            return AABB.toSphere(this, this._sphereTemp);
        }
        set(center, halfExtents) { return AABB.set(this, center, halfExtents); }
        randomPosition() { return AABB.randomPosition(this._randomPosition, this); }
        min() { return AABB.min(this._min, this); }
        max() { return AABB.max(this._max, this); }
        containsAABB(other) { return AABB.containsAABB(this, other); }
        contains(point) { return AABB.contains(this, point); }
    }
    /**相交检测 */
    AABB.intersection = {
        /**
          * 形状相交
          * @param other
          */
        intersectsShape(self, other) {
            switch (self.shape) {
                case EAabbShape.box:
                    switch (other.shape) {
                        case EAabbShape.box:
                            return AABB.intersection.aabbAabb(self, other);
                        case EAabbShape.Sphere:
                            return AABB.intersection.aabbSphere(self, other.getSphere());
                        case EAabbShape.cylinder:
                            return AABB.intersection.aabbCylinder(self, other.getCylinder());
                    }
                case EAabbShape.Sphere:
                    switch (other.shape) {
                        case EAabbShape.box:
                            return AABB.intersection.aabbSphere(other, self.getSphere());
                        case EAabbShape.Sphere:
                            return AABB.intersection.sphereSphere(self.getSphere(), other.getSphere());
                        case EAabbShape.cylinder:
                            return AABB.intersection.sphereCylinder(self.getSphere(), other.getCylinder());
                    }
                case EAabbShape.cylinder:
                    switch (other.shape) {
                        case EAabbShape.box:
                            return AABB.intersection.aabbCylinder(other, self.getCylinder());
                        case EAabbShape.Sphere:
                            return AABB.intersection.sphereCylinder(self.getSphere(), other.getCylinder());
                        case EAabbShape.cylinder:
                            return AABB.intersection.cylinderCylinder(self.getCylinder(), other.getCylinder());
                    }
            }
            return false;
        },
        /**
         * 轴对齐包围盒相交
         * @param self
         * @param other
         * @returns
         */
        aabbAabb(self, other) {
            v3T.set(self.min());
            v3T2.set(self.max());
            v3T3.set(other.min());
            v3T4.set(other.max());
            return (v3T.x <= v3T4.x && v3T2.x >= v3T3.x)
                && (v3T.y <= v3T4.y && v3T2.y >= v3T3.y)
                && (v3T.z <= v3T4.z && v3T2.z >= v3T3.z);
        },
        /**
         * 轴对齐包围盒与轴对齐球相交
         * @param aabb
         * @param sphere
         * @returns
         */
        aabbSphere(aabb, sphere) {
            v3T.set(AABB.ptPointAabb(aabb, sphere.center));
            return apeng.Vector3.distanceSqr(sphere.center, v3T) <= (sphere.radius * sphere.radius);
        },
        /**
         * 轴对齐包围盒与圆柱相交
         * @param aabb
         * @param cylinder
         * @returns
         */
        aabbCylinder(aabb, cylinder) {
            cylinder.toAABB(aabbT);
            // 包围盒相交
            if (AABB.intersection.aabbAabb(aabb, aabbT))
                // 底部矩形与圆相交
                if (apeng.Polygon.polygonCircle(aabb.getBottomPolygon(), cylinder.getCircle()))
                    return true;
            return false;
        },
        /**
         * 轴对齐球与球相交
         * @param self
         * @param other
         */
        sphereSphere(self, other) {
            return apeng.Vector3.distanceSqr(self.center, other.center) <= ((self.radius + other.radius) * (self.radius + other.radius));
        },
        /**
         * 轴对齐球与轴对齐圆柱相交
         *
         *
         * 暂时使用圆柱包围盒与球相交
         * @param sphere
         * @param cylinder
         * @returns
         */
        sphereCylinder(sphere, cylinder) {
            return AABB.intersection.aabbSphere(cylinder.toAABB(aabbT), sphere);
        },
        /**
          * 轴对齐圆柱与轴对齐圆柱相交
          * @param sphere
          * @param cylinder
          * @returns
          */
        cylinderCylinder(self, other) {
            self.toAABB(aabbT);
            other.toAABB(aabbT2);
            // 包围盒相交
            if (AABB.intersection.aabbAabb(aabbT, aabbT2))
                aabbT;
            // 底部圆相交
            if (self.getCircle().intersects(other.getCircle()))
                return true;
            return false;
        },
    };
    apeng.AABB = AABB;
    const sphereT = new apeng.Sphere();
    const aabbT = new AABB();
    const aabbT2 = new AABB();
})(apeng || (apeng = {}));
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    class Collider3DOctree {
        constructor() {
            this.root = null;
            this.parent = null;
            /**当前空间的盒子 */
            this.aabb = null;
            /**子包围盒 */
            this.child = null;
            /**当前层级 */
            this.curLevel = 0;
            /**分到当前块的数据 */
            this.containData = [];
        }
        clear() {
            if (this.child)
                for (let child of this.child)
                    child.clear();
            this.root = null;
            this.parent = null;
            this.aabb = null;
            this.child = null;
            this.curLevel = 0;
            this.containData.length = 0;
        }
        /**
         * 添加一个数据
         * 会自动判断进入分块中
         * @param _item
         */
        add(item) {
            this.root.addShape(item);
            if (apeng.AABB.intersection.aabbAabb(this.aabb, item.aabb)) {
                if (this.child == null) {
                    this.containData.push(item);
                    // 分裂子节点
                    if (this.curLevel < this.root.maxLevel) {
                        this.child = [];
                        // 创建子节点
                        for (let aabb of this.aabb.octree()) {
                            let create = new Collider3DOctree();
                            create.aabb = aabb;
                            create.parent = this;
                            create.root = this.root;
                            create.curLevel = create.getLevel();
                            for (let items of this.containData)
                                create.add(items);
                            this.child.push(create);
                        }
                        this.containData.length = 0;
                    }
                    else {
                        // 根节点不添加
                        if (this.parent) {
                            item.octree.push(this);
                        }
                    }
                }
                else {
                    for (let child of this.child)
                        child.add(item);
                }
            }
        }
        /**
         * 获取当前的深度层
         * @returns
         */
        getLevel() {
            let level = 0;
            let parent = this.parent;
            while (parent) {
                parent = parent.parent;
                level++;
            }
            return level;
        }
    }
    apeng.Collider3DOctree = Collider3DOctree;
})(apeng || (apeng = {}));
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    /**
     * 八叉树
     * 将所有碰撞块放入最后一层子节点中
     */
    class Collider3DRoot extends apeng.Collider3DOctree {
        constructor() {
            super();
            /**分组控制 */
            this.group = new apeng.ColliderGroup();
            /**最大层级深度 */
            this.maxLevel = 3;
            this.ids = 0;
            this.colliders = [];
            /**动态更新位置的集合 */
            this.updateShapes = [];
            /**逻辑帧的执行次数 */
            this.cycleCount = 0;
            this._isOpen = true;
            this._updateShape = false;
            this.root = this;
        }
        /**
         * 初始化八叉树
         * 如不初始化 则使用 双层for循环
         * @param maxAABB 根包围盒，应当包含所有子块
         * @param maxLevel 子节点分层
         */
        initOctree(maxAABB, maxLevel = 3) {
            this.aabb = maxAABB;
            this.maxLevel = maxLevel;
            this.setOpen(true);
        }
        /**开启八叉树检测 */
        setOpen(isOpen) {
            this._isOpen = isOpen;
            this.cycleCount = 0;
        }
        /**添加一个数据 子类调用 */
        addShape(value) {
            if (value.id !== null)
                return;
            value.id = this.ids;
            value.root = this;
            this.ids++;
            this.colliders.push(value);
            if (value.updateShape)
                this.updateShapes.push(value);
        }
        remove(value) {
            value.clear();
        }
        onUpdate() {
            this.updateShape();
            this.cycleCount = 0;
            if (this._isOpen)
                this.octreeCollider(this.child);
            else
                this.defaultCollider();
        }
        /**
         * 更新需要动态更新aabb
         */
        updateShape() {
            if (this.updateShapes.length == 0)
                return;
            for (let item of this.updateShapes) {
                if (item.octree.length > 0) {
                    this._updateShape = item.updateShape(item.aabb);
                    if (this._updateShape && this._isOpen) {
                        item.removeFormOctreeItem();
                        this.add(item);
                    }
                }
            }
        }
        /**双层for循环碰撞 */
        defaultCollider() {
            this.cycle(this.colliders);
        }
        /**八叉树碰撞 */
        octreeCollider(childs) {
            if (childs)
                for (let child of childs) {
                    if (child.child == null)
                        this.cycle(child.containData);
                    this.octreeCollider(child.child);
                }
        }
        clear() {
            super.clear();
            for (let value of this.colliders)
                value.clear();
            this.cycleCount = 0;
            this.ids = 0;
            this.colliders.length = 0;
            this.updateShapes.length = 0;
        }
        /**校验当前块的碰撞 */
        cycle(items) {
            if (items.length < 2)
                return;
            for (let self of items) {
                if (!self)
                    continue;
                for (let other of items) {
                    if (!other)
                        continue;
                    if (self == other)
                        continue;
                    if (!self.isCollider)
                        continue;
                    if (!other.isCollider)
                        continue;
                    // 同分组 不产生碰撞
                    if (self.group == other.group)
                        continue;
                    // 是当前分组
                    if (!this.group.has(self.group, other.group))
                        continue;
                    if (apeng.AABB.intersection.intersectsShape(self.aabb, other.aabb)) {
                        self.isColliderEnter = true;
                        // 开始
                        if (self.hasEnter(other))
                            if (self.onEnter)
                                self.onEnter(self, other);
                        // 进入中
                        if (self.onUpdate)
                            self.onUpdate(self, other);
                    }
                    else {
                        self.isColliderEnter = false;
                        // 退出
                        if (self.hasExit(other))
                            if (self.onExit)
                                self.onExit(self, other);
                    }
                    this.cycleCount++;
                }
            }
        }
        /**获取添加到所有块的个数 */
        getAddItemAllCount() {
            let count = 0;
            let countCall = (childs) => {
                if (childs)
                    for (let child of childs) {
                        count += child.containData.length;
                        countCall(child.child);
                    }
            };
            countCall(this.child);
            return count;
        }
    }
    apeng.Collider3DRoot = Collider3DRoot;
})(apeng || (apeng = {}));
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    class Collider3DShape {
        constructor(center, halfExtents, shape, group, updateShape = null) {
            /**碰撞盒 */
            this.aabb = null;
            /**动态更新 */
            this.updateShape = null;
            /**是否发生碰撞 */
            this.isCollider = true;
            this.group = null;
            this.onEnter = null;
            this.onUpdate = null;
            this.onExit = null;
            this.id = null;
            this.octree = [];
            this.root = null;
            /**进入的其他碰撞id */
            this.otherCollider = [];
            /**被其他碰撞的引用 */
            this.selfCollider = [];
            this.owner = null;
            /**正在碰撞中 */
            this.isColliderEnter = false;
            this.aabb = new apeng.AABB(center, halfExtents, shape);
            this.group = group;
            this.updateShape = updateShape;
        }
        /**校验进入的是否可以发生回调 */
        hasEnter(other) {
            // 派发开始回调
            if (!apeng.Sets.has(this.otherCollider, other)) {
                this.otherCollider.push(other);
                other.selfCollider.push(this);
                return true;
            }
            return false;
        }
        /**校验退出的是否可以发生回调 */
        hasExit(other) {
            if (apeng.Sets.has(this.otherCollider, other)) {
                apeng.Sets.delete(this.otherCollider, other);
                apeng.Sets.delete(other.selfCollider, this);
                return true;
            }
            return false;
        }
        /**清空所有引用 */
        clear() {
            this.isColliderEnter = false;
            this.otherCollider.length = 0;
            this.selfCollider.length = 0;
            apeng.Sets.delete(this.root.updateShapes, this);
            apeng.Sets.delete(this.root.colliders, this);
            if (this.octree.length > 0) {
                for (let value of this.octree) {
                    apeng.Sets.delete(value.containData, this);
                }
                this.octree.length = 0;
            }
            this.id = null;
        }
        /**从树中删除当前数据 */
        removeFormOctreeItem() {
            if (this.octree.length > 0) {
                for (let value of this.octree) {
                    apeng.Sets.delete(value.containData, this);
                }
                this.octree.length = 0;
            }
        }
    }
    apeng.Collider3DShape = Collider3DShape;
})(apeng || (apeng = {}));
/// <reference path="./../../utils/Vector3.ts" />

(function (apeng) {
    /**轴对齐圆柱 */
    class Cylinder {
        constructor(center, radius, height) {
            /** 本地坐标的中心点 */
            this.center = new apeng.Vector3();
            /**半径 */
            this.radius = 0;
            /**高度 */
            this.height = 0;
            this._circle = new apeng.Circle();
            this.set(center, radius, height);
        }
        static toAABB(cylinder, out) {
            out.center.set(cylinder.center);
            out.halfExtents.set(cylinder.radius, cylinder.height / 2, cylinder.radius);
            return out;
        }
        /**获取xz的圆 */
        static getCircle(out, value) {
            return out.set(value.center.x, value.center.z, value.radius);
        }
        static set(out, center, radius, height) {
            if (center)
                apeng.Vector3.set(out.center, center);
            out.radius = radius || 0;
            out.height = height || 0;
            return out;
        }
        set(center, radius, height) { return Cylinder.set(this, center, radius, height); }
        getCircle() { return Cylinder.getCircle(this._circle, this); }
        toAABB(out) { return Cylinder.toAABB(this, out); }
    }
    apeng.Cylinder = Cylinder;
})(apeng || (apeng = {}));

(function (apeng) {
    let ETweenType;
    (function (ETweenType) {
        ETweenType[ETweenType["None"] = 0] = "None";
        ETweenType[ETweenType["Breathe"] = 1] = "Breathe";
        ETweenType[ETweenType["BreatheLinear"] = 2] = "BreatheLinear";
        /**自上到中的动画 */
        ETweenType[ETweenType["UIshow"] = 3] = "UIshow";
        ETweenType[ETweenType["TipShow"] = 4] = "TipShow";
        ETweenType[ETweenType["Rotate"] = 5] = "Rotate";
        /**从0放大到1.5 */
        ETweenType[ETweenType["ScaleZeroToMax"] = 6] = "ScaleZeroToMax";
        /**当前放大到1.2倍在缩回来 */
        ETweenType[ETweenType["ScaleTo"] = 7] = "ScaleTo";
        ETweenType[ETweenType["MoveLeftRight"] = 8] = "MoveLeftRight";
        /**轻微放大缩小 */
        ETweenType[ETweenType["ScaleTo2"] = 9] = "ScaleTo2";
        ETweenType[ETweenType["BreatheLinear2"] = 10] = "BreatheLinear2";
        /**摇晃 */
        ETweenType[ETweenType["Shake"] = 11] = "Shake";
        /**ui打开时 缩放 */
        ETweenType[ETweenType["UISHowScale"] = 12] = "UISHowScale";
        /**从上到中在回去 */
        ETweenType[ETweenType["TipShowTop"] = 13] = "TipShowTop";
        /**上下循环移动动画 */
        ETweenType[ETweenType["MoveTopDown"] = 14] = "MoveTopDown";
    })(ETweenType = apeng.ETweenType || (apeng.ETweenType = {}));
    apeng.ccenum(ETweenType);
    class TweenHelper {
        static setDefaultData(type, data) {
            this._defaultData[type] = data;
        }
        static stop(value, type) {
            if (!type)
                apeng.Tween.stopAllByTarget(value);
            else {
                let _tween = this.getTween(value, type);
                if (_tween) {
                    _tween.stop();
                    let orgin = value["_Tweens_orgin" + type];
                    if (orgin)
                        orgin();
                }
            }
            return this;
        }
        static default(node, type, cb) {
            TweenHelper.stop(node, type);
            return this.getTween(node, type, (_tween) => {
                switch (type) {
                    case ETweenType.Breathe: {
                        let v3T = node.getScale();
                        let v3T2 = v3T.clone();
                        _tween
                            .call(() => {
                            v3T2.x = v3T.x * .9;
                            v3T2.y = v3T.y * .95;
                        })
                            .to(.3, { scale: v3T2 }, { easing: "fade" })
                            .call(() => {
                            v3T2.x = v3T.x * 1.07;
                            v3T2.y = v3T.y * 1;
                        })
                            .to(.3, { scale: v3T2 }, { easing: "circInOut" })
                            .call(() => {
                            v3T2.x = v3T.x;
                            v3T2.y = v3T.y;
                        })
                            .to(.1, { scale: v3T2 })
                            .delay(1)
                            .union()
                            .repeatForever();
                        return { scale: v3T };
                    }
                    case ETweenType.BreatheLinear: {
                        let v3T = node.getScale();
                        let v3T2 = v3T.clone();
                        _tween
                            .call(() => {
                            v3T2.x = v3T.x * 1.1;
                            v3T2.y = v3T.y * 1.1;
                        })
                            .to(.8, { scale: v3T2 }, { easing: "backOut" })
                            .call(() => {
                            v3T2.x = v3T.x * 1;
                            v3T2.y = v3T.y * 1;
                        })
                            .to(.5, { scale: v3T2 })
                            .union()
                            .repeatForever();
                        return { scale: v3T };
                    }
                    case ETweenType.BreatheLinear2: {
                        let v3T = node.getScale();
                        let v3T2 = v3T.clone();
                        _tween
                            .call(() => {
                            v3T2.x = v3T.x * 1.3;
                            v3T2.y = v3T.y * 1.3;
                        })
                            .to(.8, { scale: v3T2 }, { easing: "backOut" })
                            .call(() => {
                            v3T2.x = v3T.x * 1;
                            v3T2.y = v3T.y * 1;
                        })
                            .to(.5, { scale: v3T2 })
                            .union()
                            .repeatForever();
                        return { scale: v3T };
                    }
                    case ETweenType.UIshow: {
                        let v3T = node.getPosition();
                        let v3T2 = v3T.clone();
                        _tween
                            .call(() => {
                            v3T2.y = apeng.winSize().height + apeng.NodeHelper.getUITransform(node).height;
                            node.setPosition(v3T2);
                            v3T2.y = v3T.y - 80;
                        })
                            .to(0.3, { position: v3T2 }, { easing: "quadOut" })
                            .to(0.2, { position: v3T }, { easing: "quadIn" });
                        return { position: v3T };
                    }
                    case ETweenType.TipShow: {
                        let v3T = node.getPosition();
                        let v3T2 = v3T.clone();
                        let v3T3 = v3T.clone();
                        let v3T4 = v3T.clone();
                        let v3T5 = v3T.clone();
                        _tween
                            .call(() => {
                            v3T3.x = -apeng.winSize().width - apeng.NodeHelper.getUITransform(node).width;
                            node.setPosition(v3T3);
                            v3T.x = v3T2.x + 80;
                            v3T4.x = v3T2.x - 80;
                            v3T5.x = -v3T3.x;
                        })
                            .to(0.3, { position: v3T }, { easing: "quadOut" })
                            .to(0.2, { position: v3T2 }, { easing: "quadIn" })
                            .delay(1)
                            .to(0.2, { position: v3T4 }, { easing: "quadIn" })
                            .to(0.3, { position: v3T5 }, { easing: "quadOut" })
                            .call(() => {
                            if (cb)
                                cb();
                        });
                        return { position: v3T };
                    }
                    case ETweenType.Rotate:
                        _tween
                            .by(3, { angle: -360 })
                            .union()
                            .repeatForever();
                        return { angle: 0 };
                    case ETweenType.ScaleZeroToMax:
                        let v3T = node.getScale();
                        _tween
                            .call(() => {
                            node.setScale(new apeng.Vec3(0, 0, 1));
                        })
                            .to(1, { scale: new apeng.Vec3(1.5, 1.5, 1) });
                        return { scale: v3T };
                    case ETweenType.ScaleTo: {
                        let v3T = node.getScale();
                        let v3T1 = v3T.clone();
                        _tween
                            .call(() => {
                            apeng.Vector3.mul(v3T1, v3T, 1.2);
                        })
                            .to(0.3, { scale: v3T1 }, { easing: "quadOut" })
                            .to(0.2, { scale: v3T }, { easing: "quadIn" });
                        return { scale: v3T };
                    }
                    case ETweenType.ScaleTo2: {
                        let v3T = node.getScale();
                        let v3T1 = v3T.clone();
                        _tween
                            .call(() => {
                            apeng.Vector3.mul(v3T1, v3T, 1.05);
                        })
                            .to(0.15, { scale: v3T1 }, { easing: "quadOut" })
                            .to(0.1, { scale: v3T }, { easing: "quadIn" });
                        return { scale: v3T };
                    }
                    case ETweenType.MoveLeftRight: {
                        let v3T = node.getPosition();
                        let v3T2 = v3T.clone();
                        v3T2.x -= 300;
                        let v3T3 = v3T.clone();
                        v3T3.x += 300;
                        _tween
                            .to(1, { position: v3T2 })
                            .to(1, { position: v3T3 })
                            .delay(.5)
                            .union()
                            .repeatForever();
                        return { position: v3T };
                    }
                    case ETweenType.Shake: {
                        _tween
                            .set({ angle: 0 })
                            .to(.3, { angle: -10 })
                            .to(.6, { angle: 10 })
                            .to(.3, { angle: 0 })
                            .delay(.5)
                            .union()
                            .repeatForever();
                        return { angle: 0 };
                    }
                    case ETweenType.UISHowScale: {
                        let v3T = node.getScale();
                        let v3T2 = v3T.clone().multiplyScalar(1.07);
                        let _tween2 = node["_Tweens2_" + type] = new apeng.Tween(node);
                        _tween2
                            .delay(.1)
                            // ui动画 更新 list
                            .call(() => {
                            if (cb)
                                cb("one");
                        })
                            .union();
                        _tween
                            .call(() => {
                            node.setScale(apeng.Vec3.ZERO);
                            _tween2.start();
                        })
                            .to(.25, { scale: v3T2 }, { easing: "quadOut" })
                            .to(.15, { scale: v3T }, { easing: "quadOut" })
                            .call(() => {
                            if (cb)
                                cb("two");
                        });
                        TweenHelper.UISHowScaleDuration = .4;
                        return { scale: v3T, __callTween2: () => _tween2.stop() };
                    }
                    case ETweenType.TipShowTop: {
                        let v3 = node.getPosition();
                        let v3T = v3.clone();
                        let v3T2 = v3.clone();
                        let v3T3 = v3.clone();
                        _tween
                            .call(() => {
                            v3T3.y = apeng.winSize().height + apeng.NodeHelper.getUITransform(node).height;
                            node.setPosition(v3T3);
                            v3T2.y = v3.y;
                            let data = TweenHelper._defaultData[ETweenType.TipShowTop];
                            if (data !== undefined)
                                if (typeof data === "number") {
                                    v3T2.y += data;
                                    v3T.y += data;
                                }
                            v3T.y = v3T2.y - 80;
                        })
                            .to(0.3, { position: v3T }, { easing: "quadOut" })
                            .to(0.2, { position: v3T2 }, { easing: "quadIn" })
                            .delay(1)
                            .to(0.2, { position: v3T }, { easing: "quadIn" })
                            .to(0.3, { position: v3T3 }, { easing: "quadOut" })
                            .call(() => {
                            if (cb)
                                cb();
                        });
                        return { position: v3T };
                    }
                    case ETweenType.MoveTopDown: {
                        let data = TweenHelper._defaultData[ETweenType.MoveTopDown];
                        let dis = 20;
                        let duration = .5;
                        if (data !== undefined) {
                            dis += data.dis;
                            duration += data.duration;
                        }
                        let v3 = node.getPosition();
                        let v3T = v3.clone();
                        let v3T2 = v3.clone();
                        _tween
                            .call(() => {
                            v3T.y = v3.y + dis;
                            v3T2.y = v3.y - dis;
                        })
                            .to(duration, { position: v3T })
                            .to(duration, { position: v3T2 })
                            .union()
                            .repeatForever();
                        return { position: v3 };
                    }
                }
                return null;
            }).start();
        }
        static getTween(obj, type, create) {
            let _tween = obj["_Tweens_" + type];
            if (!_tween && create) {
                _tween = obj["_Tweens_" + type] = new apeng.Tween(obj);
                let orgin = create(_tween);
                // 还原
                if (orgin)
                    obj["_Tweens_orgin" + type] = () => {
                        for (let key in orgin) {
                            let value = orgin[key];
                            if (typeof value == "function")
                                value();
                            else
                                obj[key] = value;
                        }
                    };
            }
            return _tween;
        }
        /**获取tween的持续时间 */
        static duration(_tween) {
            if (_tween) {
                let duration = 0;
                let actions = _tween._actions;
                for (let value of actions)
                    duration += value._duration;
                return duration;
            }
            return 0;
        }
        /**
         * 改变tween里第 index的tween的持续时间
         * @param _tween
         * @param index
         * @param duration
         */
        static setDuration(_tween, index, duration) {
            let actions = _tween._actions;
            let action = actions[index];
            if (action)
                action.initWithDuration(duration);
            return this;
        }
        static pause(obj) {
            apeng.TweenSystem.instance.ActionManager.pauseTarget(obj);
            return this;
        }
        static resume(obj) {
            apeng.TweenSystem.instance.ActionManager.resumeTarget(obj);
            return this;
        }
        static hasPause(obj) {
            let mgr = apeng.TweenSystem.instance.ActionManager;
            let element = mgr._hashTargets.get(obj);
            if (element)
                return element.paused;
            return false;
        }
        static hasRun(obj) {
            let count = apeng.TweenSystem.instance.ActionManager.getNumberOfRunningActionsInTarget(obj);
            return count > 0;
        }
    }
    TweenHelper.UISHowScaleDuration = .4;
    TweenHelper._defaultData = {};
    apeng.TweenHelper = TweenHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 动画曲线函数
     */
    let EEaseType;
    (function (EEaseType) {
        /**(无效)不使用 */
        EEaseType[EEaseType["none"] = 0] = "none";
        /**常数 */
        EEaseType[EEaseType["constant"] = 1] = "constant";
        /**线性 */
        EEaseType[EEaseType["linear"] = 2] = "linear";
        /**平方曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["quadIn"] = 3] = "quadIn";
        /**平方曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["quadOut"] = 4] = "quadOut";
        /**平方曲线缓入缓出函数。运动由慢到快再到慢 */
        EEaseType[EEaseType["quadInOut"] = 5] = "quadInOut";
        /**立方曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["cubicIn"] = 6] = "cubicIn";
        /**立方曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["cubicOut"] = 7] = "cubicOut";
        /**立方曲线缓入缓出函数。运动由慢到快再到慢 */
        EEaseType[EEaseType["cubicInOut"] = 8] = "cubicInOut";
        /**四次方曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["quartIn"] = 9] = "quartIn";
        /**四次方曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["quartOut"] = 10] = "quartOut";
        /**四次方曲线缓入缓出函数。运动由慢到快再到慢 */
        EEaseType[EEaseType["quartInOut"] = 11] = "quartInOut";
        /**五次方曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["quintIn"] = 12] = "quintIn";
        /**五次方曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["quintOut"] = 13] = "quintOut";
        /**五次方曲线缓入缓出函数。运动由慢到快再到慢 */
        EEaseType[EEaseType["quintInOut"] = 14] = "quintInOut";
        /**正弦曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["sineIn"] = 15] = "sineIn";
        /**正弦曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["sineOut"] = 16] = "sineOut";
        /**正弦曲线缓入缓出函数。运动由慢到快再到慢 */
        EEaseType[EEaseType["sineInOut"] = 17] = "sineInOut";
        /**指数曲线缓入函数。运动由慢到快 */
        EEaseType[EEaseType["expoIn"] = 18] = "expoIn";
        /**指数曲线缓出函数。运动由快到慢 */
        EEaseType[EEaseType["expoOut"] = 19] = "expoOut";
        /**指数曲线缓入和缓出函数。运动由慢到很快再到慢 */
        EEaseType[EEaseType["expoInOut"] = 20] = "expoInOut";
        /**循环公式缓入函数。运动由慢到快 */
        EEaseType[EEaseType["circIn"] = 21] = "circIn";
        /** 循环公式缓出函数。运动由快到慢 */
        EEaseType[EEaseType["circOut"] = 22] = "circOut";
        /**指数曲线缓入缓出函数。运动由慢到很快再到慢 */
        EEaseType[EEaseType["circInOut"] = 23] = "circInOut";
        /**弹簧回震效果的缓入函数 */
        EEaseType[EEaseType["elasticIn"] = 24] = "elasticIn";
        /**弹簧回震效果的缓出函数 */
        EEaseType[EEaseType["elasticOut"] = 25] = "elasticOut";
        /**弹簧回震效果的缓入缓出函数 */
        EEaseType[EEaseType["elasticInOut"] = 26] = "elasticInOut";
        /**回退效果的缓入函数。 */
        EEaseType[EEaseType["backIn"] = 27] = "backIn";
        /**回退效果的缓出函数。 */
        EEaseType[EEaseType["backOut"] = 28] = "backOut";
        /**回退效果的缓入缓出函数。 */
        EEaseType[EEaseType["backInOut"] = 29] = "backInOut";
        /**弹跳效果的缓入函数。 */
        EEaseType[EEaseType["bounceIn"] = 30] = "bounceIn";
        /**弹跳效果的缓出函数。 */
        EEaseType[EEaseType["bounceOut"] = 31] = "bounceOut";
        /**弹跳效果的缓入缓出函数。 */
        EEaseType[EEaseType["bounceInOut"] = 32] = "bounceInOut";
        /**平滑效果函数。 */
        EEaseType[EEaseType["smooth"] = 33] = "smooth";
        /**渐褪效果函数。 */
        EEaseType[EEaseType["fade"] = 34] = "fade";
        EEaseType[EEaseType["quadOutIn"] = 35] = "quadOutIn";
        EEaseType[EEaseType["cubicOutIn"] = 36] = "cubicOutIn";
        EEaseType[EEaseType["quartOutIn"] = 37] = "quartOutIn";
        EEaseType[EEaseType["quintOutIn"] = 38] = "quintOutIn";
        EEaseType[EEaseType["sineOutIn"] = 39] = "sineOutIn";
        EEaseType[EEaseType["expoOutIn"] = 40] = "expoOutIn";
        EEaseType[EEaseType["circOutIn"] = 41] = "circOutIn";
        EEaseType[EEaseType["backOutIn"] = 42] = "backOutIn";
        EEaseType[EEaseType["bounceOutIn"] = 43] = "bounceOutIn";
    })(EEaseType = apeng.EEaseType || (apeng.EEaseType = {}));
    apeng.ccenum(EEaseType);
    function easing(type, ratio) {
        let fn = Easeing[EEaseType[type]];
        if (fn)
            ratio = fn(ratio);
        return ratio;
    }
    apeng.easing = easing;
    const Easeing = {
        constant() { return 0; },
        linear(k) { return k; }, quadIn(k) { return k * k; },
        quadOut(k) { return k * (2 - k); },
        quadInOut(k) {
            k *= 2;
            if (k < 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        },
        cubicIn(k) { return k * k * k; },
        cubicOut(k) { return --k * k * k + 1; },
        cubicInOut(k) {
            k *= 2;
            if (k < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        },
        quartIn(k) { return k * k * k * k; },
        quartOut(k) { return 1 - (--k * k * k * k); },
        quartInOut(k) {
            k *= 2;
            if (k < 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        },
        quintIn(k) { return k * k * k * k * k; },
        quintOut(k) { return --k * k * k * k * k + 1; },
        quintInOut(k) {
            k *= 2;
            if (k < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        },
        sineIn(k) { return 1 - Math.cos(k * Math.PI / 2); },
        sineOut(k) { return Math.sin(k * Math.PI / 2); },
        sineInOut(k) { return 0.5 * (1 - Math.cos(Math.PI * k)); },
        expoIn(k) { return k === 0 ? 0 : Math.pow(1024, k - 1); },
        expoOut(k) { return k === 1 ? 1 : 1 - Math.pow(2, -10 * k); },
        expoInOut(k) {
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            k *= 2;
            if (k < 1)
                return 0.5 * Math.pow(1024, k - 1);
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        },
        circIn(k) { return 1 - Math.sqrt(1 - k * k); },
        circOut(k) { return Math.sqrt(1 - (--k * k)); },
        circInOut(k) {
            k *= 2;
            if (k < 1)
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
        elasticIn(k) {
            let s;
            let a = 0.1;
            const p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        },
        elasticOut(k) {
            let s;
            let a = 0.1;
            const p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
        },
        elasticInOut(k) {
            let s;
            let a = 0.1;
            const p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            }
            else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            k *= 2;
            if (k < 1)
                return -0.5 *
                    (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        },
        backIn(k) {
            const s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        backOut(k) {
            const s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        backInOut(k) {
            const s = 1.70158 * 1.525;
            k *= 2;
            if (k < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
        bounceIn(k) {
            return 1 - Easeing.bounceOut(1 - k);
        },
        bounceOut(k) {
            if (k < (1 / 2.75)) {
                return 7.5625 * k * k;
            }
            else if (k < (2 / 2.75)) {
                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
            }
            else if (k < (2.5 / 2.75)) {
                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
            }
            else {
                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
            }
        },
        bounceInOut(k) {
            if (k < 0.5) {
                return Easeing.bounceIn(k * 2) * 0.5;
            }
            return Easeing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
        },
        smooth(k) {
            if (k <= 0) {
                return 0;
            }
            if (k >= 1) {
                return 1;
            }
            return k * k * (3 - 2 * k);
        },
        fade(k) {
            if (k <= 0) {
                return 0;
            }
            if (k >= 1) {
                return 1;
            }
            return k * k * k * (k * (k * 6 - 15) + 10);
        },
        quadOutIn(k) { },
        cubicOutIn(k) { },
        quartOutIn(k) { },
        quintOutIn(k) { },
        sineOutIn(k) { },
        expoOutIn(k) { },
        circOutIn(k) { },
        elasticOutIn(k) { },
        backOutIn(k) { },
        bounceOutIn(k) { },
    };
    Easeing.quadOutIn = _makeOutIn(Easeing.quadIn, Easeing.quadOut);
    Easeing.cubicOutIn = _makeOutIn(Easeing.cubicIn, Easeing.cubicOut);
    Easeing.quartOutIn = _makeOutIn(Easeing.quartIn, Easeing.quartOut);
    Easeing.quintOutIn = _makeOutIn(Easeing.quintIn, Easeing.quintOut);
    Easeing.sineOutIn = _makeOutIn(Easeing.sineIn, Easeing.sineOut);
    Easeing.expoOutIn = _makeOutIn(Easeing.expoIn, Easeing.expoOut);
    Easeing.circOutIn = _makeOutIn(Easeing.circIn, Easeing.circOut);
    Easeing.backOutIn = _makeOutIn(Easeing.backIn, Easeing.backOut);
    Easeing.bounceOutIn = _makeOutIn(Easeing.bounceIn, Easeing.bounceOut);
    function _makeOutIn(fnIn, fnOut) {
        return (k) => {
            if (k < 0.5) {
                return fnOut(k * 2) / 2;
            }
            return fnIn(2 * k - 1) / 2 + 0.5;
        };
    }
})(apeng || (apeng = {}));
/// <reference path="./../helper/DirectorHelper.ts" />
/// <reference path="./../helper/TweenHelper.ts" />
/// <reference path="./BaseComponent.ts" />
/// <reference path="./../utils/Ease.ts" />

(function (apeng) {
    let AnimtorByTweenCC = class AnimtorByTweenCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "内置tween";
            this.type = apeng.ETweenType.None;
            this.isEnablePlay = true;
            this.delayPlay = -1;
            this.delayPlayByOpacityZeor = false;
        }
        onEnable() {
            super.onEnable();
            if (this.isEnablePlay)
                this.play();
        }
        onDisable() {
            this.stop();
            super.onDisable();
        }
        stop() {
            apeng.TweenHelper.stop(this.node, this.type);
        }
        play(cb) {
            if (this.ListCC)
                this.ListCC.otherAnimComplete(true);
            let _cb = cb;
            // 更新listCC
            if (this.ListCC) {
                _cb = (data) => {
                    this.ListCC.otherAnimComplete(false, data);
                    if (cb)
                        cb();
                };
            }
            if (this.delayPlay != -1) {
                if (this.delayPlayByOpacityZeor)
                    this.setOpacity(0);
                this.scheduleOnce(() => {
                    apeng.TweenHelper.default(this.node, this.type, _cb);
                    if (this.delayPlayByOpacityZeor)
                        this.setOpacity(1);
                }, this.delayPlay);
            }
            else
                apeng.TweenHelper.default(this.node, this.type, _cb);
        }
        getDuration() {
            return apeng.TweenHelper.duration(apeng.TweenHelper.getTween(this.node, this.type));
        }
    };
    __decorate([
        apeng.property({
            type: apeng.ETweenType,
            displayName: "类型",
        })
    ], AnimtorByTweenCC.prototype, "type", void 0);
    __decorate([
        apeng.property({
            displayName: "激活时执行",
            visible() { return this.type != apeng.ETweenType.None; }
        })
    ], AnimtorByTweenCC.prototype, "isEnablePlay", void 0);
    __decorate([
        apeng.property({
            displayName: "延迟执行",
            visible() { return this.isEnablePlay; }
        })
    ], AnimtorByTweenCC.prototype, "delayPlay", void 0);
    __decorate([
        apeng.property({
            displayName: "延迟时 透明度置为0 防止看起来闪现",
            visible() { return this.isEnablePlay && this.delayPlay != -1; }
        })
    ], AnimtorByTweenCC.prototype, "delayPlayByOpacityZeor", void 0);
    AnimtorByTweenCC = __decorate([
        apeng.ccclass("AnimtorByTweenCC"),
        apeng.menuAnim("AnimtorByTweenCC")
    ], AnimtorByTweenCC);
    apeng.AnimtorByTweenCC = AnimtorByTweenCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const v2T = new apeng.Vector2();
    const v2T2 = new apeng.Vector2();
    const sizeT = {
        width: 0,
        height: 0
    };
    class Rectangle {
        constructor(x, y, width, height) {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.angle = 0;
            /**获取或设置矩形的 x 和 y 坐标 */
            this._origin = new apeng.Vector2();
            /**获取或设置矩形中心点的坐标 */
            this._center = new apeng.Vector2();
            this._v2s = null;
            this._layoutOut = null;
            this._layoutXCount = null;
            this._layoutYCount = null;
            this._layoutCenter = null;
            this._quadtree = null;
            this.set(x, y, width, height);
        }
        static set(self, x, y, width, height) {
            if (x && typeof x === "object") {
                self.x = x.x;
                self.y = x.y;
                self.width = x.width || 0;
                self.height = x.height || 0;
            }
            else {
                self.x = (x || 0);
                self.y = y || 0;
                self.width = width || 0;
                self.height = height || 0;
            }
            return self;
        }
        /**由任意两个点创建一个矩形，目标矩形即是这两个点各向 x、y 轴作线所得到的矩形 */
        static fromMinMax(out, min, max) {
            const minX = Math.min(min.x, max.x);
            const minY = Math.min(min.y, max.y);
            const maxX = Math.max(min.x, max.x);
            const maxY = Math.max(min.y, max.y);
            out.x = minX;
            out.y = minY;
            out.width = maxX - minX;
            out.height = maxY - minY;
            return out;
        }
        /**xy是否在近似值内 */
        static equalsXY(self, other, range) {
            if (self.width != other.width)
                return false;
            if (self.height != other.height)
                return false;
            if (!apeng.Maths.isRange(self.x, other.x, range))
                return false;
            if (!apeng.Maths.isRange(self.y, other.y, range))
                return false;
            return true;
        }
        /**计算当前矩形与指定矩形重叠部分的矩形，将其赋值给出口矩形 */
        static intersection(out, self, other) {
            const axMin = self.x;
            const ayMin = self.y;
            const axMax = self.x + self.width;
            const ayMax = self.y + self.height;
            const bxMin = other.x;
            const byMin = other.y;
            const bxMax = other.x + other.width;
            const byMax = other.y + other.height;
            out.x = Math.max(axMin, bxMin);
            out.y = Math.max(ayMin, byMin);
            out.width = Math.min(axMax, bxMax) - out.x;
            out.height = Math.min(ayMax, byMax) - out.y;
            return out;
        }
        /**创建同时包含当前矩形和指定矩形的最小矩形，将其赋值给出口矩形 */
        static union(out, self, other) {
            const x = self.x;
            const y = self.y;
            const w = self.width;
            const h = self.height;
            const bx = other.x;
            const by = other.y;
            const bw = other.width;
            const bh = other.height;
            out.x = Math.min(x, bx);
            out.y = Math.min(y, by);
            out.width = Math.max(x + w, bx + bw) - out.x;
            out.height = Math.max(y + h, by + bh) - out.y;
            return out;
        }
        /**判断当前矩形是否包含指定矩形 */
        static containsRect(self, other) {
            return (self.x <= other.x
                && self.x + self.width >= other.x + other.width
                && self.y <= other.y
                && self.y + self.height >= other.y + other.height);
        }
        /**判断当前矩形是否包含指定的点 */
        static contains(self, point) {
            return (self.x < point.x
                && self.x + self.width > point.x
                && self.y < point.y
                && self.y + self.height > point.y);
        }
        /**判断当前矩形是否与指定矩形相交 */
        static intersects(self, other) {
            const maxax = self.x + self.width;
            const maxay = self.y + self.height;
            const maxbx = other.x + other.width;
            const maxby = other.y + other.height;
            return !(maxax < other.x || maxbx < self.x || maxay < other.y || maxby < self.y);
        }
        /**判断当前矩形是否与指定矩形相等 */
        static equals(self, other) {
            return self.x === other.x
                && self.y === other.y
                && self.width === other.width
                && self.height === other.height;
        }
        /**绕中心旋转矩形 */
        static angleCenter(out, value, angle) {
            let center = value.center;
            let size = value.size;
            let radian = apeng.Maths.toRadian(angle);
            apeng.Vector2.set(out[0], -size.width / 2, -size.height / 2);
            apeng.Vector2.set(out[1], size.width / 2, -size.height / 2);
            apeng.Vector2.set(out[2], size.width / 2, size.height / 2);
            apeng.Vector2.set(out[3], -size.width / 2, size.height / 2);
            for (let _out of out)
                _out.rotateSelf(radian).addSelf(center);
            return out;
        }
        /**根据指定的插值比率，从当前矩形到目标矩形之间做插值 */
        static lerp(out, self, to, ratio) {
            const x = self.x;
            const y = self.y;
            const w = self.width;
            const h = self.height;
            out.x = x + (to.x - x) * ratio;
            out.y = y + (to.y - y) * ratio;
            out.width = w + (to.width - w) * ratio;
            out.height = h + (to.height - h) * ratio;
            return out;
        }
        /**距中心点 缩放矩形 */
        static mul(out, value, mul) {
            v2T2.set(value.center);
            v2T.set(mul, mul);
            out.width = value.width * v2T.x;
            out.height = value.height * v2T.y;
            out.center = v2T2;
            return out;
        }
        /**从中心点 增加范围 */
        static add(out, value, addWidth, addHeight) {
            v2T2.set(value.center);
            out.width = value.width + addWidth;
            out.height = value.height + addHeight;
            out.center = v2T2;
            return out;
        }
        /**
         * 等分矩形到位置
         * @param x
         * @param y
         * @param center 排除边框点 全部居中排列
         */
        static layout(out, rectange, xCount, yCount, center) {
            for (let i = 0; i < xCount; i++) {
                if (out[i] == undefined)
                    out[i] = [];
                for (let j = 0; j < yCount; j++) {
                    if (out[i][j] == undefined)
                        out[i][j] = new apeng.Vector2();
                    Rectangle.layoutPoint(out[i][j], rectange, i, j, xCount, yCount, center);
                }
            }
            return out;
        }
        /**
         * 将 self里的一个坐标
         * 转换到 other里的坐标
         * @param out
         * @param self
         * @param other
         */
        static converPointToOther(out, point, self, other) {
            apeng.Vector2.sub(out, self.origin, other.origin);
            apeng.Vector2.add(out, out, point);
            return out;
        }
        static layoutPoint(out, rectange, i, j, xCount, yCount, center) {
            if (center) {
                out.x = rectange.x + ((i + .5) / xCount) * rectange.width;
                out.y = rectange.y + ((j + .5) / yCount) * rectange.height;
            }
            else {
                out.x = rectange.x + (i / (xCount - 1)) * rectange.width;
                out.y = rectange.y + (j / (yCount - 1)) * rectange.height;
            }
            return out;
        }
        static layoutPointByIndex(rectange, point, xCount, yCount, center) {
            if (center) {
                apeng.Vector2.sub(v2T, point, rectange.origin);
                Rectangle._layoutPointByIndex.i = Math.floor(v2T.x / (xCount - .5));
                Rectangle._layoutPointByIndex.j = Math.floor(v2T.y / (yCount - .5));
            }
            else {
            }
            return Rectangle._layoutPointByIndex;
        }
        static create(x, y, width, height) {
            return new Rectangle(x, y, width, height);
        }
        static clone(rectange) {
            return new Rectangle().set(rectange);
        }
        static polygon(out, value) {
            apeng.Vector2.set(out[0], value.xMin, value.yMin);
            apeng.Vector2.set(out[1], value.xMin, value.yMax);
            apeng.Vector2.set(out[2], value.xMax, value.yMax);
            apeng.Vector2.set(out[3], value.xMax, value.yMin);
            return out;
        }
        /**将当前包围盒分成4等分的矩形 */
        static quadtree(out, value) {
            let width = value.width / 2;
            let height = value.height / 2;
            for (let i = 0; i < 4; i++) {
                out[i].width = width;
                out[i].height = height;
            }
            // 左上角
            out[0].origin = v2T.set(value.x, value.y + height);
            // 右上角
            out[1].origin = v2T.set(value.x + width, value.y + height);
            // 左下角
            out[2].origin = v2T.set(value.x, value.y);
            // 右下角
            out[3].origin = v2T.set(value.x + width, value.y);
            return out;
        }
        get origin() {
            return this._origin.set(this.x, this.y);
        }
        set origin(value) {
            this.x = value.x;
            this.y = value.y;
        }
        get center() {
            return this._center.set(this.x + this.width / 2, this.y + this.height / 2);
        }
        set center(value) {
            this.x = value.x - this.width / 2;
            this.y = value.y - this.height / 2;
        }
        /**中心点相对于左边的距离 */
        get centerDisLeft() {
            return this.center.x - this.width / 2;
        }
        get centerDisRight() {
            return this.center.x + this.width / 2;
        }
        get centerDisTop() {
            return this.center.y + this.height / 2;
        }
        get centerDisDown() {
            return this.center.y - this.height / 2;
        }
        get yMax() {
            return this.y + this.height;
        }
        set yMax(value) {
            this.height = value - this.y;
        }
        get yMin() {
            return this.y;
        }
        set yMin(value) {
            this.height += this.y - value;
            this.y = value;
        }
        get xMax() {
            return this.x + this.width;
        }
        set xMax(value) {
            this.width = value - this.x;
        }
        get xMin() {
            return this.x;
        }
        set xMin(value) {
            this.width += this.x - value;
            this.x = value;
        }
        /**获取或设置矩形的尺寸 */
        get size() {
            sizeT.width = this.width;
            sizeT.height = this.height;
            return sizeT;
        }
        set size(value) {
            this.width = value.width;
            this.height = value.height;
        }
        get v2s() {
            if (this._v2s == null)
                this._v2s = [new apeng.Vector2(), new apeng.Vector2(), new apeng.Vector2(), new apeng.Vector2()];
            return this._v2s;
        }
        layoutSelf(xCount, yCount, center) {
            if (this._layoutOut == null)
                this._layoutOut = [];
            this._layoutXCount = xCount;
            this._layoutYCount = yCount;
            this._layoutCenter = center;
            return Rectangle.layout(this._layoutOut, this, this._layoutXCount, this._layoutYCount, this._layoutCenter);
        }
        layoutPoint(out, i, j) { return Rectangle.layoutPoint(out, this, i, j, this._layoutXCount, this._layoutYCount, this._layoutCenter); }
        layoutPointByIndex(point) { return Rectangle.layoutPointByIndex(this, point, this._layoutXCount, this._layoutYCount, this._layoutCenter); }
        polygon() { return Rectangle.polygon(this.v2s, this); }
        set(x, y, width, height) { return Rectangle.set(this, x, y, width, height); }
        lerp(out, to, ratio) { return Rectangle.lerp(out, this, to, ratio); }
        lerpSelf(to, ratio) { return Rectangle.lerp(this, this, to, ratio); }
        equals(other) { return Rectangle.equals(this, other); }
        intersects(other) { return Rectangle.intersects(this, other); }
        contains(point) { return Rectangle.contains(this, point); }
        containsRect(other) { return Rectangle.containsRect(this, other); }
        union(out, other) { return Rectangle.union(out, this, other); }
        unionSelf(other) { return Rectangle.union(this, this, other); }
        intersection(out, other) { return Rectangle.intersection(out, this, other); }
        intersectionSelf(other) { return Rectangle.intersection(this, this, other); }
        equalsXY(other, range) { return Rectangle.equalsXY(this, other, range); }
        mul(out, mul) { return Rectangle.mul(out, this, mul); }
        mulSelf(mul) { return Rectangle.mul(this, this, mul); }
        add(out, addWidth, addHeight) { return Rectangle.add(out, this, addWidth, addHeight); }
        addSelf(addWidth, addHeight) { return Rectangle.add(this, this, addWidth, addHeight); }
        layout(out, xCount, yCount, center) { return Rectangle.layout(out, this, xCount, yCount, center); }
        converPointToOther(out, point, other) { return Rectangle.converPointToOther(out, point, this, other); }
        fromMinMax(min, max) { return Rectangle.fromMinMax(this, min, max); }
        clone() { return Rectangle.clone(this); }
        angleCenter(addAngle = 0) { return this.angle != 0 ? Rectangle.angleCenter(this.v2s, this, this.angle + addAngle) : Rectangle.polygon(this.v2s, this); }
        quadtree() {
            if (this._quadtree == null) {
                this._quadtree = [];
                for (let i = 0; i < 4; i++)
                    this._quadtree[i] = new Rectangle();
            }
            return Rectangle.quadtree(this._quadtree, this);
        }
    }
    Rectangle.TEMP = new Rectangle();
    Rectangle._layoutPointByIndex = {};
    apeng.Rectangle = Rectangle;
    const rectT = new Rectangle();
})(apeng || (apeng = {}));

(function (apeng) {
    const v2T = new apeng.Vector2();
    let CreatePrefabToEditorCC = class CreatePrefabToEditorCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "创建预制体到场景";
            this.Pool = null;
            this.prefabItemByUuid = "";
            this.prefabItemDeep = null;
            this.isPool = true;
            this.isPlayAnim = false;
            this._isPreloadPrefab = true;
            this._numItems = 0;
            this._itemScale = -1;
            this._runClearItem = true;
            this._prefabItem = null;
            this.isLoadPrefab = false;
            this.loadPrefabUrl = "";
            this._renderData = {};
            /**render 接口不阻断*/
            this.isRenderItems = true;
        }
        /**item 上  itemAnimIgnore为true 不播放动画*/
        static itemAnimIgnore(item, value) {
            item["itemAnimIgnore"] = value;
        }
        set prefabItem(value) {
            if (this._prefabItem == value)
                return;
            this._prefabItem = value;
            this.onEditorUpdateData();
        }
        get prefabItem() {
            if (this.prefabItemDeep)
                return this.prefabItemDeep;
            if (this._prefabItem)
                return this._prefabItem;
            if (this.prefabItemByUuid)
                return apeng._resouces.get(this.getPrefabUuidByUrl());
            return null;
        }
        set isPreloadPrefab(value) {
            if (this._isPreloadPrefab == value)
                return;
            this._isPreloadPrefab = value;
            this.updatePreloadPrefab();
        }
        get isPreloadPrefab() { return this._isPreloadPrefab; }
        set numItems(value) {
            if (this._numItems == value)
                return;
            this._numItems = value;
            if (this.onItemCountChange)
                this.onItemCountChange();
            this.updateItem();
        }
        get numItems() { return this._numItems; }
        set runClearItem(value) {
            if (this._runClearItem == value)
                return;
            this._runClearItem = value;
        }
        get runClearItem() { return this._runClearItem; }
        set itemScale(value) {
            if (this._itemScale == value)
                return;
            this._itemScale = value;
            this.updateItem();
        }
        get itemScale() { return this._itemScale; }
        get itemOrginScale() { return this._itemScale != -1 ? this._itemScale : this.prefabItem.data.scale.x; }
        get itemOrginUITransform() { return this.prefabItem.data.getComponent(apeng.UITransform); }
        /**容器 */
        get content() { return this.node; }
        get contentUITransform() {
            if (!this.content)
                return null;
            return apeng.NodeHelper.getUITransform(this.content);
        }
        get items() { return this.content.children; }
        onEditorUpdateData() {
            this.updatePreloadPrefab();
            this.updateItem();
        }
        onEditorClearData() {
            apeng.Sets.forEach(this.content.children, node => {
                node.removeFromParent();
                node.destroy();
            }, true);
        }
        onPreLoad() {
            this.node.layer = this.node.parent.layer;
            if (apeng.EDITOR) {
                this.updateItem();
                this.updatePreloadPrefab();
            }
            else {
                if (this.isPool)
                    this.Pool = new apeng.PoolOnce(1000, this.createNode.bind(this), (data) => data.removeFromParent(), (data) => data.destroy());
                if (!this._runClearItem)
                    this.updateItem();
                else
                    this._numItems = 0;
            }
        }
        onEnable() {
            super.onEnable();
            if (!apeng.EDITOR)
                if (this.isPlayAnim) {
                    this.clearAnim();
                    this.scheduleOnceCover(this.playItemAnim, 0);
                }
        }
        onDisable() {
            if (!apeng.EDITOR)
                if (this.isPlayAnim) {
                    this.clearAnim(this.itemOrginScale);
                }
            super.onDisable();
        }
        onDestroy() {
            if (this.Pool)
                this.Pool.clear();
            super.onDestroy();
        }
        clearAnim(scale = 0) {
            let i = -1;
            for (let item of this.items) {
                i++;
                apeng.TweenHelper.stop(item, "itemsAnim");
                apeng.NodeHelper.setScaleNum(item, scale, false);
            }
        }
        forEach(comp, cb) {
            apeng.NodeHelper.getChildrenByComponents(this.content, comp, cb);
        }
        createNode() {
            let node = apeng.instantiate(this.prefabItem);
            apeng.NodeHelper.setHideFlags(node, apeng.CCObject.Flags.HideInHierarchy, apeng.CCObject.Flags.DontSave);
            return node;
        }
        updatePreloadPrefab() {
            if (this._isPreloadPrefab)
                this.prefabItemDeep = this.prefabItem;
            else
                this.prefabItemDeep = null;
            this.prefabItemByUuid = this.prefabItem ? this.prefabItem._uuid : "";
        }
        preloadPrefab(url, updateItem = false, complete) {
            /**加载引用的预制体 */
            if (url && url != this.loadPrefabUrl) {
                this._prefabItem = null;
                this.isLoadPrefab = false;
                this.loadPrefabUrl = "";
            }
            if (!this.isVisible) {
                if (complete)
                    complete(false);
                return;
            }
            if (this._isPreloadPrefab || this.isLoadPrefab) {
                if (updateItem) {
                    this.removeItem();
                    this.addItem();
                }
                if (complete)
                    complete(true);
                return;
            }
            if (!url)
                url = this.getPrefabUuidByUrl();
            apeng._resouces.loadPrefab(url, (res) => {
                this._prefabItem = res;
                this.isLoadPrefab = true;
                this.loadPrefabUrl = url;
                if (!this.isVisible) {
                    if (complete)
                        complete(false);
                    return;
                }
                if (updateItem) {
                    this.removeItem();
                    this.addItem();
                }
                if (complete)
                    complete(true);
            });
        }
        getPrefabUuidByUrl() { return apeng._resouces.getUuidByUrl(this.prefabItemByUuid); }
        updateItem() {
            if (!this.prefabItem)
                return;
            if (this.LayoutCC) {
                this.LayoutCC.numItems = this._numItems;
                if (this.LayoutCC.itemByPosition.length == 0)
                    this.LayoutCC.updateView();
            }
            apeng.Sets.updateItemCount(this._numItems, this.content.children.length, (add) => {
                if (add)
                    this.addItem();
                else
                    this.removeItem();
            });
            if (this.LayoutCC)
                this.LayoutCC.updateItemPosition();
            if (this._itemScale != -1)
                apeng.Sets.forEach(this.items, item => {
                    apeng.NodeHelper.setScaleNum(item, this._itemScale, false);
                });
            if (this.onUpdateItem)
                this.onUpdateItem();
        }
        /**
         * 初始化子节点并循环
         * @param datas
         * @param comp 当前或子节点第一个匹配的组件
         * @param render
         * @param sort 数据排序 返回值越大在越前面
         * @param sortChangDatas 改变原数组数据
         */
        render(datas, comp, render, sort, sortChangDatas = false) {
            if (!this.isRenderItems && this.isPlayAnim) {
                this._renderData.datas = datas;
                this._renderData.comp = comp;
                this._renderData.render = render;
                this._renderData.sort = sort;
                this._renderData.sortChangDatas = sortChangDatas;
                return;
            }
            if (!apeng.EDITOR)
                if (this.onRenderBefore)
                    this.onRenderBefore();
            let isNumber = typeof datas == "number";
            let indexs = null;
            if (!isNumber && sort) {
                if (sortChangDatas)
                    apeng.Sets.sortMax(datas, sort);
                else {
                    indexs = [];
                    for (let i = 0; i < datas.length; i++)
                        indexs.push(i);
                    apeng.Sets.sortMax(indexs, (a) => sort(datas[a]));
                }
            }
            this.numItems = (isNumber ? datas : datas.length);
            for (let items = this.items, i = 0; i < items.length; i++) {
                let item = items[i].getComponent(comp);
                if (!item)
                    item = items[i].getComponentInChildren(comp);
                let index = i;
                if (indexs)
                    index = indexs[i];
                if (comp instanceof apeng.BaseComponent)
                    comp.autoMember();
                if (render(item, isNumber ? null : datas[index], i, index))
                    break;
            }
            if (!apeng.EDITOR) {
                if (this.isPlayAnim) {
                    this.clearAnim();
                    this.scheduleOnceCover(this.playItemAnim, 0);
                }
                if (this.onRenderComplete)
                    this.onRenderComplete();
            }
        }
        addItem(item) {
            if (!item) {
                item = this.isPool && this.Pool ? this.Pool.get() : this.createNode();
                // 主动赋值 避免延迟加载时未赋值
                item.layer = this.node.layer;
                apeng.NodeHelper.walkAllChild(item, (node) => {
                    node.layer = this.node.layer;
                    let comp = node.getComponent("BaseComponent");
                    if (comp)
                        comp.autoMember();
                });
            }
            if (!apeng.EDITOR)
                if (this.isPlayAnim)
                    apeng.NodeHelper.setScaleNum(item, 0, false);
            this.onAddItem(item);
            return item;
        }
        removeItem(item, destroy = true) {
            if (!this.prefabItem)
                return null;
            if (!item)
                item = this.items[this.items.length - 1];
            if (item) {
                if (this.isPool && this.Pool)
                    this.Pool.put(item);
                else {
                    item.removeFromParent();
                    if (destroy)
                        item.destroy();
                }
            }
            this._numItems = this.items.length;
        }
        playItemAnim() {
            let items = this.items;
            if (items.length == 0)
                return;
            // 默认缩放动画
            let isScale = this.hasPlayScaleAnim();
            let scale = this.itemOrginScale;
            let animIndex = 0;
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (!item["itemAnimIgnore"] && item.active) {
                    let tween = apeng.TweenHelper.getTween(item, "itemsAnim", (_tween) => {
                        if (isScale) {
                            let v3T = new apeng.Vec3(scale, scale, 1);
                            _tween
                                .delay(i * .03)
                                .to(.3, { scale: v3T }, { easing: "circOut" });
                            return { scale: v3T };
                        }
                        // 列表动画
                        else {
                            let comp = null;
                            if (!item.getComponent(apeng.UIRenderer))
                                if (!item.getComponent(apeng.UIOpacity))
                                    item.addComponent(apeng.UIOpacity);
                            comp = item.getComponent("RenderOpacityAnimCC");
                            if (!comp)
                                comp = item.addComponent("RenderOpacityAnimCC");
                            if (comp) {
                                comp.showEaseType = apeng.EEaseType.linear;
                                comp.speed = 1;
                            }
                            let height = apeng.NodeHelper.getUITransform(item).height;
                            let curPos = new apeng.Vec3();
                            let middlePos = new apeng.Vec3();
                            let startPos = new apeng.Vec3();
                            _tween
                                .call(() => {
                                apeng.Vector2.set(curPos, this.LayoutCC.getItemPosition(i, false));
                                apeng.Vector2.set(middlePos, curPos.x, curPos.y + height * .05);
                                apeng.Vector2.set(startPos, curPos.x, curPos.y - height * 1.8 - i * (height * .25));
                                if (comp)
                                    comp.setOpacity(0);
                                apeng.NodeHelper.setPositionXY(item, startPos, false);
                            })
                                .delay((i + 1) * .1)
                                .call(() => {
                                apeng.NodeHelper.setScaleNum(item, scale, false);
                                if (comp)
                                    comp.play(true);
                            })
                                .to(.3, { position: middlePos }, { easing: "sineOut" })
                                .to(.1, { position: curPos }, { easing: "sineOut" })
                                .call(() => {
                                if (comp)
                                    comp.play(true, null, false);
                            });
                            return { position: curPos };
                        }
                    });
                    if (isScale)
                        apeng.TweenHelper.setDuration(tween, 0, animIndex * .03);
                    else
                        apeng.TweenHelper.setDuration(tween, 1, (animIndex + 1) * .1);
                    tween.start();
                    animIndex++;
                }
                else {
                    apeng.NodeHelper.setScaleNum(item, scale, false);
                }
            }
        }
        hasPlayScaleAnim() {
            if (this.LayoutCC && this.LayoutCC.type == apeng.ELayoutType.Vertical && this.LayoutCC.verticalDirection == apeng.EVerticalDirection.TopToBottom)
                return false;
            return true;
        }
        /**创建item 添加到节点前时 */
        onAddItem(item) {
            this.content.addChild(item);
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Prefab,
            displayName: "子预制体"
        })
    ], CreatePrefabToEditorCC.prototype, "prefabItem", null);
    __decorate([
        apeng.property({
            displayName: "绑定加载预制体",
            visible() { return !!this._prefabItem; },
        })
    ], CreatePrefabToEditorCC.prototype, "isPreloadPrefab", null);
    __decorate([
        apeng.property({
            // readonly: true,
            displayName: "预制体uuid",
        })
    ], CreatePrefabToEditorCC.prototype, "prefabItemByUuid", void 0);
    __decorate([
        apeng.property({
            // readonly: true,
            type: apeng.Prefab,
            displayName: "引用预制体 方便绑定加载",
            visible() { return true; },
        })
    ], CreatePrefabToEditorCC.prototype, "prefabItemDeep", void 0);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "当前个数"
        })
    ], CreatePrefabToEditorCC.prototype, "numItems", null);
    __decorate([
        apeng.property({
            displayName: "运行时清空"
        })
    ], CreatePrefabToEditorCC.prototype, "runClearItem", null);
    __decorate([
        apeng.property({
            displayName: "使用对象池"
        })
    ], CreatePrefabToEditorCC.prototype, "isPool", void 0);
    __decorate([
        apeng.property({
            displayName: "播放动画",
            tooltip: "layoutCC 为 Vertical && TopToBottom 播放 从下往上动画"
        })
    ], CreatePrefabToEditorCC.prototype, "isPlayAnim", void 0);
    __decorate([
        apeng.property({
            displayName: "item缩放"
        })
    ], CreatePrefabToEditorCC.prototype, "itemScale", null);
    __decorate([
        apeng.property({ serializable: true })
    ], CreatePrefabToEditorCC.prototype, "_isPreloadPrefab", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], CreatePrefabToEditorCC.prototype, "_numItems", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], CreatePrefabToEditorCC.prototype, "_itemScale", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], CreatePrefabToEditorCC.prototype, "_runClearItem", void 0);
    __decorate([
        apeng.property({ serializable: true, editorOnly: true })
    ], CreatePrefabToEditorCC.prototype, "_prefabItem", void 0);
    CreatePrefabToEditorCC = __decorate([
        apeng.ccclass("CreatePrefabToEditorCC"),
        apeng.executeInEditMode,
        apeng.menuUI("CreatePrefabToEditorCC")
    ], CreatePrefabToEditorCC);
    apeng.CreatePrefabToEditorCC = CreatePrefabToEditorCC;
})(apeng || (apeng = {}));

(function (apeng) {
    class Draw {
        constructor(key) {
            this.key = key;
            this.nodes = [];
            this.localOpacitys = [];
            this.childrens = [];
            this.next = null;
            this.prev = null;
        }
    }
    class ListCCByRenderQueue {
        constructor() {
            this.items = {};
            this.head = null;
        }
        set(prev, data) {
            this.items[data.key] = data;
            if (!this.head)
                this.head = data;
            else {
                data.next = prev.next;
                prev.next = data;
                data.prev = prev;
            }
        }
        clear() {
            // Object.keys(this.items).forEach(key => {
            //     delete this.items[key]
            // })
            this.head = null;
            this.items = {};
        }
    }
    apeng.ListCCByRenderQueue = ListCCByRenderQueue;
    class _ListCCByRender {
        constructor() {
            this.enable = true;
            this.lists = [];
            this.queues = [];
        }
        init() {
            apeng.director.on(apeng.Director.EVENT_BEFORE_DRAW, (dt) => {
                for (let i = 0; i < this.lists.length; i++) {
                    let list = this.lists[i];
                    if (list.isVisible)
                        this.start(list, this.queues[i]);
                }
            });
            apeng.director.on(apeng.Director.EVENT_AFTER_DRAW, (dt) => {
                for (let i = 0; i < this.lists.length; i++) {
                    let list = this.lists[i];
                    if (list.isVisible)
                        this.end(list, this.queues[i]);
                }
                this.lists.length = 0;
                this.queues.length = 0;
            });
        }
        lateUpdate(list) {
            if (!this.enable)
                return;
            this.lists.push(list);
            this.queues.push(list.renderQueue);
        }
        render(prev, node, nodeIndex, orginParentKey, queue, active, level, opacity = 1) {
            const uiProps = node._uiProps;
            const render = uiProps.uiComp;
            opacity = opacity * uiProps.localOpacity;
            let parentKey = orginParentKey;
            if (render) {
                parentKey = orginParentKey + "+" + level + "-" + nodeIndex;
                if (level == 0)
                    parentKey = "t";
                let draw = queue.items[parentKey];
                if (!draw) {
                    draw = new Draw(parentKey);
                    queue.set(prev, draw);
                }
                prev = draw;
                let nodes = draw.nodes;
                let localOpacitys = draw.localOpacitys;
                let selfOpacity = render.color ? render.color.a / 255 : 1;
                if (active) {
                    nodes.push(node);
                    localOpacitys.push(uiProps.localOpacity);
                    uiProps.localOpacity = opacity;
                }
                opacity = opacity * selfOpacity;
            }
            let childs = node.children;
            for (let i = 0; i < childs.length; i++) {
                let isActive = childs[i].active ? active : false;
                prev = this.render(prev, childs[i], i, parentKey, queue, isActive, level + 1, opacity);
            }
            return prev;
        }
        start(list, queue) {
            let items = list.content.children;
            for (let i = 0; i < items.length; i++) {
                let node = items[i];
                if (node.parent && node.activeInHierarchy) {
                    if (!list.intersectsRectItem(i))
                        continue;
                    this.render(null, node, i, "", queue, true, 0);
                }
            }
            list.orginChilds = list.content['_children'];
            let childs = list.content['_children'] = [];
            let curr = queue.head;
            while (curr) {
                let nodes = curr.nodes;
                let childrens = curr.childrens;
                for (let i = 0; i < nodes.length; i++) {
                    childrens[i] = nodes[i]['_children'];
                    nodes[i]['_children'] = [];
                }
                childs.push(...nodes);
                curr = curr.next;
            }
        }
        end(list, queue) {
            list.content['_children'].length = 0;
            list.content['_children'] = list.orginChilds;
            //恢复原来节点结构
            let curr = queue.head;
            while (curr) {
                let nodes = curr.nodes;
                let childrens = curr.childrens;
                let localOpacitys = curr.localOpacitys;
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i]['_children'] = childrens[i];
                    let uiProps = nodes[i]._uiProps;
                    uiProps.localOpacity = localOpacitys[i];
                }
                childrens.length = 0;
                nodes.length = 0;
                curr = curr.next;
            }
            queue.clear();
        }
    }
    apeng.ListCCByRender = new _ListCCByRender();
    class _ListCCByRender2 {
        constructor() {
            this.enable = true;
            this.parents = [];
            this.queues = [];
        }
        init() {
            apeng.director.on(apeng.Director.EVENT_BEFORE_DRAW, (dt) => {
                for (let i = 0; i < this.parents.length; i++) {
                    let parent = this.parents[i];
                    if (parent.active && parent.activeInHierarchy)
                        this.start(parent, this.queues[i]);
                }
            });
            apeng.director.on(apeng.Director.EVENT_AFTER_DRAW, (dt) => {
                for (let i = 0; i < this.parents.length; i++) {
                    let parent = this.parents[i];
                    if (parent.active && parent.activeInHierarchy)
                        this.end(parent, this.queues[i]);
                }
                this.parents.length = 0;
                this.queues.length = 0;
            });
        }
        lateUpdate(parent, queue) {
            if (!this.enable)
                return;
            this.parents.push(parent);
            this.queues.push(queue);
        }
        render(prev, node, nodeIndex, orginParentKey, queue, active, level) {
            let parentKey = orginParentKey;
            parentKey = orginParentKey + "+" + level + "-" + nodeIndex;
            if (level == 0)
                parentKey = "t";
            let draw = queue.items[parentKey];
            if (!draw) {
                draw = new Draw(parentKey);
                queue.set(prev, draw);
            }
            prev = draw;
            let nodes = draw.nodes;
            if (active) {
                nodes.push(node);
            }
            let childs = node.children;
            for (let i = 0; i < childs.length; i++) {
                let isActive = childs[i].active ? active : false;
                prev = this.render(prev, childs[i], i, parentKey, queue, isActive, level + 1);
            }
            return prev;
        }
        start(parent, queue) {
            let items = parent.children;
            for (let i = 0; i < items.length; i++) {
                let node = items[i];
                if (node.parent && node.activeInHierarchy) {
                    this.render(null, node, i, "", queue, true, 0);
                }
            }
            parent.orginChilds = parent['_children'];
            let childs = parent['_children'] = [];
            let curr = queue.head;
            while (curr) {
                let nodes = curr.nodes;
                let childrens = curr.childrens;
                for (let i = 0; i < nodes.length; i++) {
                    childrens[i] = nodes[i]['_children'];
                    nodes[i]['_children'] = [];
                }
                childs.push(...nodes);
                curr = curr.next;
            }
        }
        end(parent, queue) {
            parent['_children'].length = 0;
            parent['_children'] = parent.orginChilds;
            //恢复原来节点结构
            let curr = queue.head;
            while (curr) {
                let nodes = curr.nodes;
                let childrens = curr.childrens;
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i]['_children'] = childrens[i];
                }
                childrens.length = 0;
                nodes.length = 0;
                curr = curr.next;
            }
            queue.clear();
        }
    }
    apeng.ListCCByRender2 = new _ListCCByRender2();
    apeng.moduleMgr.once(apeng.moduleMgr.EventType.INSTANCE, () => {
        apeng.ListCCByRender.init();
        apeng.ListCCByRender2.init();
    });
})(apeng || (apeng = {}));
/// <reference path="./../utils/Rectangle.ts" />
/// <reference path="./CreatePrefabToEditorCC.ts" />
/// <reference path="./ListCCByRender.ts" />

(function (apeng) {
    /**
     * 列表组件(分帧加载，渲染优化)
     */
    const rectangleT = new apeng.Rectangle();
    const colorT = new apeng.Color();
    let ListCC = class ListCC extends apeng.CreatePrefabToEditorCC {
        constructor() {
            super(...arguments);
            this.EventType = {
                ADD_ITEM: "ADD_ITEM",
                RENDER_DELAY: "RENDER_DELAY",
            };
            this.backupDescribe = "列表";
            this.removeRender = true;
            this.removeRenderByResetSort = true;
            this.uiAnimCheck = true;
            this.isClickMove = false;
            this.btnMoveTop = null;
            this.btnMoveBottom = null;
            this.btnMoveLeft = null;
            this.btnMoveRight = null;
            this.borderHideBtn = true;
            this.maxCountEnableDrag = 0;
            this.renderBoxScale = new apeng.Vec2(1, 1);
            this.resoucesDelay = false;
            this._intervalAddCount = 10;
            this._intervalAddTime = 0;
            this.rectangle = new apeng.Rectangle();
            this._delayItems = [];
            this._items = [];
            this.contentOrginPosition = new apeng.Vec3();
            this._onRenderComplete = false;
            this.orginChilds = null;
            this.renderQueue = new apeng.ListCCByRenderQueue();
            this.loadQueueResouces = null;
            this.isLoadQueueResouces = false;
            /**渲染过后 拖拽过 */
            this.isDragScrolling = false;
            this.dragScrollContentY = -1;
            this.onPositionChange = this.updateRect;
            this.onSizeChange = this.updateRect;
        }
        /**item在显示当中 */
        itemShow(item) {
            return item["_intersectsRectItem_"];
        }
        set intervalAddTime(value) {
            if (this._intervalAddTime == value)
                return;
            this._intervalAddTime = value;
        }
        get intervalAddTime() { return this._intervalAddTime; }
        set intervalAddCount(value) {
            if (this._intervalAddCount == value)
                return;
            this._intervalAddCount = value;
        }
        get intervalAddCount() { return this._intervalAddCount; }
        /**容器 */
        get content() {
            return this.getChildByCreate("content", (node) => {
                node.addComponent("LayoutCC");
                node.addComponent(apeng.Widget);
            }, -1, true);
        }
        get items() {
            // 应包含延迟队列的item
            if (this._intervalAddTime == 0)
                return this.content.children;
            else {
                this._items.length = 0;
                this._items.push(...this.content.children);
                this._items.push(...this._delayItems);
                return this._items;
            }
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                let scroll = this.node.getComponent(apeng.ScrollView);
                if (!scroll) {
                    scroll = this.node.addComponent(apeng.ScrollView);
                    scroll.horizontal = false;
                    scroll.vertical = true;
                    scroll.inertia = true;
                    scroll.brake = .75;
                    scroll.elastic = true;
                    scroll.bounceDuration = .23;
                    scroll.content = this.content;
                    scroll.cancelInnerEvents = true;
                }
                let mask = this.node.getComponent(apeng.Mask);
                if (!mask) {
                    mask = this.node.addComponent(apeng.Mask);
                    mask.inverted = false;
                    mask.type = apeng.Mask.Type.GRAPHICS_RECT;
                }
                return;
            }
            this.addEvent(apeng.ScrollView.EventType.SCROLLING, this.onEventScrolling, this, this.node);
            if (this.Layout)
                this.addEvent(apeng.Node.EventType.SIZE_CHANGED, () => this.setVisibleByRectangeListView(false), this, this.Layout.node);
            if (this.btnMoveTop) {
                apeng.EventHandlerCC.onClick(this.btnMoveTop, () => {
                    if (this.node.active && this.enabled)
                        this.ScrollView.scrollToTop(1, true);
                }, this);
                this.btnMoveTop.active = false;
            }
            if (this.btnMoveBottom) {
                apeng.EventHandlerCC.onClick(this.btnMoveBottom, () => {
                    if (this.node.active && this.enabled)
                        this.ScrollView.scrollToBottom(1, true);
                }, this);
                this.btnMoveBottom.active = false;
            }
            if (this.btnMoveLeft) {
                apeng.EventHandlerCC.onClick(this.btnMoveLeft, () => {
                    if (this.node.active && this.enabled)
                        this.ScrollView.scrollToLeft(1, true);
                }, this);
                this.btnMoveLeft.active = false;
            }
            if (this.btnMoveRight) {
                apeng.EventHandlerCC.onClick(this.btnMoveRight, () => {
                    if (this.node.active && this.enabled)
                        this.ScrollView.scrollToRight(1, true);
                }, this);
                this.btnMoveRight.active = false;
            }
            this.updateRect();
            this.scheduleOnceCover(this.updateRect, 0);
            this.content.getPosition(this.contentOrginPosition);
            if (this.ScrollBar) {
                if (this.ScrollView.vertical)
                    this.ScrollView.verticalScrollBar = this.ScrollBar;
                if (this.ScrollView.horizontal)
                    this.ScrollView.horizontalScrollBar = this.ScrollBar;
            }
            this.isLoadQueueResouces = !!this.prefabItem.data.getComponent("ListCCByBaseItemCC");
        }
        onEnable() {
            super.onEnable();
            this.updateItem();
            this.setVisibleByRectangeListView(false);
            this.updateScrollBar();
            this.isDragScrolling = false;
            this.dragScrollContentY = this.content.position.y;
        }
        onDisable() {
            this.clearLoadResoucesQueue();
            let _num = this._numItems;
            this.clearAll();
            this._numItems = _num;
            super.onDisable();
        }
        lateUpdate(dt) {
            if (this.removeRender)
                if (this.removeRenderByResetSort)
                    apeng.ListCCByRender.lateUpdate(this);
        }
        updateRect() {
            this.getRectangle(this.rectangle, true, true);
            this.rectangle.mulSelf(this.renderBoxScale);
            this.setVisibleByRectangeListView(false);
        }
        /**其他组件播放动画 延迟更新list */
        otherAnimComplete(start, data) {
            if (!this.isPlayAnim)
                return;
            if (!this.uiAnimCheck) {
                if (data == "two") {
                    this.updateRect();
                }
                return;
            }
            if (start) {
                this.isRenderItems = false;
                this.numItems = 0;
            }
            else {
                // tween 动画派发过来
                if (data == "one") {
                    this.updateRect();
                    // 开启动画
                    this.isRenderItems = true;
                    this.render(this._renderData.datas, this._renderData.comp, this._renderData.render, this._renderData.sort, this._renderData.sortChangDatas);
                    this.node.emit(this.EventType.RENDER_DELAY);
                }
                else if (data == "two") {
                    this.updateRect();
                    this.updateScrollBar();
                    this.scheduleOnceCover(this.setVisibleByRectangeListView, .1);
                }
            }
        }
        updateScrollBar() {
            if (this.ScrollBar) {
                let sp = this.ScrollBar.getComponent(apeng.Sprite);
                if (sp) {
                    colorT.set(sp.color);
                    colorT.a = 255;
                    sp.color = colorT;
                }
                this.ScrollBar._opacity = 255;
                this.ScrollBar.onScroll(apeng.Vec2.ZERO);
                //@ts-ignore
                this.ScrollView._updateScrollBarState();
            }
        }
        clearAll() {
            if (apeng._timer) {
                apeng._timer.deleteDirtyMark("setVisibleByRectangeListView");
                apeng._timer.clearAll(this);
            }
            apeng.Sets.forEach(this._delayItems, (item) => {
                this.removeItem(item);
            }, true);
            apeng.Sets.forEach(this.items, (item) => {
                this.removeItem(item);
            }, true);
            this._delayItems.length = 0;
        }
        onUpdateItem() {
            if (this._numItems > this.maxCountEnableDrag)
                this.ScrollView.enabled = true;
            else {
                this.ScrollView.enabled = false;
                this.content.setPosition(this.contentOrginPosition);
            }
            this.setVisibleByRectangeListView(false);
            this.updateScrollBar();
        }
        onAddItem(item) {
            let _item = item;
            _item["_intersectsRectItem_"] = false;
            if (!apeng.EDITOR && this._intervalAddTime != 0) {
                this._delayItems.push(item);
                apeng._timer.loop(this, this._delayAddItem, this._intervalAddTime, -1);
            }
            else
                this.addItemToScene(item);
        }
        _delayAddItem() {
            if (!this.isVisible) {
                this.clearAll();
                return;
            }
            let values = this._delayItems.splice(0, this._intervalAddCount);
            if (values.length == 0) {
                console.log("delay addItem complete");
                apeng._timer.clear(this, this._delayAddItem);
            }
            else
                for (let item of values)
                    this.addItemToScene(item);
        }
        addItemToScene(item) {
            let index = this.items.length;
            this.content.addChild(item);
            if (this.LayoutCC)
                this.LayoutCC.updateItemPosition(index);
            this.setVisibleByRectangeListView(true, index);
            this.node.emit(this.EventType.ADD_ITEM, item);
        }
        onEventScrolling() {
            this.setVisibleByRectangeListView(true);
            if (Math.abs(this.dragScrollContentY - this.content.position.y) > 3)
                this.isDragScrolling = true;
        }
        updateClickBtnMove(ratio = 4) {
            if (!this.borderHideBtn || !this.isVisible)
                return;
            let offset = this.ScrollView.getScrollOffset();
            let y = offset.y;
            let x = offset.x;
            if (this.btnMoveTop)
                this.btnMoveTop.active = y >= ratio;
            if (this.btnMoveBottom)
                this.btnMoveBottom.active = (this.getYMax(true) - apeng.NodeHelper.getYMax(this.content, true)) < -ratio;
            if (this.btnMoveLeft)
                this.btnMoveLeft.active = x < ratio;
            if (this.btnMoveRight)
                this.btnMoveRight.active = (this.getXMax(true) - apeng.NodeHelper.getXMax(this.content, true)) < -ratio;
        }
        setVisibleByRectangeListView(dirty, index = -1) {
            if (apeng.EDITOR)
                return;
            if (!dirty || apeng._timer.dirtyMark("setVisibleByRectangeListView")) {
                this.updateClickBtnMove();
                if (!this.removeRender)
                    return;
                if (!this.removeRenderByResetSort)
                    if (index == -1)
                        for (let i = 0, items = this.items; i <= items.length; i++)
                            this.setVisibleItem(i);
                    else
                        this.setVisibleItem(index);
            }
        }
        setVisibleItem(index) {
            if (!this.removeRender)
                return;
            if (this.removeRenderByResetSort)
                return;
            let item = this.items[index];
            if (item && item.parent) {
                let active = this.intersectsRectItem(index);
                if (this.LayoutCC)
                    item.active = active;
                else {
                    if (this.Layout)
                        this.setItemVisible(item, active);
                }
            }
        }
        setItemVisible(item, visible) {
            if (!this.removeRender)
                return;
            if (this.removeRenderByResetSort)
                return;
            let comp = item.getComponentInChildren(apeng.ListCCByLayoutItemRenderCC);
            if (comp) {
                comp.node.active = visible;
            }
            else {
                apeng.NodeHelper.setOpacity(item, visible ? 1 : 0);
                let fn = (node) => {
                    let comp = node.getComponent(apeng.UIRenderer);
                    if (comp)
                        comp.enabled = visible;
                };
                fn(item);
                apeng.NodeHelper.walkAllDeepChild(item, fn);
            }
        }
        onRenderComplete() {
            this.scheduleOnceCover(this.setVisibleByRectangeListView, .1);
            if (!this._onRenderComplete)
                if (this.isLoadQueueResouces) {
                    let delay = .12;
                    if (this.resoucesDelay)
                        delay = apeng.TweenHelper.UISHowScaleDuration + .01;
                    this.scheduleOnceCover(this.onDelayRenderComplete, delay);
                }
        }
        renderComplete() {
            this.unschedule(this.onDelayRenderComplete);
            this.onDelayRenderComplete();
        }
        onDelayRenderComplete() {
            if (!this.loadQueueResouces)
                return;
            this.dragScrollContentY = this.content.position.y;
            this.isDragScrolling = false;
            this._onRenderComplete = true;
            // 相交回调
            let items = this.items;
            for (let i = 0; i < items.length; i++) {
                let _item = items[i];
                this.loadQueueResouces.add((complete) => {
                    let comp = _item.getComponent("ListCCByBaseItemCC");
                    comp.listInit();
                    complete();
                });
                this.checkLoadResouces(i);
            }
            this.loadQueueResouces.run();
        }
        onRenderBefore() {
            this.dragScrollContentY = this.content.position.y;
            this.isDragScrolling = false;
            this._onRenderComplete = false;
            if (this.isLoadQueueResouces) {
                this.clearLoadResoucesQueue();
                this.loadQueueResouces = apeng.Queue.pool.get();
                this.loadQueueResouces.interval = 2;
                this.loadQueueResouces.complete = this.clearLoadResoucesQueue.bind(this);
            }
        }
        clearLoadResoucesQueue() {
            this.unschedule(this.onDelayRenderComplete);
            if (this.loadQueueResouces) {
                apeng.Queue.pool.put(this.loadQueueResouces);
                this.loadQueueResouces = null;
            }
        }
        checkLoadResouces(index) {
            if (!this._onRenderComplete)
                return false;
            if (!this.isLoadQueueResouces)
                return false;
            let _item = this.items[index];
            if (_item["_intersectsRectItem_"]) {
                if (this.loadQueueResouces && this.loadQueueResouces.has(index)) {
                    this.loadQueueResouces.runIndex(index);
                    return true;
                }
            }
            return false;
        }
        intersectsRectItem(index) {
            let item = this.items[index];
            if (this.LayoutCC) {
                this.LayoutCC.getItemRectange(rectangleT, index, true);
            }
            else {
                if (this.Layout)
                    apeng.NodeHelper.getRectangle(rectangleT, item, true, false);
            }
            let _item = item;
            let value = _item["_intersectsRectItem_"] = rectangleT.intersects(this.rectangle);
            if (!this._onRenderComplete)
                // 阻断不显示的动画
                apeng.CreatePrefabToEditorCC.itemAnimIgnore(item, !value);
            this.checkLoadResouces(index);
            return value;
        }
        /**
         * 当前item全显示
         * @param item
         * @returns
         */
        containsRectItem(index) {
            if (this.LayoutCC)
                this.LayoutCC.getItemRectange(rectangleT, index, true);
            else if (this.Layout)
                apeng.NodeHelper.getRectangle(rectangleT, this.items[index], true, false);
            return this.rectangle.containsRect(rectangleT);
        }
        setContentPosition(x, y) {
            this.content.setPosition(x, y);
            this.setVisibleByRectangeListView(false);
        }
        setContentDeviation(x, y) {
            let pos = this.content.getPosition();
            this.content.setPosition(pos.x + x, pos.y + y);
        }
    };
    __decorate([
        apeng.property({
            tooltip: "0不启用, 调用addItem时 会延迟添加到场景中",
            displayName: "分帧加载间隔时间"
        })
    ], ListCC.prototype, "intervalAddTime", null);
    __decorate([
        apeng.property({
            step: 1,
            min: 1,
            displayName: "分帧加载个数",
            visible() { return this.intervalAddTime != 0; },
        })
    ], ListCC.prototype, "intervalAddCount", null);
    __decorate([
        apeng.property({
            displayName: "不可见移除渲染队列"
        })
    ], ListCC.prototype, "removeRender", void 0);
    __decorate([
        apeng.property({
            tooltip: "item每层分开渲染，合并dc 反之只隐藏",
            displayName: "渲染重排序",
            visible() { return this.removeRender; },
        })
    ], ListCC.prototype, "removeRenderByResetSort", void 0);
    __decorate([
        apeng.property({
            displayName: "弹窗动画延检测"
        })
    ], ListCC.prototype, "uiAnimCheck", void 0);
    __decorate([
        apeng.property({
            displayName: "点击滚动"
        })
    ], ListCC.prototype, "isClickMove", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击滑动顶部",
            visible() { return this.isClickMove; },
        })
    ], ListCC.prototype, "btnMoveTop", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击滑动底部",
            visible() { return this.isClickMove; },
        })
    ], ListCC.prototype, "btnMoveBottom", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击滑动左边",
            visible() { return this.isClickMove; },
        })
    ], ListCC.prototype, "btnMoveLeft", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击滑动右边",
            visible() { return this.isClickMove; },
        })
    ], ListCC.prototype, "btnMoveRight", void 0);
    __decorate([
        apeng.property({
            displayName: "边界隐藏按钮",
            visible() { return this.isClickMove; },
        })
    ], ListCC.prototype, "borderHideBtn", void 0);
    __decorate([
        apeng.property({
            displayName: "超过指定个数开启拖动"
        })
    ], ListCC.prototype, "maxCountEnableDrag", void 0);
    __decorate([
        apeng.property({
            displayName: "渲染区域缩放"
        })
    ], ListCC.prototype, "renderBoxScale", void 0);
    __decorate([
        apeng.property({
            displayName: "资源加载延迟"
        })
    ], ListCC.prototype, "resoucesDelay", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ListCC.prototype, "_intervalAddCount", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ListCC.prototype, "_intervalAddTime", void 0);
    ListCC = __decorate([
        apeng.ccclass("ListCC"),
        apeng.executeInEditMode,
        apeng.menuList("ListCC")
    ], ListCC);
    apeng.ListCC = ListCC;
})(apeng || (apeng = {}));

(function (apeng) {
    var EventHandlerCC_1;
    const eventT = new apeng.EventTouch([], false, "");
    const TouchByMouseEventMap = {
        [apeng.Input.EventType.TOUCH_START]: apeng.Input.EventType.MOUSE_DOWN,
        [apeng.Input.EventType.TOUCH_MOVE]: apeng.Input.EventType.MOUSE_MOVE,
        [apeng.Input.EventType.TOUCH_END]: apeng.Input.EventType.MOUSE_UP,
        [apeng.Input.EventType.TOUCH_CANCEL]: apeng.Input.EventType.MOUSE_UP,
    };
    const BlockEvents = [
        apeng.Node.EventType.TOUCH_START,
        apeng.Node.EventType.TOUCH_END,
        apeng.Node.EventType.TOUCH_MOVE,
        apeng.Node.EventType.MOUSE_DOWN,
        apeng.Node.EventType.MOUSE_MOVE,
        apeng.Node.EventType.MOUSE_UP,
        apeng.Node.EventType.MOUSE_ENTER,
        apeng.Node.EventType.MOUSE_LEAVE,
        apeng.Node.EventType.MOUSE_WHEEL
    ];
    /**编辑器事件派发类 */
    let EventHandlerCC = EventHandlerCC_1 = class EventHandlerCC {
        constructor() {
            this.event = new apeng.EventHandler();
            this.events = [];
            this.emitHandler = null;
            this._addEvents = [];
        }
        static stopPropagation(event) {
            event.propagationStopped = true;
        }
        static onClick(node, callBack, caller) {
            this.offClick(node, callBack, caller);
            let btn = node.getComponent("ButtonCC");
            if (btn) {
                btn.eventHandler.addEvent({ caller, callBack });
                return;
            }
            let events = this.getCallBacks(node);
            let fn = (e) => {
                if (!EventHandlerCC_1.enableClick)
                    return;
                EventHandlerCC_1.stopPropagation(e);
                let isPlayAudio = callBack.call(caller, e);
                // 播放音效
                if (isPlayAudio === undefined || isPlayAudio === true)
                    if (EventHandlerCC_1.clickSoundUrl)
                        apeng._audio.play(EventHandlerCC_1.clickSoundUrl);
            };
            events.push({ callBack, caller, fn });
            node.on(apeng.Node.EventType.TOUCH_END, fn, caller);
            let block = node.getComponent(apeng.BlockInputEvents);
            if (!block)
                node.addComponent(apeng.BlockInputEvents);
        }
        static offClick(node, callBack, caller) {
            let btn = node.getComponent("ButtonCC");
            if (btn) {
                btn.eventHandler.offEvent({ caller, callBack });
                return;
            }
            let events = this.getCallBacks(node);
            let data = apeng.Sets.filterValue(events, v => v.callBack == callBack && v.caller == caller);
            if (data) {
                apeng.Sets.delete(events, data);
                node.off(apeng.Node.EventType.TOUCH_END, data.fn, data.caller);
            }
        }
        static offAllClick(node) {
            let btn = node.getComponent("ButtonCC");
            if (btn) {
                btn.eventHandler.offAllEvent();
                return;
            }
            let events = this.getCallBacks(node);
            apeng.Sets.forEach(events, v => {
                apeng.Sets.delete(events, v);
                node.off(apeng.Node.EventType.TOUCH_END, v.fn, v.caller);
            }, true);
        }
        static getCallBacks(node) {
            let events = node["onClickByCallBack"];
            if (events == undefined)
                events = node["onClickByCallBack"] = [];
            return events;
        }
        static runClick(node, event) {
            let btn = node.getComponent("ButtonCC");
            if (btn) {
                btn.onTouchStart(event);
                btn.onTouchEnd(event);
            }
            else {
                let events = this.getCallBacks(node);
                for (let data of events)
                    data.fn(event);
            }
        }
        /**
         * 分发事件到时间流中
         * @param node
         * @param event
         * @param type
         * @param isCatch 捕获阶段
         */
        static dispatchEvent(node, event, type, emitData = null, isCatch) {
            eventT._touches = event.getTouches();
            eventT.touch = event.touch;
            eventT.bubbles = event.bubbles;
            eventT.type = type;
            if (isCatch !== undefined)
                event.eventPhase = Event.CAPTURING_PHASE;
            eventT.simulate = false;
            eventT.emitData = emitData;
            node.dispatchEvent(eventT);
        }
        get isCall() {
            if (this.event.handler)
                return true;
            if (this.events.length > 0)
                return true;
            if (this._addEvents.length > 0)
                return true;
            return false;
        }
        emit(...values) {
            let isPlayAudio = true;
            if (!this.isCall)
                return isPlayAudio;
            if (this.emitHandler == null) {
                this.emitHandler = [];
                for (let event of this.events)
                    if (event)
                        this.emitHandler.push(event);
                this.emitHandler.push(this.event);
            }
            apeng.EventHandler.emitEvents(this.emitHandler, ...values);
            for (let value of this._addEvents) {
                values = values.slice();
                if (value.args)
                    values.push(...value.args);
                if (value.caller) {
                    if (value.callBack.apply(value.caller, values) === false)
                        isPlayAudio = false;
                }
                else if (value.callBack(...values) === false)
                    isPlayAudio = false;
            }
            return isPlayAudio;
        }
        /**添加事件 */
        addEvent(value) {
            // 排除重复添加事件
            if (apeng.Sets.filterValue(this._addEvents, event => event.caller == value.caller && event.callBack == value.callBack))
                return;
            this._addEvents.push(value);
        }
        offEvent(value) {
            let data = apeng.Sets.filterValue(this._addEvents, event => event.caller == value.caller && event.callBack == value.callBack);
            if (data)
                apeng.Sets.delete(this._addEvents, data);
        }
        offAllEvent() {
            apeng.Sets.forEach(this._addEvents, v => {
                this.offEvent(v);
            }, true);
        }
    };
    /**打开按钮事件 */
    EventHandlerCC.enableClick = true;
    /**手指发生了拖动 */
    EventHandlerCC.touchIsMove = false;
    /**手指在拖动中，并且移动了距离 */
    EventHandlerCC.touchIsMoveRun = false;
    /**自动注册点击事件时 播放的音效 */
    EventHandlerCC.clickSoundUrl = "";
    EventHandlerCC.touchEvent = new class {
        on(type, callBack, caller) {
            if (apeng.sys.hasFeature(apeng.sys.Feature.INPUT_TOUCH))
                apeng.input._touchInput._eventTarget.on(type, callBack, caller);
            if (apeng.sys.hasFeature(apeng.sys.Feature.EVENT_MOUSE))
                apeng.input._mouseInput._eventTarget.on(TouchByMouseEventMap[type], callBack, caller);
            return this;
        }
        off(type, callBack, caller) {
            if (apeng.sys.hasFeature(apeng.sys.Feature.INPUT_TOUCH))
                apeng.input._touchInput._eventTarget.off(type, callBack, caller);
            if (apeng.sys.hasFeature(apeng.sys.Feature.EVENT_MOUSE))
                apeng.input._mouseInput._eventTarget.off(TouchByMouseEventMap[type], callBack, caller);
            return this;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.EventHandler,
            displayName: "单事件",
        })
    ], EventHandlerCC.prototype, "event", void 0);
    __decorate([
        apeng.property({
            type: [apeng.EventHandler],
            displayName: "事件池",
            visible() { return this.event.target; },
        })
    ], EventHandlerCC.prototype, "events", void 0);
    EventHandlerCC = EventHandlerCC_1 = __decorate([
        apeng.ccclass("EventHandlerCC")
    ], EventHandlerCC);
    apeng.EventHandlerCC = EventHandlerCC;
})(apeng || (apeng = {}));

(function (apeng) {
    /**完成回调处理  */
    class CompleteCallBack {
        constructor() {
            this.cb = null;
            this._cb = null;
        }
        set(cb = null) {
            this.cb = cb;
            this._cb = cb;
        }
        run(...param) {
            // 避免回调嵌套
            let cb = this.cb;
            this.cb = null;
            if (cb)
                return cb(...param);
            return null;
        }
        clear() {
            this.cb = null;
        }
    }
    apeng.CompleteCallBack = CompleteCallBack;
})(apeng || (apeng = {}));
/// <reference path="./ListCC.ts" />
/// <reference path="./../helper/EventHandlerCC.ts" />
/// <reference path="./../utils/CompleteCallBack.ts" />

(function (apeng) {
    var AnimtorCCStateItemFrame_1;
    let AnimtorCCStateItemFrame = AnimtorCCStateItemFrame_1 = class AnimtorCCStateItemFrame {
        constructor() {
            this.delay = 0;
            this.eventHandler = new apeng.EventHandlerCC();
        }
        /**
         * 创建一个帧事件
         * @param delay
         * @param event
         * @returns
         */
        static create(delay, event) {
            let value = new AnimtorCCStateItemFrame_1();
            value.delay = delay;
            value.eventHandler.addEvent(event);
            return value;
        }
    };
    __decorate([
        apeng.property({
            displayName: "延迟时长"
        })
    ], AnimtorCCStateItemFrame.prototype, "delay", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "触发回调"
        })
    ], AnimtorCCStateItemFrame.prototype, "eventHandler", void 0);
    AnimtorCCStateItemFrame = AnimtorCCStateItemFrame_1 = __decorate([
        apeng.ccclass("AnimtorCCStateItemFrame")
    ], AnimtorCCStateItemFrame);
    apeng.AnimtorCCStateItemFrame = AnimtorCCStateItemFrame;
    let AnimtorCCStateItem = class AnimtorCCStateItem {
        constructor() {
            this.animName = "";
            this.crossFade = 0;
            this.finishPlayName = "";
            this.eventHandlerFinish = new apeng.EventHandlerCC();
            this.frames = [];
            this.animtor = null;
        }
        play() {
            if (this.crossFade != 0)
                this.animtor.anim.crossFade(this.animName, this.crossFade);
            else
                this.animtor.anim.play(this.animName);
            for (let frame of this.frames) {
                if (frame.delay != 0 && frame.eventHandler.isCall) {
                    this.animtor.scheduleOnce(() => {
                        if (this.animtor.curPlayAnimName != this.animName)
                            return;
                        // 派发帧事件
                        frame.eventHandler.emit();
                    }, frame.delay);
                }
            }
        }
        onFinish() {
            this.eventHandlerFinish.emit();
            if (this.finishPlayName)
                this.animtor.play(this.finishPlayName);
        }
    };
    __decorate([
        apeng.property({
            displayName: "clip名"
        })
    ], AnimtorCCStateItem.prototype, "animName", void 0);
    __decorate([
        apeng.property({
            displayName: "切换过渡时间"
        })
    ], AnimtorCCStateItem.prototype, "crossFade", void 0);
    __decorate([
        apeng.property({
            displayName: "播放完后继续播放",
        })
    ], AnimtorCCStateItem.prototype, "finishPlayName", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "播放完成"
        })
    ], AnimtorCCStateItem.prototype, "eventHandlerFinish", void 0);
    __decorate([
        apeng.property({
            type: [AnimtorCCStateItemFrame],
            displayName: "帧事件",
        })
    ], AnimtorCCStateItem.prototype, "frames", void 0);
    AnimtorCCStateItem = __decorate([
        apeng.ccclass("AnimtorCCStateItem")
    ], AnimtorCCStateItem);
    apeng.AnimtorCCStateItem = AnimtorCCStateItem;
    let AnimtorCC = class AnimtorCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "动画组件";
            this.anim = null;
            this.autoPlay = false;
            this.animCompleteUpdateList = null;
            this.items = [];
            this.curPlayAnimName = "";
            this.curPlayAnimNameCb = new apeng.CompleteCallBack();
            this.itemsMap = {};
        }
        onLoad() {
            super.onLoad();
            // 自动添加组件
            if (apeng.EDITOR) {
                if (!this.anim)
                    this.anim = this.getComponent(apeng.Animation);
                return;
            }
            for (let item of this.items)
                item.animtor = this;
            this.addEvent(apeng.Animation.EventType.FINISHED, this.onEventAnimFinish, this, this.anim);
        }
        onEnable() {
            super.onEnable();
            if (apeng.EDITOR)
                return;
            if (this.autoPlay)
                this.playDefault();
        }
        onDisable() {
            if (!this.isPersistRootNode) {
                this.curPlayAnimName = "";
                this.curPlayAnimNameCb.clear();
            }
            super.onDisable();
        }
        getClipIndexByName(index) {
            if (!this.anim)
                return "";
            let clip = null;
            if (index == undefined) {
                for (let value of this.anim.clips)
                    if (value) {
                        clip = value;
                        break;
                    }
            }
            else
                clip = this.anim.clips[index];
            return clip.name;
        }
        /**
         * 添加状态得帧事件
         * 如果未配置 则创建个新的
         * @param animName 动画名
         * @param event 事件回调
         * @param delay 延迟时间 默认使用编辑器配置的
         * @param frameIndex 帧索引
         */
        addStateFrameEvent(animName, event, delay = 0, frameIndex = 0) {
            let item = this.getStateItem(animName);
            if (!item.frames[frameIndex])
                item.frames[frameIndex] = AnimtorCCStateItemFrame.create(delay, event);
            else
                item.frames[frameIndex].eventHandler.addEvent(event);
        }
        /**
         * 获取一个状态 如没有 则创建默认的
         * @param animName
         * @returns
         */
        getStateItem(animName) {
            let item = this.getAnimNameByItem(animName);
            // 不存在则添加一个状态
            if (!item) {
                item = new AnimtorCCStateItem();
                item.animName = animName;
                item.animtor = this;
                this.items.push(item);
            }
            return item;
        }
        getAnimNameByItem(animName) {
            if (!this.itemsMap[animName])
                this.itemsMap[animName] = apeng.Sets.filterValue(this.items, v => v.animName == animName);
            return this.itemsMap[animName];
        }
        /**
         * 播放动画
         * 需先配置item列表
         * @param animName
         * @param cb
         * @returns
         */
        play(animName, crossFade = 0, cb, speed) {
            if (!this.anim)
                return;
            if (!animName)
                return;
            this.curPlayAnimName = animName;
            this.curPlayAnimNameCb.set(cb);
            if (speed != undefined)
                this.setAnimSpeed(animName, speed);
            if (this.animCompleteUpdateList)
                this.animCompleteUpdateList.otherAnimComplete(true);
            let item = this.getAnimNameByItem(animName);
            if (item)
                item.play();
            else {
                if (crossFade != 0)
                    this.anim.crossFade(animName, crossFade);
                else
                    this.anim.play(animName);
            }
        }
        /**当前动画是否播放完毕 */
        hasPlayComplete(animName = "") {
            let curState = this.getCurState();
            if (!curState)
                return true;
            if (animName && curState.name != animName)
                return true;
            return curState.isPlaying;
        }
        /**切换动画状态 */
        changeState(animName) {
            if (this.curPlayAnimName == animName)
                return;
            this.play(animName);
        }
        setAnimSpeed(animName, speed) {
            if (!this.anim)
                return;
            if (!animName)
                return;
            if (speed == undefined)
                return;
            let state = this.anim.getState(animName);
            if (state)
                state.speed = speed;
        }
        getCurState() {
            return this.getState(this.curPlayAnimName);
        }
        getState(animName) {
            if (!this.anim)
                return;
            let state = this.anim.getState(animName);
            return state;
        }
        /**设置动画播放完 需要多长时间 */
        setAnimDurationBySpeed(animName, duration) {
            if (!this.anim)
                return;
            if (!animName)
                return;
            if (!duration)
                return;
            let state = this.anim.getState(animName);
            this.setAnimSpeed(animName, state.duration / duration);
        }
        pause(animName) {
            var _a;
            if (!animName)
                animName = this.getClipIndexByName();
            (_a = this.getState(animName)) === null || _a === void 0 ? void 0 : _a.pause();
        }
        resume(animName) {
            var _a;
            if (!animName)
                animName = this.getClipIndexByName();
            (_a = this.getState(animName)) === null || _a === void 0 ? void 0 : _a.resume();
        }
        playDefault(cb) {
            this.play(this.getClipIndexByName(), 0, cb);
        }
        getDefaultClip() {
            if (!this.anim)
                return null;
            return this.anim.clips[0];
        }
        stop() {
            if (!this.anim)
                return;
            this.anim.stop();
        }
        onEventAnimFinish(type, state) {
            if (state.clip.name != this.curPlayAnimName)
                return;
            let item = this.getAnimNameByItem(state.clip.name);
            if (item)
                item.onFinish();
            this.curPlayAnimNameCb.run();
            if (this.animCompleteUpdateList)
                this.animCompleteUpdateList.otherAnimComplete(false);
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Animation,
            displayName: "动画组件",
        })
    ], AnimtorCC.prototype, "anim", void 0);
    __decorate([
        apeng.property({
            displayName: "显示时播放动画"
        })
    ], AnimtorCC.prototype, "autoPlay", void 0);
    __decorate([
        apeng.property({
            type: apeng.ListCC,
            displayName: "播放完成 更新rect"
        })
    ], AnimtorCC.prototype, "animCompleteUpdateList", void 0);
    __decorate([
        apeng.property({
            type: [AnimtorCCStateItem],
            displayName: "配置"
        })
    ], AnimtorCC.prototype, "items", void 0);
    AnimtorCC = __decorate([
        apeng.ccclass("AnimtorCC"),
        apeng.executeInEditMode,
        apeng.menuAnim("AnimtorCC")
    ], AnimtorCC);
    apeng.AnimtorCC = AnimtorCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let AutoTargetSizeCC = class AutoTargetSizeCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "自动撑开目标节点Size";
            this.target = null;
            this.autoWidth = false;
            this.autoHeight = false;
            this.widgets = [];
            this._paddingWidth = 0;
            this._ratioWidth = 1;
            this._paddingHeight = 0;
            this._ratioHeight = 1;
            this.onEditorUpdateData = this.onSizeChange;
            /**监听当前节点大小改变时刷新 */
            this.isSizeChangeUpdate = true;
        }
        set paddingWidth(value) {
            this._paddingWidth = value;
            this.onSizeChange();
        }
        get paddingWidth() { return this._paddingWidth; }
        set ratioWidth(value) {
            this._ratioWidth = value;
            this.onSizeChange();
        }
        get ratioWidth() { return this._ratioWidth; }
        set paddingHeight(value) {
            this._paddingHeight = value;
            this.onSizeChange();
        }
        get paddingHeight() { return this._paddingHeight; }
        set ratioHeight(value) {
            this._ratioHeight = value;
            this.onSizeChange();
        }
        get ratioHeight() { return this._ratioHeight; }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR)
                if (!this.target)
                    this.target = this.node.parent;
        }
        onEnable() {
            super.onEnable();
            this.onSizeChange();
        }
        /**自动对齐padding */
        onSizeChange() {
            if (!this.isSizeChangeUpdate)
                return;
            this.updateView();
        }
        updateView() {
            if (!this.target)
                return;
            let size = this.getSize();
            let w = null, h = null;
            let uiTrans = apeng.NodeHelper.getUITransform(this.target);
            if (this.autoWidth) {
                let _w = size.width * this.getScale(false).x * this._ratioWidth + this._paddingWidth;
                if (uiTrans.width != _w)
                    w = _w;
            }
            if (this.autoHeight) {
                let _h = size.height * this.getScale(false).y * this._ratioHeight + this._paddingHeight;
                if (uiTrans.height != _h)
                    h = _h;
            }
            apeng.NodeHelper.setSize(this.target, w, h);
            // 渲染组件未更新
            if (w != null || h != null)
                this.scheduleOnceCover(this.updateRender);
            this.updateWidget();
            if (!apeng.EDITOR)
                this.scheduleOnceCover(this.updateWidget);
        }
        updateRender() {
            let render = apeng.NodeHelper.getUIRenderer(this.target);
            if (render)
                render.markForUpdateRenderData();
        }
        updateWidget() {
            for (let widget of this.widgets)
                if (widget)
                    widget.updateAlignment();
        }
        /**获取当前节点大小 方便子类重写 */
        getSize() {
            return this.UITransform.contentSize;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Node,
            tooltip: "自动对齐父节点",
            displayName: "对齐的节点",
        })
    ], AutoTargetSizeCC.prototype, "target", void 0);
    __decorate([
        apeng.property({
            displayName: "自动对齐宽"
        })
    ], AutoTargetSizeCC.prototype, "autoWidth", void 0);
    __decorate([
        apeng.property({
            displayName: "宽的边距",
            visible() { return this.autoWidth; }
        })
    ], AutoTargetSizeCC.prototype, "paddingWidth", null);
    __decorate([
        apeng.property({
            displayName: "宽的比率",
            visible() { return this.autoWidth; }
        })
    ], AutoTargetSizeCC.prototype, "ratioWidth", null);
    __decorate([
        apeng.property({
            displayName: "自动对齐高"
        })
    ], AutoTargetSizeCC.prototype, "autoHeight", void 0);
    __decorate([
        apeng.property({
            displayName: "高的边距",
            visible() { return this.autoHeight; }
        })
    ], AutoTargetSizeCC.prototype, "paddingHeight", null);
    __decorate([
        apeng.property({
            displayName: "高的比率",
            visible() { return this.autoHeight; }
        })
    ], AutoTargetSizeCC.prototype, "ratioHeight", null);
    __decorate([
        apeng.property({
            type: [apeng.Widget],
            displayName: "更新Widget"
        })
    ], AutoTargetSizeCC.prototype, "widgets", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], AutoTargetSizeCC.prototype, "_paddingWidth", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], AutoTargetSizeCC.prototype, "_ratioWidth", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], AutoTargetSizeCC.prototype, "_paddingHeight", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], AutoTargetSizeCC.prototype, "_ratioHeight", void 0);
    AutoTargetSizeCC = __decorate([
        apeng.ccclass("AutoTargetSizeCC"),
        apeng.executeInEditMode,
        apeng.menuUI("AutoTargetSizeCC")
    ], AutoTargetSizeCC);
    apeng.AutoTargetSizeCC = AutoTargetSizeCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ButtonByChildGrayExcludeCC = class ButtonByChildGrayExcludeCC extends _cc_.Component {
        constructor() {
            super(...arguments);
            this.backupDescribe = "按钮置灰时排除当前或所有子节点";
        }
    };
    ButtonByChildGrayExcludeCC = __decorate([
        apeng.ccclass("ButtonByChildGrayExcludeCC"),
        apeng.menuBtn("ButtonByChildGrayExcludeCC")
    ], ButtonByChildGrayExcludeCC);
    apeng.ButtonByChildGrayExcludeCC = ButtonByChildGrayExcludeCC;
})(apeng || (apeng = {}));
/// <reference path="./../helper/DirectorHelper.ts" />

(function (apeng) {
    const v2T = new apeng.Vec2();
    const BlockEvents = [
        apeng.Node.EventType.MOUSE_DOWN,
        apeng.Node.EventType.MOUSE_MOVE,
        apeng.Node.EventType.MOUSE_UP,
        apeng.Node.EventType.MOUSE_ENTER,
        apeng.Node.EventType.MOUSE_LEAVE,
        apeng.Node.EventType.MOUSE_WHEEL
    ];
    let ButtonCC = class ButtonCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "按钮组件";
            this.isPlayAudio = true;
            this.isPlayAnimPress = true;
            this.pressDuration = .1;
            this.pressScale = 1.2;
            this.coolingTime = .2;
            this.breatheLinear = false;
            this.uiUrl = "";
            this.globalControl = true;
            this.eventHandler = new apeng.EventHandlerCC();
            this._isGray = false;
            this._isPlayBreathe = false;
            this._interactable = true;
            this._originalScale = new apeng.Vec3();
            this._transitionFinished = true;
            this._time = 0;
            this._targetScale = new apeng.Vec3();
            this._fromScale = new apeng.Vec3();
            this._toScale = new apeng.Vec3();
            /**按下中 */
            this._pressed = false;
            this._isCooling = false;
            this._playBreathe = false;
            this._playPress = false;
            this.tweenType = apeng.ETweenType.None;
        }
        set isPlayBreathe(value) {
            if (this._isPlayBreathe == value)
                return;
            this._isPlayBreathe = value;
            this.updateScale();
            if (!this._interactable)
                this.clearData();
        }
        get isPlayBreathe() { return this._isPlayBreathe; }
        set isGray(value) {
            if (this._isGray == value)
                return;
            this._isGray = value;
            this.gray(this._isGray);
            this.updateScale();
        }
        get isGray() { return this._isGray; }
        set interactable(value) {
            if (this._interactable = value)
                return;
            this._interactable = value;
            this.updateScale();
            if (!this._interactable)
                this.clearData();
        }
        get interactable() {
            return this._interactable;
        }
        onLoad() {
            super.onLoad();
            this.node.getScale(this._originalScale);
            this.clearData();
            this.tweenType = this.breatheLinear ? apeng.ETweenType.BreatheLinear : apeng.ETweenType.Breathe;
            if (this._isPlayBreathe)
                this._playBreathe = true;
            if (this.isPlayAnimPress)
                this._playPress = true;
            for (let type of BlockEvents)
                this.addEvent(type, apeng.EventHandlerCC.stopPropagation, apeng.EventHandlerCC, this.node);
        }
        onEnable() {
            super.onEnable();
            this.clearData();
            this.updateScale();
            this.gray(this._isGray);
        }
        onDisable() {
            super.onDisable();
            this.clearData();
        }
        onUpdate() {
            if (this._transitionFinished)
                return;
            if (!this.isPlayAnimPress)
                return;
            this._time += apeng._timer.dtDefault;
            let ratio = 1.0;
            ratio = this._time / this.pressDuration;
            if (ratio >= 1)
                ratio = 1;
            this.node.getScale(this._targetScale);
            this._targetScale.x = apeng.lerp(this._fromScale.x, this._toScale.x, ratio);
            this._targetScale.y = apeng.lerp(this._fromScale.y, this._toScale.y, ratio);
            this.node.setScale(this._targetScale);
            if (ratio >= 1)
                this._transitionFinished = true;
        }
        /**
         * 暂停事件 包括动画 按压效果
         * @param value
         * @param stopEvent 阻止响应事件
         */
        setStopClick(value, stopEvent, gray = true) {
            if (gray)
                this._isGray = value;
            if (this._playBreathe)
                this._isPlayBreathe = !value;
            if (this._playPress)
                this.isPlayAnimPress = !value;
            if (stopEvent)
                this.interactable = !value;
            this.clearData();
            this.updateScale();
            this.gray(this._isGray);
        }
        onTouchStart(e) {
            if (!this.hasEmitEvent())
                return;
            this._pressed = true;
            this.updateScale();
            apeng.EventHandlerCC.stopPropagation(e);
        }
        onTouchMove(event) {
            if (!this.hasEmitEvent())
                return;
            if (!this._pressed)
                return;
            if (!event)
                return;
            const touch = (event).touch;
            if (!touch)
                return;
            const hit = this.UITransform.isHit(touch.getUILocation(v2T));
            if (hit) {
                apeng.Vec3.copy(this._fromScale, this._originalScale);
                apeng.Vec3.multiplyScalar(this._toScale, this._originalScale, this.pressScale);
                this._transitionFinished = false;
            }
            else {
                this._time = 0;
                this.node.setScale(this._originalScale);
                this._transitionFinished = true;
            }
            apeng.EventHandlerCC.stopPropagation(event);
        }
        onTouchEnd(event) {
            if (!this.hasEmitEvent())
                return;
            // 冷却事件计时
            this._isCooling = true;
            if (this.coolingTime <= 0)
                this.onTouchNodeEndTimerOnce();
            else
                this.scheduleOnceCover(this.onTouchNodeEndTimerOnce, this.coolingTime);
            if (this._pressed) {
                // 派发事件
                let isPlayAudio = this.eventHandler.emit(event);
                // 播放音效
                if (isPlayAudio && this.isPlayAudio && apeng.EventHandlerCC.clickSoundUrl)
                    apeng._audio.play(apeng.EventHandlerCC.clickSoundUrl);
                if (this.uiUrl)
                    apeng._ui.open(this.uiUrl, null, null, null, true);
            }
            this._pressed = false;
            this.updateScale();
            apeng.EventHandlerCC.stopPropagation(event);
        }
        onTouchCancel(event) {
            if (!this.hasEmitEvent())
                return;
            this._pressed = false;
            this.updateScale();
        }
        updateScale() {
            if (apeng.EDITOR)
                return;
            apeng.TweenHelper.stop(this.node, this.tweenType);
            if (this._pressed) {
                apeng.Vec3.copy(this._fromScale, this._originalScale);
                apeng.Vec3.multiplyScalar(this._toScale, this._originalScale, this.pressScale);
                if (this._isPlayBreathe) {
                    this.node.setScale(this._originalScale);
                    apeng.TweenHelper.stop(this.node, this.tweenType);
                }
            }
            else {
                this.node.getScale(this._fromScale);
                apeng.Vec3.copy(this._toScale, this._originalScale);
                if (this._isPlayBreathe) {
                    this.node.setScale(this._originalScale);
                    apeng.TweenHelper.default(this.node, this.tweenType);
                    return;
                }
            }
            this._time = 0;
            this._transitionFinished = false;
        }
        onTouchNodeEndTimerOnce() {
            this._isCooling = false;
        }
        clearData() {
            apeng.TweenHelper.stop(this.node, this.tweenType);
            this._pressed = false;
            this._time = 0;
            this._isCooling = false;
            if (!apeng.EDITOR)
                this.node.setScale(this._originalScale);
        }
        hasEmitEvent() {
            if (!this._interactable)
                return false;
            if (!this.enabledInHierarchy)
                return false;
            if (!apeng.EventHandlerCC.enableClick && this.globalControl) {
                console.log("buttonCC event close, ButEnabled = " + apeng.EventHandlerCC.enableClick);
                return false;
            }
            if (this._isCooling) {
                console.log("buttonCC cooling");
                return false;
            }
            return true;
        }
    };
    __decorate([
        apeng.property({
            displayName: "播放音效"
        })
    ], ButtonCC.prototype, "isPlayAudio", void 0);
    __decorate([
        apeng.property({
            displayName: "按压效果"
        })
    ], ButtonCC.prototype, "isPlayAnimPress", void 0);
    __decorate([
        apeng.property({
            displayName: "按压过渡时间",
            visible() { return this.isPlayAnimPress; }
        })
    ], ButtonCC.prototype, "pressDuration", void 0);
    __decorate([
        apeng.property({
            displayName: "按压缩放的大小",
            visible() { return this.isPlayAnimPress; }
        })
    ], ButtonCC.prototype, "pressScale", void 0);
    __decorate([
        apeng.property({
            displayName: "冷却时间"
        })
    ], ButtonCC.prototype, "coolingTime", void 0);
    __decorate([
        apeng.property({
            displayName: "播放呼吸动画"
        })
    ], ButtonCC.prototype, "isPlayBreathe", null);
    __decorate([
        apeng.property({
            displayName: "线性呼吸",
            visible() { return this._isPlayBreathe; }
        })
    ], ButtonCC.prototype, "breatheLinear", void 0);
    __decorate([
        apeng.property({
            displayName: "置灰"
        })
    ], ButtonCC.prototype, "isGray", null);
    __decorate([
        apeng.property({
            displayName: "响应事件"
        })
    ], ButtonCC.prototype, "interactable", null);
    __decorate([
        apeng.property({
            displayName: "打开ui路径"
        })
    ], ButtonCC.prototype, "uiUrl", void 0);
    __decorate([
        apeng.property({
            tooltip: "进入EventHandlerCC.enableClick控制",
            displayName: "全局控制"
        })
    ], ButtonCC.prototype, "globalControl", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "派发事件"
        })
    ], ButtonCC.prototype, "eventHandler", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ButtonCC.prototype, "_isGray", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ButtonCC.prototype, "_isPlayBreathe", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ButtonCC.prototype, "_interactable", void 0);
    ButtonCC = __decorate([
        apeng.ccclass("ButtonCC"),
        apeng.menuBtn("ButtonCC")
    ], ButtonCC);
    apeng.ButtonCC = ButtonCC;
})(apeng || (apeng = {}));

(function (apeng) {
    class Spherical {
        constructor(radius = 1, phi = 0, theta = 0) {
            this.radius = 1;
            this.phi = 0;
            this.theta = 0;
            this.radius = radius;
            this.phi = phi; // polar angle
            this.theta = theta; // azimuthal angle
            return this;
        }
        set(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        }
        copy(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        }
        // restrict phi to be between EPS and PI-EPS
        makeSafe() {
            const EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        }
        setFromVector3(v) {
            return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
            this.radius = Math.sqrt(x * x + y * y + z * z);
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            }
            else {
                this.theta = Math.atan2(x, z);
                this.phi = Math.acos(apeng.math.clamp(y / this.radius, -1, 1));
            }
            return this;
        }
        clone() {
            return new Spherical().copy(this);
        }
        toVec3(out) {
            const phi = this.phi;
            const radius = this.radius;
            const theta = this.theta;
            const sinPhiRadius = Math.sin(phi) * radius;
            out.x = sinPhiRadius * Math.sin(theta);
            out.y = Math.cos(phi) * radius;
            out.z = sinPhiRadius * Math.cos(theta);
            return this;
        }
    }
    const STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
    };
    const EPS = apeng.math.EPSILON;
    const twoPI = 2 * Math.PI;
    const _tempVec3 = new apeng.Vec3();
    const _tempVec3_1 = new apeng.Vec3();
    const _tempVec2 = new apeng.Vec2();
    const _tempVec2_1 = new apeng.Vec2();
    const _tempVec2_2 = new apeng.Vec2();
    const _tempVec2_3 = new apeng.Vec2();
    let CameraOrbitControlCC = class CameraOrbitControlCC extends apeng.Component {
        constructor() {
            super(...arguments);
            this.target = new apeng.Vec3();
            this.minDistance = 0;
            this.maxDistance = 9999999;
            this.isAutoEvent = true;
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            this.minAzimuthAngle = -Infinity;
            this.maxAzimuthAngle = Infinity;
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.enableZoom = true;
            this.zoomSpeed = 1.0;
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = true;
            this.keyPanSpeed = 7.0;
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0;
            this.object = null;
            this.camera = null;
            this.state = STATE.NONE;
            this.spherical = new Spherical();
            this.sphericalDelta = new Spherical();
            this.scale = 1;
            this.panOffset = new apeng.Vec3();
            this.zoomChanged = false;
            this.rotateStart = new apeng.Vec2();
            this.rotateEnd = new apeng.Vec2();
            this.rotateDelta = new apeng.Vec2();
            this.panStart = new apeng.Vec2();
            this.panEnd = new apeng.Vec2();
            this.panDelta = new apeng.Vec2();
            this.dollyStart = new apeng.Vec2();
            this.dollyEnd = new apeng.Vec2();
            this.dollyDelta = new apeng.Vec2();
            this.pointers = [];
            this.pointerPositions = {};
            this._scaleAdd = 1;
            this.offset = new apeng.Vec3();
            // so camera.up is the orbit axis
            this.quat = new apeng.Quat(); //.setFromUnitVectors(object.up, v3(0, 1, 0));
            this.quatInverse = new apeng.Quat();
            this.lastPosition = new apeng.Vec3();
            this.lastQuaternion = new apeng.Quat();
        }
        get scaleRatio() { return this._scaleAdd; }
        onLoad() {
            this.object = this.node;
            this.camera = this.node.getComponent(apeng.Camera);
        }
        start() {
            // so camera.up is the orbit axis
            this.reset();
        }
        reset() {
            apeng.Quat.rotationTo(this.quat, this.object.up, apeng.Vec3.UP);
            apeng.Quat.invert(this.quatInverse, this.quat);
            this.spherical.radius = apeng.Vec3.distance(this.object.position, this.target);
        }
        onEnable() {
            // input.on(Input.EventType.MOUSE_MOVE, this._onMouseMove, this);
            // input.on(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
            if (this.isAutoEvent) {
                apeng.input.on(apeng.Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);
                apeng.input.on(apeng.Input.EventType.TOUCH_MOVE, this.onMouseMove, this);
            }
        }
        onDisable() {
            // input.off(Input.EventType.MOUSE_MOVE, this._onMouseMove, this);
            // input.off(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
            if (this.isAutoEvent) {
                apeng.input.off(apeng.Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);
                apeng.input.off(apeng.Input.EventType.TOUCH_MOVE, this.onMouseMove, this);
            }
        }
        onDestroy() {
        }
        onMouseDown(event) {
        }
        rotateLeft(angle) {
            this.sphericalDelta.theta -= angle;
        }
        rotateUp(angle) {
            this.sphericalDelta.phi -= angle;
        }
        handleMouseMoveRotate(event) {
            const rotateDelta = this.rotateDelta;
            const clientHeight = apeng.winSize().height;
            event.getDelta(rotateDelta);
            this.rotateDelta.multiplyScalar(this.rotateSpeed);
            this.rotateLeft(2 * Math.PI * rotateDelta.x / clientHeight); // yes, height
            this.rotateUp(-2 * Math.PI * rotateDelta.y / clientHeight);
            this.updateObject();
        }
        onMouseMove(event) {
            let touches = event.getTouches();
            if (touches.length >= 2) {
                let touch1 = touches[0], touch2 = touches[1];
                touch1.getLocation(_tempVec2);
                touch2.getLocation(_tempVec2_1);
                apeng.Vector2.sub(_tempVec2_2, _tempVec2, _tempVec2_1);
                touch1.getDelta(_tempVec2);
                touch2.getDelta(_tempVec2_1);
                apeng.Vector2.sub(_tempVec2_3, _tempVec2, _tempVec2_1);
                let last = this._scaleAdd;
                if (Math.abs(_tempVec2_2.x) > Math.abs(_tempVec2_2.y))
                    this._scaleAdd = (_tempVec2_2.x + _tempVec2_3.x) / _tempVec2_2.x * this._scaleAdd;
                else
                    this._scaleAdd = (_tempVec2_2.y + _tempVec2_3.y) / _tempVec2_2.y * this._scaleAdd;
                if (last > this._scaleAdd)
                    this.handleMouseWheel(false, .3);
                else if (last < this._scaleAdd)
                    this.handleMouseWheel(true, .3);
            }
            else {
                this.handleMouseMoveRotate(event);
            }
        }
        panLeft(distance) {
            //v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            const v = this.object.right;
            v.multiplyScalar(-distance);
            this.panOffset.add(v);
        }
        ;
        panUp(distance) {
            // if (scope.screenSpacePanning === true) {
            // v.setFromMatrixColumn(objectMatrix, 1);
            // } else {
            //     v.setFromMatrixColumn(objectMatrix, 0);
            //     v.crossVectors(scope.object.up, v);
            // }
            const v = this.object.up;
            v.multiplyScalar(-distance);
            this.panOffset.add(v);
        }
        ;
        pan(deltaX, deltaY) {
            const clientHeight = apeng.winSize().height;
            const scope = this;
            const offset = this.offset;
            // if (scope.object.isPerspectiveCamera) {
            // perspective
            const position = scope.object.position;
            offset.set(position).subtract(scope.target);
            let targetDistance = offset.length();
            // half of the fov is center to top of screen
            targetDistance *= Math.tan(scope.camera.fov / 2 * Math.PI / 180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            this.panLeft(2 * deltaX * targetDistance / clientHeight);
            this.panUp(2 * deltaY * targetDistance / clientHeight);
            // } else if (scope.object.isOrthographicCamera) {
            //     // orthographic
            //     panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            //     panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
            // } else {
            //     // camera neither orthographic nor perspective
            //     console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
            //     scope.enablePan = false;
            // }
        }
        onMouseWheel(event) {
            // evt.preventSwallow()
            let y = event.getScrollY();
            if (y > 0) {
                this.handleMouseWheel(true);
            }
            else if (y < 0) {
                this.handleMouseWheel(false);
            }
        }
        getZoomScale() {
            return Math.pow(0.95, this.zoomSpeed);
        }
        dollyOut(dollyScale) {
            // const scope = this
            // if (scope.object.isPerspectiveCamera) {
            // this.scale = Maths.clampf(this.scale / dollyScale, this.scaleMin, this.scaleMin);
            this.scale /= dollyScale;
            // } else if (scope.object.isOrthographicCamera) {
            //     scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            //     scope.object.updateProjectionMatrix();
            //     zoomChanged = true;
            // } else {
            //     console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            //     scope.enableZoom = false;
            // }
        }
        dollyIn(dollyScale) {
            // if (scope.object.isPerspectiveCamera) {
            this.scale *= dollyScale;
            // this.scale = Maths.clampf(this.scale * dollyScale, this.scaleMin, this.scaleMin);
            // } else if (scope.object.isOrthographicCamera) {
            //     scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            //     scope.object.updateProjectionMatrix();
            //     zoomChanged = true;
            // } else {
            //     console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            //     scope.enableZoom = false;
            // }
        }
        handleMouseWheel(big, mul = 1) {
            this.zoomSpeed = mul;
            if (big) {
                this.dollyIn(this.getZoomScale());
            }
            else {
                this.dollyOut(this.getZoomScale());
            }
            this.updateObject();
        }
        updateObject() {
            const scope = this;
            const offset = this.offset;
            const quat = this.quat;
            const quatInverse = this.quatInverse;
            const lastPosition = this.lastPosition;
            const lastQuaternion = this.lastQuaternion;
            const spherical = this.spherical;
            const sphericalDelta = this.sphericalDelta;
            const panOffset = this.panOffset;
            const position = scope.object.position;
            offset.set(position).subtract(scope.target);
            // rotate offset to "y-axis-is-up" space
            apeng.Vec3.transformQuat(offset, offset, quat);
            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);
            if (scope.autoRotate && this.state === STATE.NONE) {
                // rotateLeft(getAutoRotationAngle());
            }
            if (scope.enableDamping) {
                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            }
            else {
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
            }
            // restrict theta to be between desired limits
            let min = scope.minAzimuthAngle;
            let max = scope.maxAzimuthAngle;
            if (isFinite(min) && isFinite(max)) {
                if (min < -Math.PI)
                    min += twoPI;
                else if (min > Math.PI)
                    min -= twoPI;
                if (max < -Math.PI)
                    max += twoPI;
                else if (max > Math.PI)
                    max -= twoPI;
                if (min <= max) {
                    spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                }
                else {
                    spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
                }
            }
            // restrict phi to be between desired limits
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
            spherical.makeSafe();
            spherical.radius *= this.scale;
            // restrict radius to be between desired limits
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            // move target to panned location
            if (scope.enableDamping === true) {
                // scope.target.addScaledVector(panOffset, scope.dampingFactor);
                apeng.Vec3.scaleAndAdd(scope.target, scope.target, panOffset, scope.dampingFactor);
            }
            else {
                scope.target.add(panOffset);
            }
            // offset.setFromSpherical(spherical);
            spherical.toVec3(offset);
            // rotate offset back to "camera-up-vector-is-up" space
            // offset.applyQuaternion(quatInverse);
            apeng.Vec3.transformQuat(offset, offset, quatInverse);
            position.set(scope.target).add(offset);
            scope.object.position = position;
            scope.object.lookAt(scope.target);
            if (scope.enableDamping === true) {
                sphericalDelta.theta *= 1 - scope.dampingFactor;
                sphericalDelta.phi *= 1 - scope.dampingFactor;
                panOffset.multiplyScalar(1 - scope.dampingFactor);
            }
            else {
                sphericalDelta.set(0, 0, 0);
                panOffset.set(0, 0, 0);
            }
            this.scale = 1;
            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8
            if (this.zoomChanged || apeng.Vec3.squaredDistance(lastPosition, scope.object.position) > EPS || 8 * (1 - apeng.Quat.dot(lastQuaternion, scope.object.rotation)) > EPS) {
                // scope.dispatchEvent(_changeEvent);
                lastPosition.set(scope.object.position);
                lastQuaternion.set(scope.object.rotation);
                this.zoomChanged = false;
                return true;
            }
            return false;
        }
        update(deltaTime) {
            this.updateObject();
        }
    };
    __decorate([
        apeng.property({ displayName: "目标位置" })
    ], CameraOrbitControlCC.prototype, "target", void 0);
    __decorate([
        apeng.property({ displayName: "放到最大" })
    ], CameraOrbitControlCC.prototype, "minDistance", void 0);
    __decorate([
        apeng.property({ displayName: "最小" })
    ], CameraOrbitControlCC.prototype, "maxDistance", void 0);
    __decorate([
        apeng.property({ displayName: "自动注册手指事件" })
    ], CameraOrbitControlCC.prototype, "isAutoEvent", void 0);
    __decorate([
        apeng.property({ displayName: "自动滚动" })
    ], CameraOrbitControlCC.prototype, "enableDamping", void 0);
    __decorate([
        apeng.property({ displayName: "自动滚动插值" })
    ], CameraOrbitControlCC.prototype, "dampingFactor", void 0);
    CameraOrbitControlCC = __decorate([
        apeng.ccclass("CameraOrbitControlCC"),
        apeng.menuScene("CameraOrbitControlCC")
    ], CameraOrbitControlCC);
    apeng.CameraOrbitControlCC = CameraOrbitControlCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let CameraTouchMoveCC = class CameraTouchMoveCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "摄像机拖动组件 方便测试";
            this.changeZ = true;
            this.speed = 1;
            this.v3_t = new apeng.Vec3();
            this.quat_t = new apeng.Quat();
            this.result = new apeng.Vec3();
        }
        onStageTouchMove(evt) {
            if (!apeng.EventHandlerCC.touchIsMoveRun)
                return;
            let mextX = evt.getDeltaX();
            let mextY = evt.getDeltaY();
            let rotation = this.node.getRotation(this.quat_t);
            if (mextX != 0) {
                apeng.Quat.rotateAround(rotation, rotation, this._getDirection(0, -1, 0), mextX / 5 / 360 * apeng.Maths.PI * this.speed);
            }
            if (mextY != 0) {
                apeng.Quat.rotateAround(rotation, rotation, this._getDirection(1, 0, 0), mextY / 5 / 360 * apeng.Maths.PI * this.speed);
            }
            rotation.getEulerAngles(this.v3_t);
            // 不改变z轴旋转
            this.node.setWorldRotationFromEuler(this.v3_t.x, this.v3_t.y, this.changeZ ? this.v3_t.z : 0);
        }
        _getDirection(x, y, z) {
            this.result.set(x, y, z);
            apeng.Vec3.transformQuat(this.result, this.result, this.node.getRotation());
            return this.result;
        }
    };
    __decorate([
        apeng.property({
            displayName: "改变z轴"
        })
    ], CameraTouchMoveCC.prototype, "changeZ", void 0);
    __decorate([
        apeng.property({
            displayName: "滚动速度"
        })
    ], CameraTouchMoveCC.prototype, "speed", void 0);
    CameraTouchMoveCC = __decorate([
        apeng.ccclass("CameraTouchMoveCC"),
        apeng.menuScene("CameraTouchMoveCC")
    ], CameraTouchMoveCC);
    apeng.CameraTouchMoveCC = CameraTouchMoveCC;
})(apeng || (apeng = {}));
/// <reference path="./../helper/DirectorHelper.ts" />

(function (apeng) {
    let ClickChangeViewCC = class ClickChangeViewCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                CHANGE: "CHANGE",
            };
            this.backupDescribe = "点击切换显示";
            this._index = 0;
            this.otherBtns = null;
            this.onEditorUpdateData = this.updateView;
            /**返回为true时 可正常切换 */
            this.hasChange = null;
        }
        set index(vlaue) {
            if (vlaue == this._index)
                return;
            if (this.hasChange) {
                if (!this.hasChange(vlaue))
                    return;
            }
            this._index = apeng.Maths.clampf(vlaue, 0, Math.max(this.views.children.length, this.btns.children.length) - 1);
            this.updateView();
            this.node.emit(this.EventType.CHANGE, this._index);
        }
        get index() { return this._index; }
        get views() { return this.getChildByCreate("views", null, -1, true); }
        get btns() { return this.otherBtns || this.getChildByCreate("btns", null, -1, true); }
        get curIndexByName() { return this.getIndexByName(this._index); }
        get curBtnIndexByName() { return this.getBtnIndexByName(this._index); }
        onLoad() {
            super.onLoad();
            if (!apeng.EDITOR) {
                for (let node of this.btns.children)
                    apeng.EventHandlerCC.onClick(node, this.onClickChildren, this);
            }
        }
        onEnable() {
            this.btns.active = true;
            super.onEnable();
            this.updateView();
        }
        onDisable() {
            this.btns.active = false;
            super.onDisable();
        }
        onClickChildren(event) {
            let node = event.getCurrentTarget();
            let index = this.btns.children.indexOf(node);
            this.index = index;
        }
        setIndex(index) {
            if (typeof index == "string")
                index = Number(index);
            this.index = index;
        }
        updateView() {
            let node = this.btns;
            for (let i = 0; i < node.children.length; i++) {
                let child = node.children[i];
                if (child) {
                    if (child.children[1])
                        child.children[1].active = i == this._index;
                    if (child.children[0])
                        child.children[0].active = i != this._index;
                }
            }
            node = this.views;
            for (let i = 0; i < node.children.length; i++)
                if (node.children[i])
                    node.children[i].active = i == this._index;
        }
        getBtnIndexByName(index) {
            let node = this.btns.children[index];
            if (node)
                return node.name;
            return "";
        }
        getIndexByName(index) {
            let node = this.views.children[index];
            if (node)
                return node.name;
            return "";
        }
        setIndexByName(name) {
            if (!this.views.children)
                return;
            for (let i = 0; i < this.views.children.length; i++) {
                if (this.views.children[i].name == name)
                    this.index = i;
            }
        }
    };
    __decorate([
        apeng.property({
            step: 1,
            displayName: "显示索引",
        })
    ], ClickChangeViewCC.prototype, "index", null);
    __decorate([
        apeng.property({ serializable: true })
    ], ClickChangeViewCC.prototype, "_index", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "按钮"
        })
    ], ClickChangeViewCC.prototype, "otherBtns", void 0);
    ClickChangeViewCC = __decorate([
        apeng.ccclass("ClickChangeViewCC"),
        apeng.executeInEditMode,
        apeng.menuUI("ClickChangeViewCC")
    ], ClickChangeViewCC);
    apeng.ClickChangeViewCC = ClickChangeViewCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ControllerByChildItem = class ControllerByChildItem {
        constructor() {
            this.controllerName = "";
            this.visible = true;
        }
    };
    __decorate([
        apeng.property({
            readonly: true,
            displayName: "名称"
        })
    ], ControllerByChildItem.prototype, "controllerName", void 0);
    __decorate([
        apeng.property({
            displayName: "显示"
        })
    ], ControllerByChildItem.prototype, "visible", void 0);
    ControllerByChildItem = __decorate([
        apeng.ccclass("ControllerByChildItem")
    ], ControllerByChildItem);
    apeng.ControllerByChildItem = ControllerByChildItem;
    let ControllerByChildCC = class ControllerByChildCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "子控制器";
            this.remove = false;
            this.items = [];
            this._all = false;
            this._noClear = false;
        }
        set all(value) {
            for (let item of this.items)
                item.visible = true;
        }
        get all() { return this._all; }
        set noClear(value) {
            for (let item of this.items)
                item.visible = false;
        }
        get noClear() { return this._noClear; }
        setVisible(controllerName) {
            if (!this.remove)
                this.node.active = apeng.Sets.filterValue(this.items, v => v.controllerName == controllerName).visible;
        }
    };
    __decorate([
        apeng.property({
            displayName: "排除"
        })
    ], ControllerByChildCC.prototype, "remove", void 0);
    __decorate([
        apeng.property({
            readonly: true,
            type: [ControllerByChildItem],
            displayName: "配置"
        })
    ], ControllerByChildCC.prototype, "items", void 0);
    __decorate([
        apeng.property({
            displayName: "全选"
        })
    ], ControllerByChildCC.prototype, "all", null);
    __decorate([
        apeng.property({
            displayName: "清空"
        })
    ], ControllerByChildCC.prototype, "noClear", null);
    __decorate([
        apeng.property({ serializable: true })
    ], ControllerByChildCC.prototype, "_all", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ControllerByChildCC.prototype, "_noClear", void 0);
    ControllerByChildCC = __decorate([
        apeng.ccclass("ControllerByChildCC"),
        apeng.menuController("ControllerByChildCC")
    ], ControllerByChildCC);
    apeng.ControllerByChildCC = ControllerByChildCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ControllerByChildExcludeCC = class ControllerByChildExcludeCC extends _cc_.Component {
        constructor() {
            super(...arguments);
            this.backupDescribe = "控制器排除当前或所有子节点";
            this.remove = true;
        }
    };
    __decorate([
        apeng.property({
            displayName: "排除"
        })
    ], ControllerByChildExcludeCC.prototype, "remove", void 0);
    ControllerByChildExcludeCC = __decorate([
        apeng.ccclass("ControllerByChildExcludeCC"),
        apeng.menuController("ControllerByChildExcludeCC")
    ], ControllerByChildExcludeCC);
    apeng.ControllerByChildExcludeCC = ControllerByChildExcludeCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ControllerCCItem2 = class ControllerCCItem2 {
        constructor() {
            this.controllerName = "";
        }
    };
    __decorate([
        apeng.property({
            displayName: "名称"
        })
    ], ControllerCCItem2.prototype, "controllerName", void 0);
    ControllerCCItem2 = __decorate([
        apeng.ccclass("ControllerCCItem2")
    ], ControllerCCItem2);
    apeng.ControllerCCItem2 = ControllerCCItem2;
    let ControllerCC = class ControllerCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "模拟fgui控制器";
            this.items = [];
            this._index = 0;
            this._itemName = "";
            this.itemNameMap = {};
            this.onEditorUpdateData = this.updateView;
        }
        set index(vlaue) {
            if (vlaue == this._index)
                return;
            this._index = apeng.Maths.clampf(vlaue, 0, this.items.length - 1);
            this._itemName = this.items[this._index].controllerName;
            this.updateView();
        }
        get index() { return this._index; }
        set itemName(vlaue) {
            if (vlaue == this._itemName)
                return;
            this._itemName = vlaue;
            this.setItemName(this._itemName);
        }
        get itemName() { return this._itemName; }
        onEditorClearData() {
            this.walkAllChild(node => {
                let comp = node.getComponent(apeng.ControllerByChildCC);
                if (comp)
                    comp.destroy();
            });
        }
        onLoad() {
            super.onLoad();
            this.updateView();
        }
        setIndex(index) {
            if (typeof index == "string")
                index = Number(index);
            this.index = index;
        }
        setItemName(itemName, defaultIndex = -1) {
            if (this.itemNameMap[itemName] === undefined)
                this.itemNameMap[itemName] = apeng.Sets.filterOf(this.items, v => v.controllerName == itemName);
            if (this.itemNameMap[itemName] != -1)
                this.index = this.itemNameMap[itemName];
            else {
                if (defaultIndex != -1)
                    this.index = defaultIndex;
            }
        }
        updateView() {
            if (!this.items[this._index])
                return;
            let curName = this.items[this._index].controllerName;
            this.walkAllDeepChild(node => {
                if (node.getComponent("ControllerCC"))
                    return 1;
                let exclude = node.getComponent("ControllerByChildExcludeCC");
                if (exclude) {
                    if (exclude.remove)
                        return 1;
                }
                let isRemove = node.getComponent("ListCC")
                    || node.getComponent("CreatePrefabToEditorCC")
                    || node.getComponent("CreatePrefabToEditorOnceCC");
                let comp = node.getComponent(apeng.ControllerByChildCC);
                if (!comp) {
                    // 嵌套预制体添加无效
                    comp = node.addComponent(apeng.ControllerByChildCC);
                    let data = [];
                    for (let item of this.items)
                        data.push(new apeng.ControllerByChildItem());
                    comp.items = data;
                    comp.remove = !!isRemove;
                }
                for (let i = 0; i < this.items.length; i++)
                    comp.items[i].controllerName = this.items[i].controllerName;
                comp.setVisible(curName);
            });
        }
    };
    __decorate([
        apeng.property({
            type: [ControllerCCItem2],
            displayName: "控制器"
        })
    ], ControllerCC.prototype, "items", void 0);
    __decorate([
        apeng.property({
            min: 0,
            step: 1,
            displayName: "显示索引",
            visible() { return this.items.length != 0; }
        })
    ], ControllerCC.prototype, "index", null);
    __decorate([
        apeng.property({ serializable: true })
    ], ControllerCC.prototype, "_index", void 0);
    __decorate([
        apeng.property({
            displayName: "显示名称",
            visible() { return this.items.length != 0; }
        })
    ], ControllerCC.prototype, "itemName", null);
    __decorate([
        apeng.property({ serializable: true })
    ], ControllerCC.prototype, "_itemName", void 0);
    ControllerCC = __decorate([
        apeng.ccclass("ControllerCC"),
        apeng.menuController("ControllerCC")
    ], ControllerCC);
    apeng.ControllerCC = ControllerCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let CreatePrefabToEditorOnceCC = class CreatePrefabToEditorOnceCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.prefabItemDeep = null;
            this.prefabItemByUuid = "";
            this.runClearItem = true;
            this._prefabItem = null;
            this._isPreloadPrefab = false;
            this.isLoadPrefab = false;
            this.loadPrefabUrl = "";
        }
        getPool() { return null; }
        get item() { return this.content.children[0]; }
        set prefabItem(value) {
            if (this._prefabItem == value)
                return;
            this._prefabItem = value;
            this.onEditorUpdateData();
        }
        get prefabItem() { return this._prefabItem || this.prefabItemDeep; }
        set isPreloadPrefab(value) {
            if (this._isPreloadPrefab == value)
                return;
            this._isPreloadPrefab = value;
            this.updatePreloadPrefab();
        }
        get isPreloadPrefab() { return this._isPreloadPrefab; }
        get content() { return this.node; }
        onEditorUpdateData() {
            this.updatePreloadPrefab();
            this.updateItem();
        }
        onEditorClearData() {
            apeng.Sets.forEach(this.content.children, node => {
                node.removeFromParent();
                node.destroy();
            }, true);
        }
        onPreLoad() {
            this.content.layer = this.node.parent.layer;
            if (apeng.EDITOR)
                this.updateItem();
            if (!this.runClearItem)
                this.updateItem();
        }
        updatePreloadPrefab() {
            if (this._isPreloadPrefab) {
                this.prefabItemDeep = this.prefabItem;
            }
            else {
                this.prefabItemDeep = null;
                this.prefabItemByUuid = this.prefabItem ? this.prefabItem._uuid : "";
            }
        }
        /**加载引用的预制体 */
        preloadPrefab(url, updateItem = false, complete) {
            if (url && url != this.loadPrefabUrl) {
                this._prefabItem = null;
                this.isLoadPrefab = false;
                this.loadPrefabUrl = "";
            }
            if (!this.isVisible) {
                if (complete)
                    complete(false);
                return;
            }
            if (this.isLoadPrefab) {
                if (updateItem) {
                    this.removeItem();
                    this.addItem();
                }
                if (complete)
                    complete(true);
                return;
            }
            if (!url)
                url = apeng._resouces.getUuidByUrl(this.prefabItemByUuid);
            apeng._resouces.loadPrefab(url, (res) => {
                this._prefabItem = res;
                this.isLoadPrefab = true;
                this.loadPrefabUrl = url;
                if (!this.isVisible) {
                    if (complete)
                        complete(false);
                    return;
                }
                this.clearCacheComponent();
                if (updateItem) {
                    this.removeItem();
                    this.addItem();
                }
                if (complete)
                    complete(true);
            });
        }
        updateItem() {
            if (!this.prefabItem)
                return;
            apeng.Sets.updateItemCount(1, this.content.children.length, (add) => {
                if (add)
                    this.addItem();
                else
                    this.removeItem();
            });
        }
        addItem() {
            if (!this.prefabItem)
                return null;
            let pool = this.getPool();
            let item = pool ? pool.get(this.loadPrefabUrl || apeng._resouces.getUuidByUrl(this.prefabItemByUuid)) : apeng.instantiate(this.prefabItem);
            apeng.NodeHelper.setHideFlags(item, apeng.CCObject.Flags.HideInHierarchy, apeng.CCObject.Flags.DontSave);
            // 主动赋值 避免延迟加载时未赋值
            item.layer = this.content.layer;
            apeng.NodeHelper.walkAllChild(item, (node) => {
                node.layer = this.content.layer;
                let comp = node.getComponent("BaseComponent");
                if (comp)
                    comp.autoMember();
            });
            this.onAddItem(item);
            return item;
        }
        removeItem(item, destroy = true) {
            if (!this.prefabItem)
                return null;
            if (!item)
                item = this.content.children[this.content.children.length - 1];
            if (item) {
                let pool = this.getPool();
                if (pool)
                    pool.put(item);
                else {
                    item.removeFromParent();
                    if (destroy)
                        item.destroy();
                }
            }
            if (this.onRemoveItem)
                this.onRemoveItem();
        }
        getPrefabUuidByUrl() { return apeng._resouces.getUuidByUrl(this.prefabItemByUuid); }
        removeAll() {
            apeng.Sets.forEach(this.content.children, (item) => {
                this.removeItem(item);
            }, true);
        }
        /**创建item 添加到节点前时 */
        onAddItem(item) {
            this.content.addChild(item);
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Prefab,
            displayName: "子预制体"
        })
    ], CreatePrefabToEditorOnceCC.prototype, "prefabItem", null);
    __decorate([
        apeng.property({
            readonly: true,
            type: apeng.Prefab,
            displayName: "引用预制体 方便绑定加载",
            visible() { return true; },
        })
    ], CreatePrefabToEditorOnceCC.prototype, "prefabItemDeep", void 0);
    __decorate([
        apeng.property({
            displayName: "绑定加载预制体",
            visible() { return !!this._prefabItem; },
        })
    ], CreatePrefabToEditorOnceCC.prototype, "isPreloadPrefab", null);
    __decorate([
        apeng.property({
            readonly: true,
            displayName: "预制体uuid",
            visible() { return this._prefabItem && !this._isPreloadPrefab; },
        })
    ], CreatePrefabToEditorOnceCC.prototype, "prefabItemByUuid", void 0);
    __decorate([
        apeng.property({
            displayName: "运行时清空"
        })
    ], CreatePrefabToEditorOnceCC.prototype, "runClearItem", void 0);
    __decorate([
        apeng.property({ serializable: true, editorOnly: true })
    ], CreatePrefabToEditorOnceCC.prototype, "_prefabItem", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], CreatePrefabToEditorOnceCC.prototype, "_isPreloadPrefab", void 0);
    CreatePrefabToEditorOnceCC = __decorate([
        apeng.ccclass("CreatePrefabToEditorOnceCC"),
        apeng.executeInEditMode,
        apeng.menuUI("CreatePrefabToEditorOnceCC")
    ], CreatePrefabToEditorOnceCC);
    apeng.CreatePrefabToEditorOnceCC = CreatePrefabToEditorOnceCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
    const OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
    const EPSILON = 1e-4;
    const TOLERANCE = 1e4;
    const MOVEMENT_FACTOR = 0.7;
    const _tempVec3 = new apeng.Vec3();
    const _tempVec3_1 = new apeng.Vec3();
    const _tempVec2 = new apeng.Vec2();
    const _tempVec2_1 = new apeng.Vec2();
    const _tempVec2_2 = new apeng.Vec2();
    const _tempVec2_3 = new apeng.Vec2();
    const v2T = new apeng.Vector2();
    const v2T2 = new apeng.Vector2();
    const v3T = new apeng.Vec3();
    const v3T2 = new apeng.Vec3();
    const v3T3 = new apeng.Vec3();
    const quintEaseOut = (time) => {
        time -= 1;
        return (time * time * time * time * time + 1);
    };
    let DragViewCC = class DragViewCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "拖拽视图";
            this.content = null;
            this.dragReverse = true;
            this.brake = 0.5;
            this.scaleViewMin = .5;
            this.scaleCamera = null;
            this.isAutoEvent = true;
            this.lerpTouchDelay = 2;
            this._autoScrolling = false;
            this._topBoundary = 0;
            this._bottomBoundary = 0;
            this._leftBoundary = 0;
            this._rightBoundary = 0;
            this._touchMoveDisplacements = [];
            this._touchMoveTimeDeltas = [];
            this._touchMovePreviousTimestamp = 0;
            this._touchMoved = false;
            this._autoScrollAttenuate = false;
            this._autoScrollStartPosition = new apeng.Vec3();
            this._autoScrollTargetDelta = new apeng.Vec3();
            this._autoScrollTotalTime = 0;
            this._autoScrollAccumulatedTime = 0;
            this._autoScrollCurrentlyOutOfBoundary = false;
            this._autoScrollBraking = false;
            this._autoScrollBrakingStartPosition = new apeng.Vec3();
            this._outOfBoundaryAmount = new apeng.Vec3();
            this._outOfBoundaryAmountDirty = true;
            this._stopMouseWheel = false;
            this._mouseWheelEventElapsedTime = 0.0;
            this._isScrollEndedWithThresholdEventFired = false;
            this._deltaPos = new apeng.Vec3();
            this._orginCameraOrthoheight = -1;
            this._orginContentSize = new apeng.Size();
            this._scaleCameraRatio = new apeng.Size();
            this._scaleAdd = 1;
            this._scaleCheckBoundary = false;
            this.isTouchStart = false;
            this.isTouchStartDealy = false;
            this.scaleMax = 1;
            this._scaleToLerpSpeed = -1;
            this._scaleToRatio = -1;
            this._scaleToMinRatio = .001;
            this._scaleToStart = false;
            this.onSizeChange = this._calculateBoundary;
        }
        get scaleRatio() { return this._scaleAdd; }
        get contentUITransform() {
            if (!this.content)
                return null;
            return apeng.NodeHelper.getUITransform(this.content);
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR)
                return;
            if (this.isAutoEvent) {
                this.addEvent(apeng.Node.EventType.TOUCH_START, this._onTouchBegan, this, this.node, true);
                this.addEvent(apeng.Node.EventType.TOUCH_END, this._onTouchEnded, this, this.node, true);
                this.addEvent(apeng.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, this.node, true);
                this.addEvent(apeng.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, this.node, true);
                this.addEvent(apeng.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, this.node, true);
            }
            this._calculateBoundary();
            if (this.scaleCamera)
                this._orginCameraOrthoheight = this.scaleCamera.orthoHeight;
            let size = apeng.winSize();
            this._scaleCameraRatio.width = size.width / this._orginCameraOrthoheight;
            this._scaleCameraRatio.height = size.height / this._orginCameraOrthoheight;
            if (this.content)
                this.updateContentSize(this.contentUITransform.contentSize);
        }
        updateContentSize(_size) {
            let size = apeng.winSize();
            this._orginContentSize.width = _size.width;
            this._orginContentSize.height = _size.height;
            this.scaleMax = Math.max(1, Math.min(this._orginContentSize.height / size.height, this._orginContentSize.width / size.width));
        }
        onUpdate() {
            if (this._autoScrolling)
                this._processAutoScrolling(apeng._timer.dtDefault);
            if (this._scaleToStart) {
                this._scaleAdd = apeng.Maths.lerp(this._scaleAdd, this._scaleToRatio, this._scaleToLerpSpeed * apeng._timer.dtSecond);
                if (Math.abs(this._scaleToRatio - this._scaleAdd) < this._scaleToMinRatio) {
                    this._scaleAdd = this._scaleToRatio;
                    this._scaleToStart = false;
                    console.log("缩放动画完成");
                }
                this.scaleView(false, this._scaleCheckBoundary);
            }
        }
        onDisable() {
            super.onDisable();
            this.isTouchStart = false;
            this._autoScrolling = false;
            this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }
        getScaleToByRatio() {
            return (this._scaleAdd - this.scaleViewMin) / (this.scaleMax - this.scaleViewMin);
        }
        scaleTo(lerpSpeed, toRatio, _scaleCheckBoundary = true, minRatio = .001) {
            this._scaleCheckBoundary = _scaleCheckBoundary;
            this._scaleToStart = true;
            this._scaleToLerpSpeed = lerpSpeed;
            this._scaleToMinRatio = minRatio;
            this._scaleToRatio = apeng.Maths.lerp(this.scaleViewMin, this.scaleMax, toRatio);
        }
        scaleTo2(ratio) {
            this._scaleAdd = apeng.Maths.lerp(this.scaleViewMin, this.scaleMax, ratio);
            this.scaleView(false, false);
        }
        _onMouseWheel(event, captureListeners) {
            if (!this.enabledInHierarchy)
                return;
            if (this._hasNestedViewGroup(event, captureListeners))
                return;
            this._scaleToStart = false;
            this._scaleAdd = this._scaleAdd + ((event.getScrollY() < 0) ? .1 : -.1);
            this.scaleView(false);
            this._mouseWheelEventElapsedTime = 0;
            if (!this._stopMouseWheel) {
                this._handlePressLogic();
                this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
                this._stopMouseWheel = true;
            }
            this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchBegan(event, captureListeners) {
            if (!this.enabledInHierarchy || !this.content)
                return;
            if (this._hasNestedViewGroup(event, captureListeners))
                return;
            this._scaleToStart = false;
            this._handlePressLogic();
            this._touchMoved = false;
            this._stopPropagationIfTargetIsMe(event);
            this.isTouchStart = true;
            this.isTouchStartDealy = true;
            this.unschedule(this._touchEndDelay);
        }
        _onTouchMoved(event, captureListeners) {
            if (!this.enabledInHierarchy || !this.content)
                return;
            if (this._hasNestedViewGroup(event, captureListeners))
                return;
            let touches = event.getTouches();
            if (touches.length >= 2) {
                let touch1 = touches[0], touch2 = touches[1];
                touch1.getLocation(_tempVec2);
                touch2.getLocation(_tempVec2_1);
                apeng.Vector2.sub(_tempVec2_2, _tempVec2, _tempVec2_1);
                touch1.getDelta(_tempVec2);
                touch2.getDelta(_tempVec2_1);
                apeng.Vector2.sub(_tempVec2_3, _tempVec2, _tempVec2_1);
                if (Math.abs(_tempVec2_2.x) > Math.abs(_tempVec2_2.y))
                    this._scaleAdd = (_tempVec2_2.x + _tempVec2_3.x) / _tempVec2_2.x * this._scaleAdd;
                else
                    this._scaleAdd = (_tempVec2_2.y + _tempVec2_3.y) / _tempVec2_2.y * this._scaleAdd;
                this.scaleView(true);
                this._touchMoved = true;
            }
            else {
                const touch = event.touch;
                this._getLocalAxisAlignDelta(this._deltaPos, touch);
                this._processDeltaMove(this._deltaPos);
                // touch.getUIStartLocation(_tempVec2_1)
                // touch.getUILocation(_tempVec2)
                // _tempVec2.subtract(_tempVec2_1)
                // if (_tempVec2.length() > 7)
                // 	if (!this._touchMoved && event.target !== this.node) {
                // 		const cancelEvent = new EventTouch(event.getTouches(), event.bubbles, Input.EventType.TOUCH_CANCEL)
                // 		cancelEvent.touch = event.touch
                // 		cancelEvent.simulate = true;
                // 		(event.target as _cc_.Node).dispatchEvent(cancelEvent)
                // 		this._touchMoved = true
                // 	}
            }
            this._stopPropagationIfTargetIsMe(event);
        }
        /**
         * 缩放
         * @param offsetRatio
         * @param reverse 比率取反
         */
        scaleView(reverse, checkBoundary = true) {
            if (!this.scaleCamera || !this.content)
                return;
            let max = this.scaleMax;
            let scaleAdd = this._scaleAdd = apeng.Maths.clampf(this._scaleAdd, this.scaleViewMin, max);
            if (reverse)
                scaleAdd = max - scaleAdd + this.scaleViewMin;
            this.scaleCamera.orthoHeight = scaleAdd * this._orginCameraOrthoheight;
            let ratio = this._orginCameraOrthoheight - scaleAdd * this._orginCameraOrthoheight;
            apeng.NodeHelper.setSize(this.content, this._orginContentSize.width + this._scaleCameraRatio.width * ratio, this._orginContentSize.height + this._scaleCameraRatio.height * ratio);
            if (checkBoundary)
                this._calculateBoundary();
        }
        _onTouchEnded(event, captureListeners) {
            if (!this.enabledInHierarchy || !this.content || !event)
                return;
            if (this._hasNestedViewGroup(event, captureListeners))
                return;
            const touch = event.touch;
            this._handleReleaseLogic(touch);
            if (this._touchMoved)
                event.propagationStopped = true;
            else
                this._stopPropagationIfTargetIsMe(event);
            this._touchEnd();
        }
        _onTouchCancelled(event, captureListeners) {
            if (!this.enabledInHierarchy || !this.content)
                return;
            if (this._hasNestedViewGroup(event, captureListeners))
                return;
            this._touchEnd();
            if (event && !event.simulate) {
                const touch = event.touch;
                this._handleReleaseLogic(touch);
            }
            this._stopPropagationIfTargetIsMe(event);
        }
        _touchEnd() {
            this.isTouchStart = false;
            this.scheduleOnceCover(this._touchEndDelay, this.lerpTouchDelay);
        }
        _touchEndDelay() {
            this.isTouchStartDealy = false;
        }
        _calculateBoundary() {
            if (!this.content)
                return;
            let contentParent = this.content.parent;
            if (!contentParent)
                return;
            const viewTrans = apeng.NodeHelper.getUITransform(contentParent);
            const anchorX = viewTrans.width * viewTrans.anchorX;
            const anchorY = viewTrans.height * viewTrans.anchorY;
            this._leftBoundary = -anchorX;
            this._bottomBoundary = -anchorY;
            this._rightBoundary = this._leftBoundary + viewTrans.width;
            this._topBoundary = this._bottomBoundary + viewTrans.height;
            let scrollViewSize = viewTrans.contentSize;
            let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDelta = -bottomDelta;
            let totalScrollDelta = 0;
            let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDelta = -leftDelta;
            // 是否限制在上视区上边
            const uiTrans = this.contentUITransform;
            const contentSize = uiTrans.contentSize;
            if (contentSize.height < scrollViewSize.height) {
                totalScrollDelta = contentSize.height - scrollViewSize.height;
                v3T.y = bottomDelta - totalScrollDelta;
            }
            else
                v3T.y = 0;
            // 是否限制在上视区左边
            if (contentSize.width < scrollViewSize.width) {
                totalScrollDelta = contentSize.width - scrollViewSize.width;
                v2T.x = leftDelta;
            }
            else
                v3T.x = 0;
            v3T.z = 0;
            this._moveContent(v3T);
            this._outOfBoundaryAmountDirty = true;
            if (this._isOutOfBoundary()) {
                _tempVec3.set(this.content.position);
                _tempVec3.add(this._getHowMuchOutOfBoundary(v3T));
                this.setContentPosition(_tempVec3);
            }
        }
        setContentPosition(position) {
            this.content.setPosition(position);
        }
        _hasNestedViewGroup(event, captureListeners) {
            if (!event || event.eventPhase !== Event.CAPTURING_PHASE)
                return false;
            if (captureListeners) {
                for (const listener of captureListeners) {
                    const item = listener;
                    if (this.node === item) {
                        if (event.target && event.target.getComponent(apeng.ViewGroup))
                            return true;
                        return false;
                    }
                    if (item.getComponent(apeng.ViewGroup))
                        return true;
                }
            }
            return false;
        }
        _calculateAttenuatedFactor(distance) {
            if (this.brake <= 0)
                return (1 - this.brake);
            return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
        }
        _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
            let len = initialVelocity.length();
            v3T2.set(deltaMove);
            apeng.Vector3.normalize(v3T, v3T2);
            if (this.content && this.content.parent) {
                const contentSize = this.contentUITransform.contentSize;
                const scrollViewSize = apeng.NodeHelper.getUITransform(this.content.parent).contentSize;
                const totalMoveWidth = (contentSize.width - scrollViewSize.width);
                const totalMoveHeight = (contentSize.height - scrollViewSize.height);
                const attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
                const attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
                v3T.x = v3T.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
                v3T.y = v3T.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
                v3T.z = 0;
            }
            const originalMoveLength = v3T2.length();
            let factor = v3T.length() / originalMoveLength;
            v3T.add(v3T2);
            if (this.brake > 0 && factor > 7) {
                factor = Math.sqrt(factor);
                apeng.Vector3.mul(v3T, v3T2, factor);
                v3T.add(v3T2);
            }
            let time = Math.sqrt(Math.sqrt(len / 5));
            if (this.brake > 0 && factor > 3) {
                factor = 3;
                time *= factor;
            }
            if (this.brake === 0 && factor > 1)
                time *= factor;
            this._autoScrolling = true;
            this._autoScrollTargetDelta.set(v3T);
            this._autoScrollAttenuate = true;
            apeng.Vec3.copy(this._autoScrollStartPosition, this.content.position);
            this._autoScrollTotalTime = time;
            this._autoScrollAccumulatedTime = 0;
            this._autoScrollBraking = false;
            this._isScrollEndedWithThresholdEventFired = false;
            this._autoScrollBrakingStartPosition.set(0, 0, 0);
            if (!this._getHowMuchOutOfBoundary(v3T).equals(apeng.Vec3.ZERO, EPSILON))
                this._autoScrollCurrentlyOutOfBoundary = true;
        }
        _moveContent(deltaMove) {
            _tempVec3.set(this.content.position);
            _tempVec3.add(deltaMove);
            _tempVec3.set(Math.round(_tempVec3.x * TOLERANCE) * EPSILON, Math.round(_tempVec3.y * TOLERANCE) * EPSILON, _tempVec3.z);
            if (this.content) {
                const contentPos = this.content.position;
                if (!(Math.abs(_tempVec3.x - contentPos.x) < EPSILON && Math.abs(_tempVec3.y - contentPos.y) < EPSILON)) {
                    this.setContentPosition(_tempVec3);
                    this._outOfBoundaryAmountDirty = true;
                }
            }
        }
        _getContentLeftBoundary() {
            if (!this.content)
                return -1;
            const uiTrans = this.contentUITransform;
            return this.content.position.x - uiTrans.anchorX * uiTrans.width;
        }
        _getContentRightBoundary() {
            if (!this.content)
                return -1;
            const uiTrans = this.contentUITransform;
            return this._getContentLeftBoundary() + uiTrans.width;
        }
        _getContentTopBoundary() {
            if (!this.content)
                return -1;
            const uiTrans = this.contentUITransform;
            return this._getContentBottomBoundary() + uiTrans.height;
        }
        _getContentBottomBoundary() {
            if (!this.content)
                return -1;
            const uiTrans = this.contentUITransform;
            return this.content.position.y - uiTrans.anchorY * uiTrans.height;
        }
        _getHowMuchOutOfBoundary(out, addition) {
            addition = addition || apeng.Vec3.ZERO;
            if (addition.equals(apeng.Vec3.ZERO, EPSILON) && !this._outOfBoundaryAmountDirty)
                return this._outOfBoundaryAmount;
            const tempLeftBoundary = this._getContentLeftBoundary();
            const tempRightBoundary = this._getContentRightBoundary();
            if (tempLeftBoundary + addition.x > this._leftBoundary)
                out.x = this._leftBoundary - (tempLeftBoundary + addition.x);
            else if (tempRightBoundary + addition.x < this._rightBoundary)
                out.x = this._rightBoundary - (tempRightBoundary + addition.x);
            else
                out.x = 0;
            const tempTopBoundary = this._getContentTopBoundary();
            const tempBottomBoundary = this._getContentBottomBoundary();
            if (tempTopBoundary + addition.y < this._topBoundary)
                out.y = this._topBoundary - (tempTopBoundary + addition.y);
            else if (tempBottomBoundary + addition.y > this._bottomBoundary)
                out.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
            else
                out.y = 0;
            out.z = 0;
            if (addition.equals(apeng.Vec3.ZERO, EPSILON)) {
                this._outOfBoundaryAmount.set(out);
                this._outOfBoundaryAmountDirty = false;
            }
            this._clampDelta(out);
            return out;
        }
        _stopPropagationIfTargetIsMe(event) {
            if (event.eventPhase === Event.AT_TARGET && event.target === this.node)
                event.propagationStopped = true;
        }
        /**强制打开插值动画 */
        openLerp() {
            this._touchEndDelay();
            this.unschedule(this._touchEndDelay);
            this._autoScrolling = false;
        }
        /**
         * 插值到目标
         * @param target 左下脚原点
         * @param ratio
         */
        lerpMove(target, ratio, checkScaleTo = true, minRatio = .01) {
            if (this._autoScrolling
                || this.isTouchStart
                || this.isTouchStartDealy)
                return false;
            if (checkScaleTo)
                if (this._scaleToStart)
                    return false;
            let contentPos = this.content.position;
            if (apeng.Vector2.equals(target, contentPos, minRatio))
                return true;
            apeng.Vector2.lerp(v2T, contentPos, target, ratio * apeng._timer.dtSecond);
            apeng.Vector2.sub(v3T3, v2T, contentPos);
            let isEnd = false;
            if (v3T3.length() < minRatio) {
                apeng.Vector2.sub(v3T3, target, contentPos);
                isEnd = true;
            }
            v3T3.z = 0;
            this._processDeltaMove(v3T3, false);
            return isEnd;
        }
        _processDeltaMove(deltaMove, touch = true) {
            this._clampDelta(deltaMove);
            this._getHowMuchOutOfBoundary(v3T, deltaMove);
            deltaMove.add(v3T);
            this._moveContent(deltaMove);
            if (touch)
                this._gatherTouchMove(deltaMove);
        }
        _handleReleaseLogic(touch) {
            this._getLocalAxisAlignDelta(this._deltaPos, touch);
            this._gatherTouchMove(this._deltaPos);
            this._processInertiaScroll();
        }
        _getLocalAxisAlignDelta(out, touch) {
            const uiTransformComp = this.UITransform;
            touch.getUILocation(_tempVec2);
            touch.getUIPreviousLocation(_tempVec2_1);
            if (this.dragReverse) {
                _tempVec2.multiplyScalar(-1);
                _tempVec2_1.multiplyScalar(-1);
            }
            _tempVec3.set(_tempVec2.x, _tempVec2.y, 0);
            _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3, _tempVec3);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
            apeng.Vec3.subtract(out, _tempVec3, _tempVec3_1);
        }
        _handlePressLogic() {
            this._autoScrolling = false;
            this._touchMovePreviousTimestamp = new Date().getMilliseconds();
            for (let v of this._touchMoveDisplacements)
                apeng.Vector3.pool.put(v);
            this._touchMoveDisplacements.length = 0;
            this._touchMoveTimeDeltas.length = 0;
        }
        _clampDelta(out) {
            if (this.content && this.content.parent) {
                const scrollViewSize = apeng.NodeHelper.getUITransform(this.content.parent).contentSize;
                const uiTrans = this.contentUITransform;
                if (uiTrans.width < scrollViewSize.width)
                    out.x = 0;
                if (uiTrans.height < scrollViewSize.height)
                    out.y = 0;
            }
        }
        _gatherTouchMove(delta) {
            const clampDt = apeng.Vector3.pool.get().set(delta);
            this._clampDelta(clampDt);
            while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                let v = this._touchMoveDisplacements.shift();
                if (v)
                    apeng.Vector3.pool.put(v);
                this._touchMoveTimeDeltas.shift();
            }
            this._touchMoveDisplacements.push(clampDt);
            const timeStamp = new Date().getMilliseconds();
            this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);
            this._touchMovePreviousTimestamp = timeStamp;
        }
        _processInertiaScroll() {
            let totalTime = apeng.Maths.arrAdd(this._touchMoveTimeDeltas);
            if (totalTime <= 0 || totalTime >= 0.5)
                v3T.set();
            else {
                v3T2.set();
                for (let v of this._touchMoveDisplacements)
                    apeng.Vector3.add(v3T2, v3T2, v);
                v3T.set(v3T2.x * (1 - this.brake) / totalTime, v3T2.y * (1 - this.brake) / totalTime, v3T2.z);
            }
            if (!v3T.equals(apeng.Vec3.ZERO, EPSILON) && this.brake < 1) {
                apeng.Vector3.mul(v3T2, v3T, MOVEMENT_FACTOR);
                this._startAttenuatingAutoScroll(v3T2, v3T);
            }
        }
        _isOutOfBoundary() {
            return !this._getHowMuchOutOfBoundary(v3T).equals(apeng.Vec3.ZERO, EPSILON);
        }
        _isNecessaryAutoScrollBrake() {
            if (this._autoScrollBraking)
                return true;
            if (this._isOutOfBoundary()) {
                if (!this._autoScrollCurrentlyOutOfBoundary) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    this._autoScrollBraking = true;
                    this._autoScrollBrakingStartPosition.set(this.content.position);
                    return true;
                }
            }
            else
                this._autoScrollCurrentlyOutOfBoundary = false;
            return false;
        }
        _processAutoScrolling(dt) {
            const brakingFactor = this._isNecessaryAutoScrollBrake() ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
            this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
            let percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
            if (this._autoScrollAttenuate)
                percentage = quintEaseOut(percentage);
            apeng.Vector3.mul(v3T3, this._autoScrollTargetDelta, percentage);
            v3T3.add(this._autoScrollStartPosition);
            let reachedEnd = Math.abs(percentage - 1) <= EPSILON;
            const fireEvent = Math.abs(percentage - 1) <= EPSILON;
            if (fireEvent && !this._isScrollEndedWithThresholdEventFired)
                this._isScrollEndedWithThresholdEventFired = true;
            v3T.set(v3T3);
            v3T.subtract(this.content.position);
            this._getHowMuchOutOfBoundary(v3T2, v3T);
            if (!v3T2.equals(apeng.Vec3.ZERO, EPSILON)) {
                v3T3.add(v3T2);
                reachedEnd = true;
            }
            if (reachedEnd)
                this._autoScrolling = false;
            v3T3.subtract(this.content.position);
            this._clampDelta(v3T3);
            this._moveContent(v3T3);
        }
        _checkMouseWheel(dt) {
            const maxElapsedTime = 0.1;
            if (!this._getHowMuchOutOfBoundary(v3T).equals(apeng.Vec3.ZERO, EPSILON)) {
                this._processInertiaScroll();
                this.unschedule(this._checkMouseWheel);
                this._stopMouseWheel = false;
                return;
            }
            this._mouseWheelEventElapsedTime += dt;
            if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
                this.unschedule(this._checkMouseWheel);
                this._stopMouseWheel = false;
            }
        }
        _calculateMovePercentDelta(anchor, applyToHorizontal, applyToVertical, out) {
            this._calculateBoundary();
            let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDelta = -bottomDelta;
            let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDelta = -leftDelta;
            if (this.content && this.content.parent) {
                let totalScrollDelta = 0;
                const uiTrans = apeng.NodeHelper.getUITransform(this.content);
                const contentSize = uiTrans.contentSize;
                const scrollSize = apeng.NodeHelper.getUITransform(this.content.parent).contentSize;
                if (applyToHorizontal) {
                    totalScrollDelta = contentSize.width - scrollSize.width;
                    out.x = leftDelta - totalScrollDelta * apeng.Maths.clamp01(anchor.x);
                }
                if (applyToVertical) {
                    totalScrollDelta = contentSize.height - scrollSize.height;
                    out.y = bottomDelta - totalScrollDelta * apeng.Maths.clamp01(anchor.y);
                }
            }
            return out;
        }
        /**
         * 移动到指定位置
         * @param target 容器下的坐标
         * @param duration
         */
        moveTo(target, duration) {
            v2T.x = (this.UITransform.width * this.UITransform.anchorX - target.x) / this.UITransform.width;
            v2T.y = (this.UITransform.height * this.UITransform.anchorY - target.y) / this.UITransform.height;
            // console.log("v2T+++++++++%o",v2T)
            this._calculateMovePercentDelta(v2T, true, true, v3T3);
            this._startAutoScroll(v3T3, duration, true);
        }
        _startAutoScroll(deltaMove, duration, attenuated) {
            this._autoScrolling = true;
            this._autoScrollTargetDelta.set(deltaMove);
            this._autoScrollAttenuate = attenuated;
            apeng.Vec3.copy(this._autoScrollStartPosition, this.content.position);
            this._autoScrollTotalTime = duration;
            this._autoScrollAccumulatedTime = 0;
            this._autoScrollBraking = false;
            this._isScrollEndedWithThresholdEventFired = false;
            this._autoScrollBrakingStartPosition.set(0, 0, 0);
            if (!this._getHowMuchOutOfBoundary(v3T).equals(apeng.Vec3.ZERO, EPSILON))
                this._autoScrollCurrentlyOutOfBoundary = true;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "可滚动展示内容的节点"
        })
    ], DragViewCC.prototype, "content", void 0);
    __decorate([
        apeng.property({
            displayName: "拖动方向取反"
        })
    ], DragViewCC.prototype, "dragReverse", void 0);
    __decorate([
        apeng.property({
            range: [0, 1, 0.1],
            displayName: "惯性滑动比率",
        })
    ], DragViewCC.prototype, "brake", void 0);
    __decorate([
        apeng.property({
            displayName: "最小缩放"
        })
    ], DragViewCC.prototype, "scaleViewMin", void 0);
    __decorate([
        apeng.property({
            type: apeng.Camera,
            displayName: "缩放摄像机"
        })
    ], DragViewCC.prototype, "scaleCamera", void 0);
    __decorate([
        apeng.property({
            displayName: "自动注册手指事件"
        })
    ], DragViewCC.prototype, "isAutoEvent", void 0);
    __decorate([
        apeng.property({
            displayName: "插值触摸延迟"
        })
    ], DragViewCC.prototype, "lerpTouchDelay", void 0);
    DragViewCC = __decorate([
        apeng.ccclass("DragViewCC"),
        apeng.menuUI("DragViewCC"),
        apeng.requireComponent(apeng.UITransform)
    ], DragViewCC);
    apeng.DragViewCC = DragViewCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let armatureDisplay = apeng.dragonBones ? apeng.dragonBones.ArmatureDisplay : apeng.Asset;
    let DragonBonesCC = class DragonBonesCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                PLAY: "PLAY"
            };
            this.backupDescribe = "龙骨组件";
            this.anim = null;
            this.crossFade = 0;
            this.curPlayAnimName = "";
            this.curPlayTimes = -1;
            this.curState = null;
            this.lastPlayAnim = "";
            this.curPlayAnimNameCb = null;
            this.hasPlay = null;
            this.initTimeScale = 1;
            this.playing = {};
        }
        onLoad() {
            super.onLoad();
            // 自动添加组件
            if (apeng.EDITOR) {
                if (!this.anim)
                    this.anim = this.getComponent(apeng.dragonBones.ArmatureDisplay);
                return;
            }
            if (!this.anim)
                return;
            this.addEvent(apeng.dragonBones.EventObject.COMPLETE, this.onEventAnimComplete, this, this.anim);
            this.initTimeScale = this.anim.timeScale;
        }
        onDisable() {
            this.curPlayAnimName = "";
            this.lastPlayAnim = "";
            this.curState = null;
            this.curPlayAnimNameCb = null;
            super.onDisable();
        }
        onEventAnimComplete(event) {
            if (event.animationState.name != this.curPlayAnimName)
                return;
            this.playing[this.curPlayAnimName] = false;
            if (this.curPlayAnimNameCb) {
                this.curPlayAnimNameCb();
                this.curPlayAnimNameCb = null;
            }
        }
        /**暂停动画 */
        pause() {
            if (!this.anim)
                return;
            this.anim.timeScale = 0;
        }
        resume() {
            if (!this.anim)
                return;
            this.anim.timeScale = this.initTimeScale;
        }
        /**
         * 播放龙骨
         * @param animName 播放的名称
         * @param playTimes 播放次数 0循环
         * @param cb
         * @returns
         */
        play(animName, playTimes = 0, cb, checkCur = true) {
            if (!this.anim)
                return;
            if (!animName)
                return;
            if (checkCur)
                if (this.curPlayAnimName == animName)
                    return;
            if (this.hasPlay)
                if (this.hasPlay(animName))
                    return;
            if (this.curPlayAnimName)
                this.lastPlayAnim = this.curPlayAnimName;
            this.curPlayAnimName = animName;
            this.curPlayTimes = playTimes;
            this.curPlayAnimNameCb = cb;
            this.playing[animName] = true;
            this.curState = this.anim.playAnimation(animName, playTimes);
            if (this.curState)
                if (this.crossFade > 0)
                    this.curState.autoFadeOutTime = this.crossFade;
            this.node.emit(this.EventType.PLAY);
        }
        playDefault(playTimes, cb, checkCur = true) {
            if (!this.anim)
                return;
            let names = this.anim.getAnimationNames(this.anim.armatureName);
            if (names[0])
                this.play(names[0], playTimes, cb, checkCur);
        }
        /**当前动画是否播放完毕  安卓端无效*/
        // public hasPlayComplete(animName: string = ""): boolean {
        //     if (!this.curState)
        //         return true
        //     if (animName && this.curState.name != animName)
        //         return true
        //     return this.curState.isCompleted
        // }
        hasPlaying(animName) {
            return this.playing[animName] || false;
        }
        getState(animName) {
            if (!this.anim)
                return null;
            return this.anim.armature().animation.getState(animName);
        }
        /**切换动画状态 */
        changeState(animName, playTimes) {
            if (this.curPlayAnimName == animName)
                return;
            this.play(animName, playTimes);
        }
        getCurPlayTime() {
            var _a;
            return (_a = this.getState(this.curPlayAnimName)) === null || _a === void 0 ? void 0 : _a.currentTime;
        }
        duration(animName) {
            if (!this.anim)
                return 0;
            return this.anim.armature().animation.animations[animName].duration;
        }
        animNames() {
            if (!this.anim)
                return [];
            return this.anim.armature().animation.animationNames;
        }
        setCurrentTime(animName, currentTime, playTimes) {
            this.play(animName, playTimes);
            this.getState(animName).currentTime = currentTime;
        }
    };
    __decorate([
        apeng.property({
            type: armatureDisplay,
            displayName: "动画组件",
        })
    ], DragonBonesCC.prototype, "anim", void 0);
    __decorate([
        apeng.property({
            displayName: "过渡时间"
        })
    ], DragonBonesCC.prototype, "crossFade", void 0);
    DragonBonesCC = __decorate([
        apeng.ccclass("DragonBonesCC"),
        apeng.executeInEditMode,
        apeng.menuAnim("DragonBonesCC")
    ], DragonBonesCC);
    apeng.DragonBonesCC = DragonBonesCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let CCFontItem = class CCFontItem {
        constructor() {
            this.string = "";
            this.offsetHight = 0;
            this.offsetWidth = 0;
            this._sf = null;
        }
        set sf(value) {
            if (!value)
                return;
            if (!(value instanceof apeng.SpriteFrame))
                return;
            this._sf = value;
            if (!this.string && this._sf.name && this._sf.name.length > 0)
                this.string = this._sf.name[this._sf.name.length - 1];
        }
        get sf() { return this._sf; }
        get width() {
            return this.sf.originalSize.width;
        }
        get height() {
            return this.sf.originalSize.height;
        }
    };
    __decorate([
        apeng.property({
            displayName: "字符",
        })
    ], CCFontItem.prototype, "string", void 0);
    __decorate([
        apeng.property({
            type: apeng.SpriteFrame,
            displayName: "图片",
        })
    ], CCFontItem.prototype, "sf", null);
    __decorate([
        apeng.property({
            displayName: "上下偏移",
        })
    ], CCFontItem.prototype, "offsetHight", void 0);
    __decorate([
        apeng.property({
            displayName: "左右偏移",
        })
    ], CCFontItem.prototype, "offsetWidth", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], CCFontItem.prototype, "_sf", void 0);
    CCFontItem = __decorate([
        apeng.ccclass("CCFontItem")
    ], CCFontItem);
    apeng.CCFontItem = CCFontItem;
    let FontCC = class FontCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "字体组件";
            this.Pool = new apeng.PoolOnce(30, () => {
                let node = new apeng.Node("PrivateNode");
                node.hideFlags |= apeng.CCObject.Flags.HideInHierarchy | apeng.CCObject.Flags.DontSave;
                node.layer = this.node.layer;
                node.addComponent(apeng.UITransform);
                node.addComponent(apeng.Sprite);
                return node;
            }, (data) => data.removeFromParent(), (data) => data.destroy());
            this.items = [];
            this._isBold = false;
            this._isGray = false;
            this._string = "";
            this._space = 0;
            this._color = new apeng.Color(255, 255, 255);
            this.itemsByStringMap = null;
            this.onEditorUpdateData = this.updateView;
        }
        set space(value) {
            if (this._space == value)
                return;
            this._space = value;
            this.updateView();
        }
        get space() {
            return this._space;
        }
        set string(value) {
            if (this._string == value)
                return;
            this._string = value;
            this.updateView();
            this.scheduleOnceCover(this.updateView);
        }
        get string() {
            return this._string;
        }
        set color(value) {
            if (this._color.equals(value))
                return;
            this._color.set(value);
            this.updateView();
        }
        get color() {
            return this._color;
        }
        set isGray(value) {
            if (this._isGray == value)
                return;
            this._isGray = value;
            this.updateView();
        }
        get isGray() { return this._isGray; }
        get isBold() { return this._isBold; }
        set isBold(value) {
            if (this._isBold === value)
                return;
            this._isBold = value;
            this.updateView();
        }
        onEditorClearData() {
            apeng.Sets.forEach(this.node.children, node => {
                node.removeFromParent();
                node.destroy();
            }, true);
        }
        onLoad() {
            super.onLoad();
            this.updateView();
        }
        onDestroy() {
            this.Pool.clear();
            super.onDestroy();
        }
        getItem(str) {
            if (!this.itemsByStringMap) {
                this.itemsByStringMap = {};
                for (let item of this.items)
                    if (item.string && item.sf)
                        this.itemsByStringMap[item.string] = item;
            }
            let item = this.itemsByStringMap[str];
            if (apeng.EDITOR)
                this.itemsByStringMap = null;
            return item;
        }
        updateView() {
            apeng.Sets.updateItemCount(this._string.length, this.node.children.length, (add) => {
                if (add)
                    this.node.addChild(this.Pool.get());
                else {
                    let node = apeng.Sets.pop(this.node.children, false);
                    if (node)
                        this.Pool.put(node);
                }
            });
            let numArr = this.string.split("");
            let sp = null;
            let last = 0;
            let node = null;
            let item = null;
            let w = 0;
            let h = 0;
            let oneItemW = 0;
            for (let i = 0; i < numArr.length; i++) {
                item = this.getItem(numArr[i]);
                if (!item)
                    continue;
                node = this.node.children[i];
                sp = node.getComponent(apeng.Sprite);
                sp.color = this.color;
                sp.spriteFrame = item.sf;
                sp.grayscale = this._isGray;
                if (i > 0)
                    last += item.width / 2;
                else
                    oneItemW = item.width;
                w += (item.width + this.space);
                apeng.NodeHelper.setPositionX(sp.node, last + item.offsetWidth, false);
                apeng.NodeHelper.setPositionY(sp.node, item.offsetHight, false);
                last += item.width / 2 + this.space;
                h = Math.max(h, item.height);
                this.node.addChild(sp.node);
            }
            w -= this.space;
            let offset = -((w) / 2) + oneItemW / 2;
            offset -= (this.UITransform.anchorX - 0.5) * this.UITransform.width;
            for (let i = this.node.children.length - 1; i >= 0; i--)
                apeng.NodeHelper.setPositionX(this.node.children[i], this.node.children[i].position.x + offset, false);
            // 节点大小
            apeng.NodeHelper.setSize(this.node, w, h);
        }
    };
    __decorate([
        apeng.property({
            displayName: "字间距"
        })
    ], FontCC.prototype, "space", null);
    __decorate([
        apeng.property({
            displayName: "显示的文字"
        })
    ], FontCC.prototype, "string", null);
    __decorate([
        apeng.property({
            type: apeng.Color,
            displayName: "颜色"
        })
    ], FontCC.prototype, "color", null);
    __decorate([
        apeng.property({
            displayName: "置灰"
        })
    ], FontCC.prototype, "isGray", null);
    __decorate([
        apeng.property({
            type: [CCFontItem],
            displayName: "字符集",
        })
    ], FontCC.prototype, "items", void 0);
    __decorate([
        apeng.property({
            displayName: "加粗"
        })
    ], FontCC.prototype, "isBold", null);
    __decorate([
        apeng.property({ serializable: true })
    ], FontCC.prototype, "_isBold", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], FontCC.prototype, "_isGray", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], FontCC.prototype, "_string", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], FontCC.prototype, "_space", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], FontCC.prototype, "_color", void 0);
    FontCC = __decorate([
        apeng.ccclass("FontCC"),
        apeng.executeInEditMode,
        apeng.menuUI("main/component/FontCC")
    ], FontCC);
    apeng.FontCC = FontCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const v2T = new apeng.Vec2();
    const v3T = new apeng.Vec3();
    let JoystickCC = class JoystickCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                MOVE: "MOVE",
                START: "START",
                END: "END",
                ANIM_COMPLETE: "ANIM_COMPLETE",
            };
            this.backupDescribe = "摇杆";
            this.orginNode = null;
            this.orginImgNode = null;
            this.dragNode = null;
            this.radius = 300;
            this._touchId = -1;
            this.angle = 150;
            this.len = 150;
            this.dir = new apeng.Vector2();
            this.isAnim = false;
            this.onTouchCancel = this.onTouchEnd;
        }
        onEnable() {
            super.onEnable();
            this.stopAnim();
        }
        onTouchStart(e) {
            if (this._touchId != -1)
                return;
            this._touchId = e.getID();
            this.isAnim = false;
            this.dragNode.active = true;
            this.orginImgNode.active = true;
            e.getUILocation(v2T);
            this.convertToNodeSpaceAR(v3T, v2T);
            apeng.NodeHelper.setPositionXY(this.orginNode, v3T, false);
            apeng.NodeHelper.setPositionXY(this.dragNode, apeng.Vec3.ZERO, false);
            this.len = 0;
            this.setAngle(v3T);
            this.node.emit(this.EventType.START);
        }
        onTouchMove(e) {
            if (!(this._touchId != -1 && this._touchId == e.getID()))
                return;
            e.getUILocation(v2T);
            apeng.NodeHelper.convertToNodeSpaceAR(v3T, this.orginNode, v2T);
            this.setAngle(v3T);
            this.len = apeng.Vector2.len(v3T);
            if (this.len > this.radius) {
                this.len = this.radius;
                apeng.Vector2.normalize(v3T, v3T);
                apeng.Vector2.mul(v3T, v3T, this.radius);
            }
            apeng.NodeHelper.setPositionXY(this.dragNode, v3T, false);
            this.node.emit(this.EventType.MOVE);
        }
        onTouchEnd(e) {
            if (!(this._touchId != -1 && this._touchId == e.getID()))
                return;
            this._touchId = -1;
            this.orginImgNode.active = false;
            apeng.NodeHelper.setRotateZ(this.dragNode, this.angle + 180, false);
            this.isAnim = true;
            this.len = 0;
            this.node.emit(this.EventType.END);
        }
        onUpdate() {
            if (!this.isAnim)
                return;
            if (apeng.NodeHelper.lerpTarget(this.dragNode, apeng.Vector3.ZERO, .1, undefined, false, undefined, .3)) {
                this.stopAnim();
                this.node.emit(this.EventType.ANIM_COMPLETE);
            }
        }
        stopAnim() {
            this.isAnim = false;
            this.dragNode.active = false;
            this.orginImgNode.active = true;
            apeng.NodeHelper.setRotateZ(this.dragNode, 0, false);
        }
        setAngle(dir) {
            if (dir.x == 0 && dir.y == 0)
                return;
            this.dir.set(dir);
            this.dir.normalizeSelf();
            this.angle = apeng.Vector2.angle(dir);
            apeng.NodeHelper.setRotateZ(this.dragNode, this.angle, false);
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "原点",
        })
    ], JoystickCC.prototype, "orginNode", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "原点图片",
        })
    ], JoystickCC.prototype, "orginImgNode", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "拖动点",
        })
    ], JoystickCC.prototype, "dragNode", void 0);
    __decorate([
        apeng.property({ displayName: "最大拖动范围" })
    ], JoystickCC.prototype, "radius", void 0);
    JoystickCC = __decorate([
        apeng.ccclass("JoystickCC"),
        apeng.menuUI("JoystickCC")
    ], JoystickCC);
    apeng.JoystickCC = JoystickCC;
})(apeng || (apeng = {}));

(function (apeng) {
    var LabelNumRollCC_1;
    let LabelNumRollCC = LabelNumRollCC_1 = class LabelNumRollCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "数字滚动组件";
            this.lastStr = "";
            this.duration = 1;
            this.strInterval = ",";
            this._to = -1;
            this._from = -1;
            this.isAnim = false;
            this._dtCount = 0;
            this.cur = 0;
        }
        onEnable() {
            super.onEnable();
            this.isAnim = false;
            this._dtCount = 0;
        }
        onUpdate() {
            if (!this.isAnim)
                return;
            this._dtCount += apeng._timer.dtDefault;
            if (this._dtCount > this.duration) {
                this._dtCount = 0;
                this.isAnim = false;
                this.updateString(this._to);
                return;
            }
            let ratio = apeng.Maths.clamp01(this._dtCount / this.duration);
            ratio = apeng.easing(apeng.EEaseType.linear, ratio);
            this.updateString(Math.floor(apeng.Maths.lerp(this._from, this._to, ratio)));
        }
        toByString(num) {
            this._from = this.cur;
            this._to = num;
            if (this._to < this._from) {
                this.isAnim = false;
                this.updateString(this._to);
                return;
            }
            this._dtCount = 0;
            this.isAnim = true;
        }
        updateString(num) {
            this.cur = num;
            let str = "";
            if (num > 9999999)
                str = Math.floor(num / 10000) + LabelNumRollCC_1.texts[20002];
            else if (num > 99999)
                str = Math.floor(num / 1000) + LabelNumRollCC_1.texts[20001];
            else {
                str = num + this.lastStr;
                if (!this.lastStr) {
                    if (this.strInterval) {
                        let _str = str;
                        let i2 = -1;
                        str = "";
                        for (let i = _str.length - 1; i >= 0; i--) {
                            if (i2 % 3 == 2)
                                str = this.strInterval + str;
                            str = _str[i] + str;
                            i2++;
                        }
                    }
                }
            }
            (this.Label || this.FontCC).string = str;
        }
        setString(num) {
            this.isAnim = false;
            this.updateString(num);
        }
    };
    LabelNumRollCC.texts = {
        20001: "k",
        20002: "w",
    };
    __decorate([
        apeng.property({
            displayName: "后缀"
        })
    ], LabelNumRollCC.prototype, "lastStr", void 0);
    __decorate([
        apeng.property({
            displayName: "滚动动画时长"
        })
    ], LabelNumRollCC.prototype, "duration", void 0);
    __decorate([
        apeng.property({
            displayName: "数字间隔"
        })
    ], LabelNumRollCC.prototype, "strInterval", void 0);
    LabelNumRollCC = LabelNumRollCC_1 = __decorate([
        apeng.ccclass("LabelNumRollCC"),
        apeng.menuUI("LabelNumRollCC")
    ], LabelNumRollCC);
    apeng.LabelNumRollCC = LabelNumRollCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let LanguageLabelCC = class LanguageLabelCC extends _cc_.Component {
        constructor() {
            super(...arguments);
            this.backupDescribe = "多语言静态文本";
            this.configID = -1;
            this.lb = null;
        }
        __preload() {
            if (this.configID != -1) {
                this.lb = this.getComponent(apeng.Label);
                if (this.lb)
                    if (this.lb.cacheMode == apeng.Label.CacheMode.BITMAP)
                        this.lb.cacheMode = apeng.Label.CacheMode.NONE;
            }
        }
        onEnable() {
            if (this.configID == -1 || !this.lb)
                return;
            apeng._language.on(apeng._language.EventType.CHANGE, this.onEventChange, this);
            this.onEventChange(() => { });
        }
        onDisable() {
            if (this.configID == -1 || !this.lb)
                return;
            apeng._language.off(apeng._language.EventType.CHANGE, this.onEventChange, this);
        }
        onEventChange(complete) {
            this.lb.string = apeng._language.get(this.configID);
            complete();
        }
    };
    __decorate([
        apeng.property({
            displayName: "lang表ID"
        })
    ], LanguageLabelCC.prototype, "configID", void 0);
    LanguageLabelCC = __decorate([
        apeng.ccclass("LanguageLabelCC"),
        apeng.menuUI("LanguageLabelCC")
    ], LanguageLabelCC);
    apeng.LanguageLabelCC = LanguageLabelCC;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Rectangle.ts" />

(function (apeng) {
    let ELayoutType;
    (function (ELayoutType) {
        /**横向 */
        ELayoutType[ELayoutType["Horizontal"] = 0] = "Horizontal";
        /**纵向 */
        ELayoutType[ELayoutType["Vertical"] = 1] = "Vertical";
        /**横向网格 */
        ELayoutType[ELayoutType["HorizontalGrid"] = 2] = "HorizontalGrid";
        /**纵向网格 */
        ELayoutType[ELayoutType["VerticalGrid"] = 3] = "VerticalGrid";
    })(ELayoutType = apeng.ELayoutType || (apeng.ELayoutType = {}));
    apeng.ccenum(ELayoutType);
    let EVerticalDirection;
    (function (EVerticalDirection) {
        EVerticalDirection[EVerticalDirection["BottomToTop"] = 0] = "BottomToTop";
        EVerticalDirection[EVerticalDirection["TopToBottom"] = 1] = "TopToBottom";
    })(EVerticalDirection = apeng.EVerticalDirection || (apeng.EVerticalDirection = {}));
    apeng.ccenum(EVerticalDirection);
    let EHorizontalDirection;
    (function (EHorizontalDirection) {
        EHorizontalDirection[EHorizontalDirection["LeftToRight"] = 0] = "LeftToRight";
        EHorizontalDirection[EHorizontalDirection["RightToLeft"] = 1] = "RightToLeft";
    })(EHorizontalDirection = apeng.EHorizontalDirection || (apeng.EHorizontalDirection = {}));
    apeng.ccenum(EHorizontalDirection);
    const v3T = new apeng.Vec3();
    const rectangleT = new apeng.Rectangle();
    let LayoutCC = class LayoutCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "网格排布";
            this.content = null;
            this._itemSize = new apeng.Size(40, 40);
            this._numItems = 0;
            this._horizontalItemY = 0;
            this._verticalItemX = 0;
            this._horizontalGridCount = 1;
            this._verticalGridCount = 1;
            this._isSetContentSize = true;
            this._type = ELayoutType.Horizontal;
            this._horizontalDirection = EHorizontalDirection.LeftToRight;
            this._verticalDirection = EVerticalDirection.TopToBottom;
            this._paddingLeft = 0;
            this._paddingRight = 0;
            this._paddingTop = 0;
            this._paddingBottom = 0;
            this._spacingX = 0;
            this._spacingY = 0;
            this._horizontalAddByLevel = 0;
            this._verticalAddByLevel = 0;
            this._ratatePosition = 0;
            this._applyItemRotate = false;
            this._showItemByLabelIndex = false;
            this._gridOneCenter = false;
            this.onEditorUpdateData = this.updateView;
            this.onAnchorChange = this.updateView;
            /**item所对应的坐标 */
            this.itemByPosition = [];
        }
        set itemSize(value) {
            if (this._itemSize.equals(value))
                return;
            this._itemSize.set(value);
            this.updateView();
        }
        get itemSize() { return this._itemSize; }
        set numItems(value) {
            if (this._numItems == value)
                return;
            this._numItems = value;
            this.updateView();
        }
        get numItems() { return this._numItems; }
        set type(value) {
            if (this._type == value)
                return;
            this._type = value;
            this.updateView();
        }
        get type() { return this._type; }
        set horizontalGridCount(value) {
            if (this._horizontalGridCount == value)
                return;
            this._horizontalGridCount = apeng.Maths.clampf(value, 1, 9999);
            this.updateView();
        }
        get horizontalGridCount() { return this._horizontalGridCount; }
        set verticalGridCount(value) {
            if (this._verticalGridCount == value)
                return;
            this._verticalGridCount = apeng.Maths.clampf(value, 1, 9999);
            this.updateView();
        }
        get verticalGridCount() { return this._verticalGridCount; }
        set horizontalDirection(value) {
            if (this._horizontalDirection == value)
                return;
            this._horizontalDirection = value;
            this.updateView();
        }
        get horizontalDirection() { return this._horizontalDirection; }
        set verticalDirection(value) {
            if (this._verticalDirection == value)
                return;
            this._verticalDirection = value;
            this.updateView();
        }
        get verticalDirection() { return this._verticalDirection; }
        set paddingLeft(value) {
            if (this._paddingLeft == value)
                return;
            this._paddingLeft = value;
            this.updateView();
        }
        get paddingLeft() { return this._paddingLeft; }
        set paddingRight(value) {
            if (this._paddingRight == value)
                return;
            this._paddingRight = value;
            this.updateView();
        }
        get paddingRight() { return this._paddingRight; }
        set paddingTop(value) {
            if (this._paddingTop == value)
                return;
            this._paddingTop = value;
            this.updateView();
        }
        get paddingTop() { return this._paddingTop; }
        set paddingBottom(value) {
            if (this._paddingBottom == value)
                return;
            this._paddingBottom = value;
            this.updateView();
        }
        get paddingBottom() { return this._paddingBottom; }
        set spacingX(value) {
            if (this._spacingX == value)
                return;
            this._spacingX = value;
            this.updateView();
        }
        get spacingX() { return this._spacingX; }
        set spacingY(value) {
            if (this._spacingY == value)
                return;
            this._spacingY = value;
            this.updateView();
        }
        get spacingY() { return this._spacingY; }
        set horizontalItemY(value) {
            if (this._horizontalItemY == value)
                return;
            this._horizontalItemY = value;
            this.updateView();
        }
        get horizontalItemY() { return this._horizontalItemY; }
        set verticalItemX(value) {
            if (this._verticalItemX == value)
                return;
            this._verticalItemX = value;
            this.updateView();
        }
        get verticalItemX() { return this._verticalItemX; }
        set horizontalAddByLevel(value) {
            if (this._horizontalAddByLevel == value)
                return;
            this._horizontalAddByLevel = value;
            this.updateView();
        }
        get horizontalAddByLevel() { return this._horizontalAddByLevel; }
        set verticalAddByLevel(value) {
            if (this._verticalAddByLevel == value)
                return;
            this._verticalAddByLevel = value;
            this.updateView();
        }
        get verticalAddByLevel() { return this._verticalAddByLevel; }
        set isSetContentSize(value) {
            if (this._isSetContentSize == value)
                return;
            this._isSetContentSize = value;
            this.updateView();
        }
        get isSetContentSize() { return this._isSetContentSize; }
        set ratatePosition(value) {
            if (this._ratatePosition == value)
                return;
            this._ratatePosition = value;
            this.updateView();
        }
        get ratatePosition() { return this._ratatePosition; }
        set applyItemRotate(value) {
            if (this._applyItemRotate == value)
                return;
            this._applyItemRotate = value;
            this.updateView();
        }
        get applyItemRotate() { return this._applyItemRotate; }
        set showItemByLabelIndex(value) {
            if (this._showItemByLabelIndex == value)
                return;
            this._showItemByLabelIndex = value;
            this.updateView();
        }
        get showItemByLabelIndex() { return this._showItemByLabelIndex; }
        set gridOneCenter(value) {
            if (this._gridOneCenter == value)
                return;
            this._gridOneCenter = value;
            this.updateView();
        }
        get gridOneCenter() { return this._gridOneCenter; }
        get contentTransform() { return apeng.NodeHelper.getUITransform(this.content); }
        onLoad() {
            super.onLoad();
            // 自动添加组件
            if (apeng.EDITOR) {
                if (!this.content)
                    this.content = this.node;
            }
            this.updateView();
        }
        start() {
            super.start();
            this.updateView();
        }
        updateView() {
            let w = null, h = null;
            switch (this._type) {
                case ELayoutType.Horizontal:
                    w = this.getHorizontalWidth();
                    this._doLayoutHorizontal(w);
                    break;
                case ELayoutType.Vertical:
                    h = this.getVerticalHeight();
                    this._doLayoutVertical(h);
                    break;
                case ELayoutType.HorizontalGrid:
                    w = this.getHorizontalWidth();
                    h = this.getVerticalHeight(Math.min(this._horizontalGridCount, this._numItems));
                    this._doLayoutHorizontalGrid(w);
                    break;
                case ELayoutType.VerticalGrid:
                    w = this.getHorizontalWidth(Math.min(this._verticalGridCount, this._numItems));
                    h = this.getVerticalHeight();
                    this._doLayoutVerticalGrid(h);
                    break;
            }
            this.updateItemPosition();
            this.updateItemRotate();
            if (this.isSetContentSize)
                apeng.NodeHelper.setSize(this.content, w, h);
        }
        /**获取包围盒 */
        getItemRectange(out, index, isWorld, offset) {
            out.size = this._itemSize;
            out.center = this.getItemPosition(index, isWorld, offset);
            if (this._applyItemRotate)
                out.angle = this._ratatePosition;
            return out;
        }
        /**通过坐标点获取所在的索引 */
        getPositionByIndex(position) {
            for (let i = 0; i < this._numItems; i++) {
                this.getItemRectange(rectangleT, i, false);
                if (rectangleT.contains(position))
                    return i;
            }
            return -1;
        }
        _doLayoutVertical(length) {
            let sign = 1;
            let paddingY = this._paddingBottom;
            if (this._verticalDirection == 1) {
                sign = -1;
                paddingY = this._paddingTop;
            }
            let startPos = (this._verticalDirection - this.contentTransform.anchorY) * length + sign * paddingY;
            let nextY = startPos - sign * this._spacingY;
            for (let i = 0; i < this._numItems; i++) {
                let y = sign * .5 * this._itemSize.height;
                nextY += sign * (.5 * this._itemSize.height + this._spacingY);
                this.setItemPosition(i, this._verticalItemX, nextY, i);
                nextY += y;
            }
        }
        _doLayoutHorizontal(length) {
            let sign = 1;
            let paddingX = this._paddingLeft;
            if (this._horizontalDirection == 1) {
                sign = -1;
                paddingX = this._paddingRight;
            }
            let startPos = (this._horizontalDirection - this.contentTransform.anchorX) * length + sign * paddingX;
            let nextX = startPos - sign * this._spacingX;
            for (let i = 0; i < this._numItems; i++) {
                let x = sign * .5 * this._itemSize.width;
                nextX += sign * (.5 * this._itemSize.width + this._spacingX);
                this.setItemPosition(i, nextX, this._horizontalItemY, i);
                nextX += x;
            }
        }
        _doLayoutHorizontalGrid(length) {
            let sign = 1;
            let paddingX = this._paddingLeft;
            if (this._horizontalDirection == 1) {
                sign = -1;
                paddingX = this._paddingRight;
            }
            let startPos = (this._horizontalDirection - this.contentTransform.anchorX) * length + sign * paddingX;
            let nextX = startPos - sign * this._spacingX;
            let count = this.getHorizontalCount();
            for (let i = 0; i < count; i++) {
                let x = sign * .5 * this._itemSize.width;
                nextX += sign * (.5 * this._itemSize.width + this._spacingX);
                for (let j = 0; j < this._horizontalGridCount; j++) {
                    let y = -((j - (this._horizontalGridCount - 1) / 2)) * (this._itemSize.height + this._spacingY);
                    if (this._gridOneCenter) {
                        if (i == count - 1) {
                            let count2 = this._horizontalGridCount - this._numItems % this._horizontalGridCount;
                            if (count2 != this._horizontalGridCount)
                                y -= count2 * (this._itemSize.height + this._spacingY) / 2;
                        }
                    }
                    this.setItemPosition((i * this._horizontalGridCount) + j, nextX, y, i);
                }
                nextX += x;
            }
        }
        _doLayoutVerticalGrid(length) {
            let sign = 1;
            let paddingY = this._paddingBottom;
            if (this._verticalDirection == 1) {
                sign = -1;
                paddingY = this._paddingTop;
            }
            let startPos = (this._verticalDirection - this.contentTransform.anchorY) * length + sign * paddingY;
            let nextY = startPos - sign * this._spacingY;
            let count = this.geVerticalCount();
            for (let i = 0; i < count; i++) {
                let y = sign * .5 * this._itemSize.height;
                nextY += sign * (.5 * this._itemSize.height + this._spacingY);
                for (let j = 0; j < this._verticalGridCount; j++) {
                    let x = ((j - (this._verticalGridCount - 1) / 2)) * (this._itemSize.width + this._spacingX);
                    if (this._gridOneCenter) {
                        if (i == count - 1) {
                            let count2 = this._verticalGridCount - this._numItems % this._verticalGridCount;
                            if (count2 != this._verticalGridCount)
                                x += count2 * (this._itemSize.width + this._spacingX) / 2;
                        }
                    }
                    this.setItemPosition((i * this._verticalGridCount) + j, x, nextY, i);
                }
                nextY += y;
            }
        }
        setItemPosition(index, x, y, addIndex) {
            let v2 = this.itemByPosition[index];
            if (!v2)
                v2 = this.itemByPosition[index] = new apeng.Vector2();
            v2.x = addIndex * this._horizontalAddByLevel;
            v2.y = addIndex * this._verticalAddByLevel;
            v2.x += x;
            v2.y += y;
            if (this._ratatePosition != 0)
                apeng.Vector2.rotate(v2, v2, apeng.Maths.toRadian(this._ratatePosition));
        }
        /**获取节点位置 */
        getItemPosition(index, isWorld, offset) {
            if (!this.itemByPosition[index])
                return null;
            apeng.Vector2.set(v3T, this.itemByPosition[index]);
            if (isWorld)
                apeng.NodeHelper.convertToWorldSpaceAR(v3T, this.content, v3T);
            if (offset)
                apeng.Vector2.add(v3T, v3T, offset);
            return v3T;
        }
        updateItemRotate() {
            if (this._applyItemRotate)
                if (this._ratatePosition != 0)
                    for (let i = 0; i < this.content.children.length; i++)
                        apeng.NodeHelper.setRotateZ(this.content.children[i], this._ratatePosition, false);
        }
        /**更新节点位置 */
        updateItemPosition(index = -1) {
            if (index == -1) {
                for (let i = 0; i < this.content.children.length; i++) {
                    apeng.NodeHelper.setPositionXY(this.content.children[i], this.itemByPosition[i], false);
                    if (this._showItemByLabelIndex) {
                        let lb = this.content.children[i].getComponentInChildren(apeng.Label);
                        if (lb)
                            lb.string = i + "";
                    }
                }
            }
            else
                apeng.NodeHelper.setPositionXY(this.content.children[index], this.itemByPosition[index], false);
        }
        getHorizontalWidth(count) {
            if (!count)
                count = this.getHorizontalCount();
            return count * this._itemSize.width + (count - 1) * this._spacingX + this._getPaddingH();
        }
        getVerticalHeight(count) {
            if (!count)
                count = this.geVerticalCount();
            return count * this._itemSize.height + (count - 1) * this._spacingY + this._getPaddingV();
        }
        getHorizontalCount() {
            return Math.ceil(this._numItems / this._horizontalGridCount);
        }
        geVerticalCount() {
            return Math.ceil(this._numItems / this._verticalGridCount);
        }
        _getPaddingH() {
            return this._paddingLeft + this._paddingRight;
        }
        _getPaddingV() {
            return this._paddingTop + this._paddingBottom;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "容器",
        })
    ], LayoutCC.prototype, "content", void 0);
    __decorate([
        apeng.property({
            displayName: "格子大小"
        })
    ], LayoutCC.prototype, "itemSize", null);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "当前个数"
        })
    ], LayoutCC.prototype, "numItems", null);
    __decorate([
        apeng.property({
            type: ELayoutType,
            displayName: "排版"
        })
    ], LayoutCC.prototype, "type", null);
    __decorate([
        apeng.property({
            displayName: "横向行数",
            visible() { return this._type == ELayoutType.HorizontalGrid; }
        })
    ], LayoutCC.prototype, "horizontalGridCount", null);
    __decorate([
        apeng.property({
            displayName: "纵向列数",
            visible() { return this._type == ELayoutType.VerticalGrid; }
        })
    ], LayoutCC.prototype, "verticalGridCount", null);
    __decorate([
        apeng.property({
            type: EHorizontalDirection,
            displayName: "横向顺序",
            visible() {
                return this._type == ELayoutType.Horizontal
                    || this._type == ELayoutType.HorizontalGrid;
            }
        })
    ], LayoutCC.prototype, "horizontalDirection", null);
    __decorate([
        apeng.property({
            type: EVerticalDirection,
            displayName: "纵向顺序",
            visible() {
                return this._type == ELayoutType.Vertical
                    || this._type == ELayoutType.VerticalGrid;
            }
        })
    ], LayoutCC.prototype, "verticalDirection", null);
    __decorate([
        apeng.property({
            displayName: "左边距",
            visible() {
                return this._type == ELayoutType.Horizontal
                    || this._type == ELayoutType.HorizontalGrid;
            }
        })
    ], LayoutCC.prototype, "paddingLeft", null);
    __decorate([
        apeng.property({
            displayName: "右边距",
            visible() {
                return this._type == ELayoutType.Horizontal
                    || this._type == ELayoutType.HorizontalGrid;
            }
        })
    ], LayoutCC.prototype, "paddingRight", null);
    __decorate([
        apeng.property({
            displayName: "上边距",
            visible() {
                return this._type == ELayoutType.Vertical
                    || this._type == ELayoutType.VerticalGrid;
            }
        })
    ], LayoutCC.prototype, "paddingTop", null);
    __decorate([
        apeng.property({
            displayName: "下边距",
            visible() {
                return this._type == ELayoutType.Vertical
                    || this._type == ELayoutType.VerticalGrid;
            }
        })
    ], LayoutCC.prototype, "paddingBottom", null);
    __decorate([
        apeng.property({
            displayName: "水平间距",
            visible() {
                return this._type == ELayoutType.Horizontal
                    || this._type == ELayoutType.HorizontalGrid
                    || this._type == ELayoutType.VerticalGrid;
            }
        })
    ], LayoutCC.prototype, "spacingX", null);
    __decorate([
        apeng.property({
            displayName: "纵向间距",
            visible() {
                return this._type == ELayoutType.Vertical
                    || this._type == ELayoutType.HorizontalGrid
                    || this._type == ELayoutType.VerticalGrid;
            }
        })
    ], LayoutCC.prototype, "spacingY", null);
    __decorate([
        apeng.property({
            displayName: "横向时Y",
            visible() {
                return this._type == ELayoutType.Horizontal;
            }
        })
    ], LayoutCC.prototype, "horizontalItemY", null);
    __decorate([
        apeng.property({
            displayName: "纵向时X",
            visible() {
                return this._type == ELayoutType.Vertical;
            }
        })
    ], LayoutCC.prototype, "verticalItemX", null);
    __decorate([
        apeng.property({
            displayName: "横向递增",
        })
    ], LayoutCC.prototype, "horizontalAddByLevel", null);
    __decorate([
        apeng.property({
            displayName: "纵向递增",
        })
    ], LayoutCC.prototype, "verticalAddByLevel", null);
    __decorate([
        apeng.property({
            displayName: "设置容器宽高",
        })
    ], LayoutCC.prototype, "isSetContentSize", null);
    __decorate([
        apeng.property({
            displayName: "旋转角度",
        })
    ], LayoutCC.prototype, "ratatePosition", null);
    __decorate([
        apeng.property({
            displayName: "子节点旋转",
        })
    ], LayoutCC.prototype, "applyItemRotate", null);
    __decorate([
        apeng.property({
            displayName: "显示itemLabel",
        })
    ], LayoutCC.prototype, "showItemByLabelIndex", null);
    __decorate([
        apeng.property({
            displayName: "网格剩一排居中",
            visible() { return this._type == ELayoutType.HorizontalGrid || this.type == ELayoutType.VerticalGrid; },
        })
    ], LayoutCC.prototype, "gridOneCenter", null);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_itemSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_numItems", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_horizontalItemY", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_verticalItemX", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_horizontalGridCount", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_verticalGridCount", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_isSetContentSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_type", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_horizontalDirection", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_verticalDirection", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_paddingLeft", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_paddingRight", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_paddingTop", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_paddingBottom", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_spacingX", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_spacingY", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_horizontalAddByLevel", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_verticalAddByLevel", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_ratatePosition", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_applyItemRotate", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_showItemByLabelIndex", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCC.prototype, "_gridOneCenter", void 0);
    LayoutCC = __decorate([
        apeng.ccclass("LayoutCC"),
        apeng.executeInEditMode,
        apeng.menuUI("LayoutCC")
    ], LayoutCC);
    apeng.LayoutCC = LayoutCC;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Rectangle.ts" />

(function (apeng) {
    const v2T = new apeng.Vector2();
    const v2T2 = new apeng.Vector2();
    let LayoutCircleCC = class LayoutCircleCC extends apeng.CreatePrefabToEditorCC {
        constructor() {
            super(...arguments);
            this.backupDescribe = "网格排布";
            this.allCount = 3;
            this._mulDisCount = 3;
            this._mulCount = [];
            this.positions = [];
        }
        set mulCount(value) {
            this._mulCount = value;
            this.onUpdateItem();
        }
        get mulCount() { return this._mulCount; }
        set mulDisCount(value) {
            if (this._mulDisCount == value)
                return;
            this._mulDisCount = value;
            this.onUpdateItem();
        }
        get mulDisCount() { return this._mulDisCount; }
        onUpdateItem() {
            let i = 0;
            if (!this.positions[i])
                this.positions[i] = apeng.Vector2.pool.get();
            this.positions[i].set();
            for (let _mulCount = 0; _mulCount < this._mulCount.length; _mulCount++) {
                let count = this._mulCount[_mulCount];
                for (let _angleCount = 0; _angleCount < count; _angleCount++) {
                    i++;
                    if (!this.positions[i])
                        this.positions[i] = apeng.Vector2.pool.get();
                    let _angle = (_angleCount + 1) / count * 360;
                    v2T.set(1, 0);
                    v2T.rotateSelf(apeng.Maths.toRadian(_angle));
                    let dis = this._mulDisCount * (_mulCount + 1);
                    apeng.Vector2.mul(this.positions[i], v2T, dis);
                }
            }
            this.allCount = i + 1;
            let childs = this.content.children;
            let sub = this.positions.length - childs.length;
            if (sub > 0)
                for (let _i = 0; _i < sub; _i++)
                    apeng.Vector2.pool.put(this.positions.pop());
            apeng.Sets.sortMax(this.positions, v => v.y + 1000000);
            for (let _i = 0; _i < childs.length; _i++) {
                if (childs[_i])
                    apeng.NodeHelper.setPositionXY(childs[_i], this.positions[_i], false);
            }
        }
        getRadius() {
            let add = 0;
            let prefab = this.prefabItem;
            if (prefab) {
                let node = prefab.data;
                if (node) {
                    let transform = apeng.NodeHelper.getUITransform(node);
                    if (transform) {
                        let size = transform.contentSize;
                        add = Math.max(size.width, size.height);
                    }
                }
            }
            return this._mulCount.length * this._mulDisCount + add;
        }
    };
    __decorate([
        apeng.property({
            type: [apeng.CCInteger],
            displayName: "圈数",
        })
    ], LayoutCircleCC.prototype, "mulCount", null);
    __decorate([
        apeng.property({
            displayName: "每圈距离",
        })
    ], LayoutCircleCC.prototype, "mulDisCount", null);
    __decorate([
        apeng.property({ displayName: "总个数" })
    ], LayoutCircleCC.prototype, "allCount", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCircleCC.prototype, "_mulDisCount", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], LayoutCircleCC.prototype, "_mulCount", void 0);
    LayoutCircleCC = __decorate([
        apeng.ccclass("LayoutCircleCC"),
        apeng.executeInEditMode,
        apeng.menuUI("LayoutCircleCC")
    ], LayoutCircleCC);
    apeng.LayoutCircleCC = LayoutCircleCC;
})(apeng || (apeng = {}));

(function (apeng) {
    var LevelRollCC_1;
    let LevelRollCC = LevelRollCC_1 = class LevelRollCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.prefabItem = null;
            this.prefabBg = null;
            this.sfOnce = null;
            this.sfLast = null;
            this.sfLoop = [];
            this.itemYOffset = new apeng.Vec2();
            this.itemCount = 0;
            this.bgCount = 0;
            this.parses = null;
            this.bgs = [];
            this.items = [];
            this.contentTrans = null;
            this.screenH = -1;
            this.showBgs = {};
            this.showItems = {};
        }
        static getBgIndexByData(index, parse) {
            if (index == 0)
                return parse.source.items.once;
            if (index == parse.bgsY.length - 1)
                return parse.source.items.last;
            let loop = parse.source.items.loop;
            return loop[(index - 1) % loop.length];
        }
        static getBgIndexBySf(index, parse, comp) {
            if (index == 0)
                return comp.sfOnce;
            if (index == parse.bgsY.length - 1)
                return comp.sfLast;
            let loop = parse.source.items.loop;
            return comp.sfLoop[(index - 1) % loop.length];
        }
        static parseData(data) {
            let parses = {
                source: data,
                onceY: 0,
                loopY: [],
                itemsY: [],
                bgsY: []
            };
            let items = data.items;
            let _loopPositionCount = 0;
            for (let v of items.loop) {
                _loopPositionCount += v.position.length;
            }
            // 整数
            let loopCount = (data.count - items.once.position.length - items.last.position.length)
                / _loopPositionCount;
            parses.bgsY.push(0);
            let lastY = 0;
            for (let v of items.once.position)
                parses.itemsY.push([v.x, v.y + lastY]);
            for (let i = 0; i < loopCount; i++) {
                let ys = [];
                for (let v of items.loop) {
                    let y = lastY + items.once.height;
                    ys.push(y);
                    parses.bgsY.push(y);
                    lastY += v.height;
                    for (let _v of v.position)
                        parses.itemsY.push([_v.x, _v.y + lastY]);
                }
                parses.loopY.push(ys);
            }
            parses.lastY = lastY + items.once.height;
            parses.bgsY.push(parses.lastY);
            for (let v of items.last.position)
                parses.itemsY.push([v.x, v.y + parses.lastY]);
            parses.allHeight = parses.lastY + items.last.height;
            return parses;
        }
        /**容器 */
        get content() { return apeng.NodeHelper.getChildByCreate(this.node, "content", this.createNode.bind(this), undefined, true); }
        get bgParent() { return apeng.NodeHelper.getChildByCreate(this.content, "bg", this.createNode.bind(this), 0, true); }
        get itemParent() { return apeng.NodeHelper.getChildByCreate(this.content, "item", this.createNode.bind(this), 1, true); }
        createNode(node) {
            let widget = node.addComponent(apeng.Widget);
            widget.isAlignBottom = true;
            widget.bottom = 0;
            let trans = apeng.NodeHelper.getUITransform(node);
            trans.setAnchorPoint(.5, 0);
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                let scroll = this.node.getComponent(apeng.ScrollView);
                if (!scroll) {
                    scroll = this.node.addComponent(apeng.ScrollView);
                    scroll.horizontal = false;
                    scroll.vertical = true;
                    scroll.inertia = true;
                    scroll.brake = .75;
                    scroll.elastic = true;
                    scroll.bounceDuration = .23;
                    scroll.content = this.content;
                    scroll.cancelInnerEvents = true;
                }
                this.bgParent;
                this.itemParent;
                this.contentTrans = apeng.NodeHelper.getUITransform(this.content);
                return;
            }
            this.screenH = apeng.winSize().height + 10;
            this.contentTrans = apeng.NodeHelper.getUITransform(this.content);
            this.addEvent(apeng.ScrollView.EventType.SCROLLING, this.updateView, this, this.node);
            for (let i = 0; i < this.bgCount; i++) {
                let node = apeng.instantiate(this.prefabBg);
                let comp = node.getComponent("LevelRollCCBg");
                this.bgs.push(comp);
                this.bgParent.addChild(node);
                apeng.NodeHelper.setPositionY(node, -10000, false);
            }
            for (let i = 0; i < this.itemCount; i++) {
                let node = apeng.instantiate(this.prefabItem);
                let comp = node.getComponent("LevelRollCCItem");
                this.items.push(comp);
                this.itemParent.addChild(node);
                apeng.NodeHelper.setPositionY(node, -10000, false);
            }
        }
        init(parses) {
            this.parses = parses;
            this.contentTrans.height = this.parses.allHeight;
            this.updateView();
        }
        updateView() {
            // 显示区域 min:-content.position.y + 屏幕高度
            let min = -this.content.position.y - 10;
            let max = min + this.screenH;
            let bgs = this.parses.bgsY;
            for (let i = 0; i < bgs.length; i++) {
                let y = bgs[i];
                // 在范围内
                if (apeng.Polygon.oneLineLine(min, max, y, y + LevelRollCC_1.getBgIndexByData(i, this.parses).height)) {
                    if (!this.showBgs[i]) {
                        let comp = this.bgs.pop();
                        if (!comp)
                            continue;
                        comp.updateView(this, i);
                        this.showBgs[i] = comp;
                    }
                }
                else {
                    if (this.showBgs[i]) {
                        this.bgs.push(this.showBgs[i]);
                        this.showBgs[i].setPositionY(-10000, false);
                        delete this.showBgs[i];
                    }
                }
            }
            let items = this.parses.itemsY;
            for (let i = 0; i < items.length; i++) {
                let y = items[i][1];
                // 在范围内
                if (apeng.Polygon.oneLineLine(min, max, y - this.itemYOffset.x, y + this.itemYOffset.y)) {
                    if (!this.showItems[i]) {
                        let comp = this.items.pop();
                        if (!comp)
                            continue;
                        comp.updateView(this, i);
                        this.showItems[i] = comp;
                    }
                }
                else {
                    if (this.showItems[i]) {
                        this.items.push(this.showItems[i]);
                        this.showItems[i].setPositionY(-10000, false);
                        delete this.showItems[i];
                    }
                }
            }
        }
        /**清除全部显示的 */
        clearShow() {
            for (let key in this.showBgs) {
                this.bgs.push(this.showBgs[key]);
                this.showBgs[key].setPositionY(-10000, false);
                delete this.showBgs[key];
            }
            for (let key in this.showBgs) {
                this.items.push(this.showItems[key]);
                this.showItems[key].setPositionY(-10000, false);
                delete this.showItems[key];
            }
        }
        scrollToIndex(index, duration, spaceY) {
            if (duration > 0)
                this.ScrollView.scrollToPercentVertical(index / this.parses.itemsY.length, duration);
            else {
                this.ScrollView.setContentPosition(new apeng.Vec3(0, -this.parses.itemsY[index][1] + spaceY, 0));
                this.updateView();
            }
        }
        getItemWithIndex(index) {
            return this.showItems[index];
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Prefab,
            displayName: "item",
        })
    ], LevelRollCC.prototype, "prefabItem", void 0);
    __decorate([
        apeng.property({
            type: apeng.Prefab,
            displayName: "背景",
        })
    ], LevelRollCC.prototype, "prefabBg", void 0);
    __decorate([
        apeng.property({
            type: apeng.SpriteFrame,
            displayName: "第一张图",
        })
    ], LevelRollCC.prototype, "sfOnce", void 0);
    __decorate([
        apeng.property({
            type: apeng.SpriteFrame,
            displayName: "最后一张图",
        })
    ], LevelRollCC.prototype, "sfLast", void 0);
    __decorate([
        apeng.property({
            type: [apeng.SpriteFrame],
            displayName: "循环图",
        })
    ], LevelRollCC.prototype, "sfLoop", void 0);
    __decorate([
        apeng.property({
            displayName: "item Y范围偏移"
        })
    ], LevelRollCC.prototype, "itemYOffset", void 0);
    __decorate([
        apeng.property({
            displayName: "实例化item个数"
        })
    ], LevelRollCC.prototype, "itemCount", void 0);
    __decorate([
        apeng.property({
            displayName: "实例化背景个数"
        })
    ], LevelRollCC.prototype, "bgCount", void 0);
    LevelRollCC = LevelRollCC_1 = __decorate([
        apeng.ccclass("LevelRollCC"),
        apeng.executeInEditMode,
        apeng.menuUI("LevelRollCC")
    ], LevelRollCC);
    apeng.LevelRollCC = LevelRollCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let LevelRollCCBg = class LevelRollCCBg extends apeng.BaseComponent {
        updateView(comp, index) {
            this.Sprite.spriteFrame = apeng.LevelRollCC.getBgIndexBySf(index, comp.parses, comp);
            this.setPositionY(comp.parses.bgsY[index], false);
        }
    };
    LevelRollCCBg = __decorate([
        apeng.ccclass("LevelRollCCBg"),
        apeng.menuUI("LevelRollCCBg")
    ], LevelRollCCBg);
    apeng.LevelRollCCBg = LevelRollCCBg;
})(apeng || (apeng = {}));

(function (apeng) {
    let LevelRollCCItem = class LevelRollCCItem extends apeng.BaseComponent {
        updateView(comp, index) {
            // this.Label.string = (index + 1) + ""
            this.setPositionXY(comp.parses.itemsY[index], false);
        }
    };
    LevelRollCCItem = __decorate([
        apeng.ccclass("LevelRollCCItem"),
        apeng.menuUI("LevelRollCCItem")
    ], LevelRollCCItem);
    apeng.LevelRollCCItem = LevelRollCCItem;
})(apeng || (apeng = {}));

(function (apeng) {
    let ListCCByBaseItemCC = class ListCCByBaseItemCC extends apeng.BaseComponent {
        listInit() {
        }
    };
    ListCCByBaseItemCC = __decorate([
        apeng.ccclass("ListCCByBaseItemCC"),
        apeng.menuList("ListCCByBaseItemCC")
    ], ListCCByBaseItemCC);
    apeng.ListCCByBaseItemCC = ListCCByBaseItemCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ListCCByLayoutItemRenderCC = class ListCCByLayoutItemRenderCC extends _cc_.Component {
        constructor() {
            super(...arguments);
            this.backupDescribe = "列表使用layout 显隐节点";
        }
    };
    ListCCByLayoutItemRenderCC = __decorate([
        apeng.ccclass("ListCCByLayoutItemRenderCC"),
        apeng.menuList("ListCCByLayoutItemRenderCC")
    ], ListCCByLayoutItemRenderCC);
    apeng.ListCCByLayoutItemRenderCC = ListCCByLayoutItemRenderCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ListRollCC = class ListRollCC extends apeng.CreatePrefabToEditorCC {
        constructor() {
            super(...arguments);
            this.backupDescribe = "列表";
            this.renderTop = 100;
            this.renderBottom = 100;
            this.topPadding = 0;
            this.bottomPadding = 0;
            this.ySpace = 0;
            this.itemHeight = 100;
            this.itemDatas = null;
            this.itemDataLength = -1;
            this.itemHeights = [];
            this.itemYs = [];
            this.itemByIndexs = [];
            this.curRenderMin = -1;
            this.curRenderMax = -1;
            this.itemDataRender = null;
            this.onSizeChange = this.updateRenderRange;
            this.onEventScrolling = this.updateItems;
        }
        /**容器 */
        get content() {
            return this.getChildByCreate("content", (node) => {
                node.addComponent(apeng.Widget);
            }, -1, true);
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                let scroll = this.node.getComponent(apeng.ScrollView);
                if (!scroll) {
                    scroll = this.node.addComponent(apeng.ScrollView);
                    scroll.horizontal = false;
                    scroll.vertical = true;
                    scroll.inertia = true;
                    scroll.brake = .75;
                    scroll.elastic = true;
                    scroll.bounceDuration = .23;
                    scroll.content = this.content;
                    scroll.cancelInnerEvents = true;
                }
                let mask = this.node.getComponent(apeng.Mask);
                if (!mask) {
                    mask = this.node.addComponent(apeng.Mask);
                    mask.inverted = false;
                    mask.type = apeng.Mask.Type.GRAPHICS_RECT;
                }
                return;
            }
            this.addEvent(apeng.ScrollView.EventType.SCROLLING, this.onEventScrolling, this, this.node);
        }
        onEnable() {
            super.onEnable();
            this.updateRange();
            this.scheduleOnceCover(this.updateRange);
        }
        onDisable() {
            this.clearItems();
            super.onDisable();
        }
        updateRange() {
            this.updateRenderRange();
            this.updateContentSize();
        }
        clearItems() {
            this.itemByIndexs.length = 0;
            let items = this.items;
            for (let i = items.length - 1; i >= 0; i--) {
                this.removeItem(items[i]);
            }
        }
        setItemDatas(datas) {
            if (typeof datas == "number") {
                this.itemDatas = null;
                this.itemDataLength = datas;
            }
            else {
                this.itemDatas = datas;
                this.itemDataLength = this.itemDatas.length;
            }
            this.itemYs.length = this.itemDataLength;
            this.itemHeights.length = this.itemDataLength;
            for (let i = 0; i < this.itemDataLength; i++) {
                if (this.itemHeights[i] === undefined)
                    this.itemHeights[i] = this.itemHeight;
                if (this.itemYs[i] === undefined) {
                    this.itemYs[i] = this.getItemY(i);
                }
            }
            this.updateContentSize();
        }
        updateRenderRange() {
            this.curRenderMax = this.renderTop;
            this.curRenderMin = -this.UITransform.height - this.renderBottom;
        }
        updateItems() {
            let isAdd = false;
            let y = this.content.position.y;
            // 在范围内的位置 都应该被渲染
            for (let i = 0; i < this.itemYs.length; i++) {
                // 实时y
                let max = this.itemYs[i] + y;
                let min = max - this.itemHeights[i];
                // 要显示
                if (apeng.Polygon.oneLineLine(min, max, this.curRenderMin, this.curRenderMax)) {
                    if (this.itemByIndexs.indexOf(i) == -1) {
                        this.itemByIndexs.push(i);
                        let item = this.addItem();
                        if (this.itemDataRender)
                            this.itemDataRender(this.itemDatas ? this.itemDatas[i] : i, item, i);
                        isAdd = true;
                    }
                }
                else {
                    let index = this.itemByIndexs.indexOf(i);
                    if (index != -1) {
                        this.itemByIndexs.splice(index, 1);
                        this.removeItem(this.items[index]);
                    }
                }
            }
            if (isAdd)
                this.scheduleOnceCover(this.onDealyAddItem);
        }
        onDealyAddItem() {
            let items = this.items;
            for (let i = 0; i < this.itemByIndexs.length; i++) {
                let index = this.itemByIndexs[i];
                let item = items[i];
                this.itemHeights[index] = apeng.NodeHelper.getUITransform(item).height;
                let y = this.getItemY(index);
                this.itemYs[index] = y;
                apeng.NodeHelper.setPositionY(item, y, false);
            }
            let endYIndex = this.itemByIndexs[this.itemByIndexs.length - 1];
            // 更新最后的所有的y
            for (let i = endYIndex; i < this.itemYs.length; i++) {
                this.itemYs[i] = this.getItemY(i);
            }
            this.updateContentSize();
        }
        getItemY(index) {
            let lastIndex = index - 1;
            let y = 0;
            if (lastIndex == -1)
                y = -this.topPadding;
            else {
                y = this.itemYs[lastIndex] - this.ySpace - this.itemHeights[lastIndex];
            }
            return y;
        }
        updateContentSize() {
            // 手动计算 content高度。只适配了高度 锚点 Y轴 都在 0
            let h = this.topPadding + this.bottomPadding;
            h += Math.max(0, this.itemDataLength - 1) * this.ySpace;
            for (let v of this.itemHeights)
                h += v;
            this.contentUITransform.height = h;
        }
        updateItemData(index) {
            if (this.itemDataRender) {
                let i = apeng.Sets.filterOf(this.itemByIndexs, v => v == index);
                if (i != -1) {
                    this.itemDataRender(this.itemDatas ? this.itemDatas[index] : index, this.items[i], index);
                    this.scheduleOnceCover(this.onDealyAddItem);
                }
            }
        }
        updateItemDatas() {
            for (let index of this.itemByIndexs)
                this.updateItemData(index);
        }
        showIndex(index, offset = 0) {
            let top = this.contentUITransform.anchorY == 1;
            // 手动计算content坐标
            let y = (top ? this.topPadding : this.bottomPadding) + (this.ySpace + this.itemHeight) * index;
            if (index == 0)
                y = 0;
            this.content.setPosition(0, Math.max(0, y + offset));
            this.updateItems();
        }
    };
    __decorate([
        apeng.property({
            displayName: "顶部渲染距离",
        })
    ], ListRollCC.prototype, "renderTop", void 0);
    __decorate([
        apeng.property({
            displayName: "底部渲染距离",
        })
    ], ListRollCC.prototype, "renderBottom", void 0);
    __decorate([
        apeng.property({
            displayName: "上边距",
        })
    ], ListRollCC.prototype, "topPadding", void 0);
    __decorate([
        apeng.property({
            displayName: "下边距",
        })
    ], ListRollCC.prototype, "bottomPadding", void 0);
    __decorate([
        apeng.property({
            displayName: "纵向间距",
        })
    ], ListRollCC.prototype, "ySpace", void 0);
    __decorate([
        apeng.property({
            displayName: "初始item高度",
        })
    ], ListRollCC.prototype, "itemHeight", void 0);
    ListRollCC = __decorate([
        apeng.ccclass("ListRollCC"),
        apeng.executeInEditMode,
        apeng.menuList("ListRollCC")
    ], ListRollCC);
    apeng.ListRollCC = ListRollCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let _uiMaxSize = null;
    /**竖屏手机最大高度 */
    function uiMaxSize() {
        if (_uiMaxSize == null) {
            _uiMaxSize = apeng.winSize().clone();
            if (_uiMaxSize.height / _uiMaxSize.width > 1.98)
                _uiMaxSize.height = _uiMaxSize.width * 1.98;
        }
        return _uiMaxSize;
    }
    apeng.uiMaxSize = uiMaxSize;
    let MaxBoxCC = class MaxBoxCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "可视范围控制";
            this._bottomOffset = 0;
            this._topOffset = 0;
            this._isTop = true;
            this._isBottom = true;
            this.onEditorUpdateData = this.updateView;
        }
        /**空出底部的世界坐标 */
        static worldYBottom() {
            return (apeng.winSize().height - uiMaxSize().height) / 2;
        }
        /**空出顶部部的世界坐标 */
        static worldYTop() {
            let h = uiMaxSize().height;
            return (apeng.winSize().height - h) / 2 + h;
        }
        set isTop(value) {
            if (this._isTop == value)
                return;
            this._isTop = value;
            this.updateView();
        }
        get isTop() { return this._isTop; }
        set topOffset(value) {
            if (this._topOffset == value)
                return;
            this._topOffset = value;
            this.updateView();
        }
        get topOffset() { return this._topOffset; }
        set isBottom(value) {
            if (this._isBottom == value)
                return;
            this._isBottom = value;
            this.updateView();
        }
        get isBottom() { return this._isBottom; }
        set bottomOffset(value) {
            if (this._bottomOffset == value)
                return;
            this._bottomOffset = value;
            this.updateView();
        }
        get bottomOffset() { return this._bottomOffset; }
        onLoad() {
            super.onLoad();
            this.updateView();
        }
        updateView() {
            let size = uiMaxSize();
            let w = size.width;
            let h = size.height;
            let wH = apeng.winSize().height;
            let offset = (wH - h) / 2;
            let y = 0;
            if (!this._isTop) {
                h += offset;
                y += offset / 2;
            }
            else if (!this._isBottom) {
                h += offset;
                y -= offset / 2;
            }
            else if (!this._isTop && this._isBottom) {
                h = wH;
            }
            if (offset != 0) {
                if (this._isTop) {
                    if (this._topOffset != 0) {
                        h += this._topOffset;
                        y += this._topOffset / 2;
                    }
                }
                if (this._isBottom) {
                    if (this._bottomOffset != 0) {
                        h += this._bottomOffset;
                        y -= this._bottomOffset / 2;
                    }
                }
            }
            this.setPositionY(y, false);
            this.setSize(w, h);
        }
    };
    __decorate([
        apeng.property({
            displayName: "空出顶部"
        })
    ], MaxBoxCC.prototype, "isTop", null);
    __decorate([
        apeng.property({
            visible() { return this._isBottom; },
            displayName: "顶部长度偏移"
        })
    ], MaxBoxCC.prototype, "topOffset", null);
    __decorate([
        apeng.property({
            displayName: "空出底部"
        })
    ], MaxBoxCC.prototype, "isBottom", null);
    __decorate([
        apeng.property({
            visible() { return this._isBottom; },
            displayName: "底部长度偏移"
        })
    ], MaxBoxCC.prototype, "bottomOffset", null);
    __decorate([
        apeng.property({ serializable: true })
    ], MaxBoxCC.prototype, "_bottomOffset", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], MaxBoxCC.prototype, "_topOffset", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], MaxBoxCC.prototype, "_isTop", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], MaxBoxCC.prototype, "_isBottom", void 0);
    MaxBoxCC = __decorate([
        apeng.ccclass("MaxBoxCC"),
        apeng.executeInEditMode,
        apeng.menuUI("MaxBoxCC")
    ], MaxBoxCC);
    apeng.MaxBoxCC = MaxBoxCC;
})(apeng || (apeng = {}));
/// <reference path="./Vector3.ts" />

(function (apeng) {
    const ccVec3zero = new apeng.Vector3();
    /**移动组件 支持2d 3d节点移动 */
    class Move {
        constructor() {
            this.endCallBack = new apeng.CompleteCallBack();
            /**移动节点 */
            this.node = null;
            /**世界坐标移动 */
            this.isWorld = true;
            /**移动速度 */
            this.speed = 100;
            /**受到慢镜头影响 */
            this.isSlowMotion = true;
            /**起始位置 */
            this.fromTarget = new apeng.Vector3();
            /**暂停移动 */
            this.isPause = true;
            /**存上次的index 方便做回调处理 */
            this.laseIndex = -1;
            this.lookAtNode = null;
            this.lookAtNodeRotate = -1;
            /**需要移动的全部时间 */
            this.allDuration = 0;
            /**运行的数据 */
            this.states = [];
            /**传入的数据 */
            this.datas = [];
            /**当前正在运行的数据块索引 */
            this._index = -1;
            this.setPosition = null;
            this.getPosition = null;
            this._v3T = new apeng.Vector3();
            this._v3T2 = new apeng.Vector3();
        }
        /**外部实现此方法 避免出现引用 */
        static getPosition(node, isWorld) { return null; }
        /**外部实现此方法 避免出现引用 */
        static setPosition(node, value, isWorld) { return null; }
        /**外部实现此方法 避免出现引用 */
        static lookAt(node, target, rotate = null, defaultRotate = 90) { }
        /**获取帧率 */
        static getDeltaTime(isSlowMotion) { return 1 / 60; }
        /**初始化移动数据 */
        init(node, isWorld, speed, isSlowMotion = true) {
            this.node = node;
            this.isWorld = isWorld;
            this.speed = speed;
            this.isSlowMotion = isSlowMotion;
            this.clear();
        }
        /**清空所有数据 */
        dispose() {
            this.endCallBack.clear();
            this.clear();
            for (let state of this.states)
                Move.IMoveState.put(state);
            this.states.length = 0;
            for (let data of this.datas)
                Move.IMove.put(data);
            this.datas.length = 0;
            this.node = null;
            this.lookAtNode = null;
            this.lookAtNodeRotate = -1;
            this.isWorld = true;
            this.speed = 100;
            this.isSlowMotion = true;
        }
        /**重置移动数据 */
        clear() {
            this.fromTarget.set();
            this.isPause = true;
            this.laseIndex = -1;
            this._index = -1;
            this.allDuration = 0;
        }
        /**
         * 移动时 设置朝向
         * @param node
         * @param rotate
         */
        setLookAt(node, rotate) {
            this.lookAtNode = node;
            this.lookAtNodeRotate = rotate;
        }
        /**设置移动数据 */
        setRunData(length, cb) {
            apeng.Sets.updateItemCount(length, this.datas.length, (add) => {
                if (add)
                    this.datas.push(Move.IMove.get());
                else
                    Move.IMove.put(this.datas.pop());
            });
            for (let i = 0; i < length; i++) {
                Move.IMove.onClear(this.datas[i]);
                cb(this.datas[i], i);
            }
        }
        /**
        * 设置目标位置
        * @param value
        */
        run(complete) {
            let length = this.datas.length;
            if (length == 0)
                return;
            if (length == 1) {
                if (apeng.Vector3.equals((this.getPosition || Move.getPosition)(this.node, this.isWorld), this.datas[0].target)) {
                    if (complete)
                        complete();
                    return;
                }
            }
            this.clear();
            this.endCallBack.set(complete);
            this.fromTarget.set((this.getPosition || Move.getPosition)(this.node, this.isWorld));
            apeng.Sets.updateItemCount(length, this.states.length, (add) => {
                if (add)
                    this.states.push(Move.IMoveState.get());
                else
                    Move.IMoveState.put(this.states.pop());
            });
            for (let i = 0; i < length; i++) {
                let state = this.states[i];
                state.dtTotal = 0;
                if (this.datas[i].delay !== undefined && this.datas[i].delay > 0)
                    state.duration = this.datas[i].delay;
                else
                    state.duration = apeng.Vector3.distance(i == 0 ? this.fromTarget : this.datas[i - 1].target, this.datas[i].target) / this.getTargetSpeed(i);
                state.isPause = false;
                state.endRatioPoint.set();
                state.isStartRatio = this.datas[i].startRatio != undefined;
                this.allDuration += state.duration;
            }
            this.isPause = false;
        }
        getTargetSpeed(index) {
            let speed = this.speed;
            if (!this.states[index])
                return speed;
            if (this.datas[index].speed)
                speed = this.datas[index].speed;
            if (this.datas[index].speedMul)
                speed *= this.datas[index].speedMul;
            return speed;
        }
        onUpdate() {
            if (this.isPause)
                return;
            // 当前运行时间
            let dt = Move.getDeltaTime(this.isSlowMotion);
            // 可能出现进行的时间比帧率更小的情况
            if (dt > this.allDuration) {
                this.isPause = true;
                this.setPopTarget();
                for (let _value of this.datas) {
                    if (_value.onStart)
                        _value.onStart();
                    if (_value.onUpdate)
                        _value.onUpdate(0);
                    if (_value.onEnd)
                        _value.onEnd();
                }
                ;
                this.endCallBack.run();
                return;
            }
            // 当前进行到的索引
            this._index = 0;
            for (let i = 0; i < this.states.length; i++) {
                let state = this.states[i];
                if (!state.isPause) {
                    this._index = i;
                    break;
                }
            }
            let state = this.states[this._index];
            let data = this.datas[this._index];
            let lastData = this.datas[this.laseIndex];
            state.dtTotal += dt;
            // 指定开始移动比率
            if (data.startRatio && state.isStartRatio && data.startRatio != 0) {
                state.isStartRatio = false;
                state.dtTotal += state.duration * data.startRatio - dt;
            }
            let ratio = state.dtTotal / state.duration;
            // 移动到指定比率结束
            if (data.endRatio && ratio >= data.endRatio) {
                // 加上剩下未走完的时间
                state.dtTotal += state.duration * (1 - data.endRatio);
                // 储存最后走到的位置
                state.endRatioPoint.set((this.getPosition || Move.getPosition)(this.node, this.isWorld));
                state.isPause = true;
            }
            if (ratio >= 1)
                state.isPause = true;
            if (data.ease != undefined)
                ratio = apeng.easing(data.ease, ratio);
            let toTarget = this.datas[this._index].target;
            let formTarget = this._index == 0 ? this.fromTarget : this.datas[this._index - 1].target;
            if (data.bezierTarget && !data.bezierTarget.equals(apeng.Vector3.ZERO)) {
                let bezierTargetFrom = formTarget;
                if (data.bezierTargetFrom && !data.bezierTargetFrom.equals(apeng.Vector3.ZERO))
                    bezierTargetFrom = data.bezierTargetFrom;
                // 样条曲线
                if (data.splineTraget && !data.splineTraget.equals(apeng.Vector3.ZERO))
                    apeng.Curve.Spline.vec2.get(bezierTargetFrom, data.bezierTarget, data.splineTraget, toTarget, 0, ratio, this._v3T);
                else {
                    // 将曲线上的点转换为控制点
                    apeng.Curve.Bezier.vec3.getCurveByControl(bezierTargetFrom, toTarget, data.bezierTarget, .5, this._v3T);
                    // 获取移动曲线
                    apeng.Curve.Bezier.vec3.getControlByCurve(bezierTargetFrom, toTarget, this._v3T, ratio, this._v3T);
                }
            }
            else
                apeng.Vector3.lerp(this._v3T, formTarget, toTarget, ratio);
            (this.setPosition || Move.setPosition)(this.node, this._v3T, this.isWorld);
            // 设置朝向
            if (this.lookAtNode) {
                apeng.Vector3.set(this._v3T2, toTarget);
                Move.lookAt(this.lookAtNode, this._v3T2, this.lookAtNodeRotate);
            }
            if (this.laseIndex == -1) {
                if (data.onStart)
                    data.onStart();
            }
            else {
                if (this.laseIndex !== this._index) {
                    if (lastData && lastData.onEnd)
                        lastData.onEnd();
                    if (data.onStart)
                        data.onStart();
                }
            }
            if (data.onUpdate)
                data.onUpdate(ratio);
            this.laseIndex = this._index;
            // 当前速度 到达目标位置得总时间
            if (this._index == this.states.length - 1 && state.isPause) {
                this.isPause = true;
                this.setPopTarget();
                if (this.states != null) {
                    this.endCallBack.run();
                    if (this.datas[this.laseIndex] &&
                        this.datas[this.laseIndex].onEnd)
                        this.datas[this.laseIndex].onEnd();
                }
            }
        }
        setPopTarget() {
            // 设置到暂停位置
            let popValue = this.states[this.states.length - 1];
            let popTarget = this.datas[this.states.length - 1];
            if (!popValue.endRatioPoint.equals(ccVec3zero))
                (this.setPosition || Move.setPosition)(this.node, popValue.endRatioPoint, this.isWorld);
            else
                (this.setPosition || Move.setPosition)(this.node, popTarget.target, this.isWorld);
        }
    }
    Move.pool = new apeng.PoolOnce(1000, () => new Move(), data => data.dispose());
    Move.IMove = new apeng.PoolOnce(1000, () => {
        return {
            target: new apeng.Vector3(),
            bezierTarget: new apeng.Vector3(),
            bezierTargetFrom: new apeng.Vector3(),
            splineTraget: new apeng.Vector3(),
        };
    }, (data) => {
        var _a, _b, _c;
        data.target.set();
        data.speed = undefined;
        data.speedMul = undefined;
        data.ease = undefined;
        data.onUpdate = undefined;
        data.onStart = undefined;
        data.onEnd = undefined;
        data.delay = undefined;
        if (data.bezierTarget)
            (_a = data.bezierTarget) === null || _a === void 0 ? void 0 : _a.set();
        if (data.bezierTargetFrom)
            (_b = data.bezierTargetFrom) === null || _b === void 0 ? void 0 : _b.set();
        if (data.splineTraget)
            (_c = data.splineTraget) === null || _c === void 0 ? void 0 : _c.set();
        data.endRatio = undefined;
        data.startRatio = undefined;
    });
    Move.IMoveState = new apeng.PoolOnce(1000, () => {
        return {
            dtTotal: 0,
            duration: -1,
            isPause: false,
            endRatioPoint: new apeng.Vector3(),
            isStartRatio: false
        };
    }, (data) => {
        data.endRatioPoint.set();
        data.dtTotal = 0;
        data.duration = -1;
        data.isPause = false;
        data.isStartRatio = false;
    });
    apeng.Move = Move;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Ease.ts" />
/// <reference path="./../utils/Move.ts" />

(function (apeng) {
    let MoveCCItem = class MoveCCItem {
        constructor() {
            this.target = null;
            this.targetV3 = new apeng.Vec3();
            this.speed = 0;
            this.speedMul = 1;
            this.ease = apeng.EEaseType.linear;
            this.endRatio = 1;
            this.startRatio = 0;
            this.isBezier = false;
            this.bezierTarget = null;
            this.bezierTargetFrom = null;
            this.isEmitCall = false;
            this.onStart = new apeng.EventHandlerCC();
            this.onEnd = new apeng.EventHandlerCC();
            this.onUpdate = new apeng.EventHandlerCC();
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "目标点"
        })
    ], MoveCCItem.prototype, "target", void 0);
    __decorate([
        apeng.property({
            tooltip: "相对自身位置的目标点 node优先",
            displayName: "相对目标点"
        })
    ], MoveCCItem.prototype, "targetV3", void 0);
    __decorate([
        apeng.property({
            tooltip: "当前段的移速，0代表使用全局的",
            displayName: "移动速度"
        })
    ], MoveCCItem.prototype, "speed", void 0);
    __decorate([
        apeng.property({
            displayName: "速度倍率"
        })
    ], MoveCCItem.prototype, "speedMul", void 0);
    __decorate([
        apeng.property({
            type: apeng.EEaseType,
            displayName: "缓动值"
        })
    ], MoveCCItem.prototype, "ease", void 0);
    __decorate([
        apeng.property({
            displayName: "到指定比率即结束"
        })
    ], MoveCCItem.prototype, "endRatio", void 0);
    __decorate([
        apeng.property({
            displayName: "从开始比率移动"
        })
    ], MoveCCItem.prototype, "startRatio", void 0);
    __decorate([
        apeng.property({
            displayName: "曲线移动"
        })
    ], MoveCCItem.prototype, "isBezier", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "贝塞尔控制点",
            visible() { return this.isBezier; }
        })
    ], MoveCCItem.prototype, "bezierTarget", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "贝塞尔起始点",
            visible() { return this.isBezier; }
        })
    ], MoveCCItem.prototype, "bezierTargetFrom", void 0);
    __decorate([
        apeng.property({
            displayName: "派发回调"
        })
    ], MoveCCItem.prototype, "isEmitCall", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "开始移动时",
            visible() { return this.isEmitCall; }
        })
    ], MoveCCItem.prototype, "onStart", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "移动结束时",
            visible() { return this.isEmitCall; }
        })
    ], MoveCCItem.prototype, "onEnd", void 0);
    __decorate([
        apeng.property({
            type: apeng.EventHandlerCC,
            displayName: "正在移动",
            visible() { return this.isEmitCall; }
        })
    ], MoveCCItem.prototype, "onUpdate", void 0);
    MoveCCItem = __decorate([
        apeng.ccclass("MoveCCItem")
    ], MoveCCItem);
    apeng.MoveCCItem = MoveCCItem;
    let MoveCC = class MoveCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "移动组件";
            this.tag = "";
            this.target = null;
            this.isWorldMove = true;
            this.speed = 100;
            this.loopCount = 1;
            this.autoPlay = false;
            this.node_lookAt = null;
            this.lookAtAngle = 0;
            this.items = [];
            this._move = new apeng.Move();
            this.curLoopCount = 0;
            this.orginPosition = null;
            this.completeCb = null;
            this.endPos = new apeng.Vector3();
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                if (!this.target)
                    this.target = this.node;
                return;
            }
            this._move.init(this.target, this.isWorldMove, this.speed, true);
            if (this.node_lookAt)
                this._move.setLookAt(this.node_lookAt, this.lookAtAngle);
            this._move.setRunData(this.items.length, (data, index) => {
                var _a, _b;
                let item = this.items[index];
                data.speed = item.speed == 0 ? null : item.speed;
                data.speedMul = item.speedMul;
                data.ease = item.ease;
                data.endRatio = item.endRatio;
                data.startRatio = item.startRatio;
                if (item.isEmitCall) {
                    if (item.onStart.isCall)
                        data.onStart = item.onStart.emit.bind(item.onStart, this.node);
                    if (item.onUpdate.isCall)
                        data.onUpdate = item.onUpdate.emit.bind(item.onUpdate, this.node);
                    if (item.onEnd.isCall)
                        data.onEnd = item.onEnd.emit.bind(item.onEnd, this.node);
                }
                if (item.isBezier) {
                    if (item.bezierTarget)
                        (_a = data.bezierTarget) === null || _a === void 0 ? void 0 : _a.set(apeng.NodeHelper.getPosition(item.bezierTarget, this.isWorldMove));
                    if (item.bezierTargetFrom)
                        (_b = data.bezierTargetFrom) === null || _b === void 0 ? void 0 : _b.set(apeng.NodeHelper.getPosition(item.bezierTargetFrom, this.isWorldMove));
                }
                // 添加循环次数
                if (this.items.length == index + 1) {
                    let endCall = data.onEnd;
                    data.onEnd = () => {
                        if (endCall)
                            endCall();
                        apeng.NodeHelper.setPosition(this.target, this.endPos, this.isWorldMove);
                        if (this.completeCb)
                            this.completeCb();
                        this.completeCb = null;
                        this.curLoopCount++;
                        if (this.loopCount == 0)
                            this.startMove();
                        else 
                        // 循环次数达到
                        if (this.curLoopCount < this.loopCount)
                            this.startMove();
                    };
                }
            });
        }
        onEnable() {
            super.onEnable();
            if (apeng.EDITOR)
                return;
            this.curLoopCount = 0;
            if (this.autoPlay)
                this.startMove();
        }
        onDestroy() {
            if (apeng.EDITOR)
                return;
            super.onDestroy();
            this._move.dispose();
        }
        onUpdate() {
            if (apeng.EDITOR)
                return;
            this._move.onUpdate();
        }
        startMove(completeCb) {
            if (!this.node.active) {
                if (completeCb)
                    completeCb();
                return;
            }
            if (!this.orginPosition)
                this.orginPosition = this.node.getPosition();
            else
                this.resetPos();
            if (completeCb)
                this.completeCb = completeCb;
            let index = -1;
            for (let data of this._move.datas) {
                index++;
                let item = this.items[index];
                if (item.target)
                    apeng.Vector3.set(data.target, apeng.NodeHelper.getPosition(item.target, this.isWorldMove));
                else
                    apeng.Vector3.add(data.target, item.targetV3, this.getPosition(this.isWorldMove));
                if (index == this.items.length - 1) {
                    this.endPos.set(data.target);
                }
            }
            this._move.run();
        }
        resetPos() {
            if (this.orginPosition)
                this.node.setPosition(this.orginPosition);
        }
    };
    __decorate([
        apeng.property({
            displayName: "标记"
        })
    ], MoveCC.prototype, "tag", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "移动节点"
        })
    ], MoveCC.prototype, "target", void 0);
    __decorate([
        apeng.property({
            displayName: "世界坐标移动"
        })
    ], MoveCC.prototype, "isWorldMove", void 0);
    __decorate([
        apeng.property({
            displayName: "移动速度"
        })
    ], MoveCC.prototype, "speed", void 0);
    __decorate([
        apeng.property({
            tooltip: "0无限循环",
            displayName: "循环次数"
        })
    ], MoveCC.prototype, "loopCount", void 0);
    __decorate([
        apeng.property({
            displayName: "显示时自动移动"
        })
    ], MoveCC.prototype, "autoPlay", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "设置朝向的节点",
        })
    ], MoveCC.prototype, "node_lookAt", void 0);
    __decorate([
        apeng.property({
            displayName: "看向目标点 朝向旋转角度",
            visible() { return this.node_lookAt; }
        })
    ], MoveCC.prototype, "lookAtAngle", void 0);
    __decorate([
        apeng.property({
            type: [MoveCCItem],
            displayName: "点配置"
        })
    ], MoveCC.prototype, "items", void 0);
    MoveCC = __decorate([
        apeng.ccclass("MoveCC"),
        apeng.executeInEditMode,
        apeng.menuAnim("MoveCC")
    ], MoveCC);
    apeng.MoveCC = MoveCC;
})(apeng || (apeng = {}));
/// <reference path="./../utils/CompleteCallBack.ts" />

(function (apeng) {
    let RenderOpacityAnimCC = class RenderOpacityAnimCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "透明度动画";
            this.speed = 1;
            this.showEaseType = apeng.EEaseType.quadOut;
            this.hideSpeed = 1;
            this.hideEaseType = apeng.EEaseType.quadIn;
            this._curOpacity = 1;
            // private _colorT = new Color(0, 0, 0, 255)
            this.orginOpacity = 0;
            this.isFadeIn = true;
            this.playComplete = new apeng.CompleteCallBack();
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR)
                return;
            this.orginOpacity = this.getOpacity();
            // this.orginOpacity = this.UIRenderer.color.a
            // this._colorT.set(this.UIRenderer.color)
            // this._colorT.a = 0
        }
        onDisable() {
            super.onDisable();
            this._curOpacity = 1;
            this.isFadeIn = true;
            this.playComplete.clear();
        }
        onUpdate() {
            if (this._curOpacity == 1)
                return;
            this._curOpacity = this._curOpacity + apeng._timer.dtDefault * 2 * (this.isFadeIn ? this.speed : this.hideSpeed);
            if (this._curOpacity > 1)
                this._curOpacity = 1;
            let ratio = apeng.easing((this.isFadeIn ? this.showEaseType : this.hideEaseType), this._curOpacity);
            this.updateView(ratio);
            if (this._curOpacity == 1)
                this.playComplete.run();
        }
        /**
         *
         * @param fadeIn 渐显 反之 渐隐
         * @param cb
         */
        play(fadeIn, cb = null, anim = true) {
            if (this.orginOpacity == 0)
                return;
            this.isFadeIn = fadeIn;
            this.playComplete.set(cb);
            if (anim) {
                this._curOpacity = 0;
                this.updateView(this._curOpacity);
            }
            else {
                this._curOpacity = 1;
                this.updateView(this._curOpacity);
                this.playComplete.run();
            }
        }
        updateView(ratio) {
            if (!this.isFadeIn)
                ratio = 1 - ratio;
            this._setOpacity(this.orginOpacity * ratio);
            // this._colorT.a = this.orginOpacity * ratio
            // this.UIRenderer.color = this._colorT
        }
        /**当前动画是否播放完毕 */
        isPlayComplete() {
            return this._curOpacity == 1;
        }
        _setOpacity(ratio) {
            this.setOpacity(ratio);
        }
    };
    __decorate([
        apeng.property({
            displayName: "渐显速度"
        })
    ], RenderOpacityAnimCC.prototype, "speed", void 0);
    __decorate([
        apeng.property({
            type: apeng.EEaseType,
            displayName: "渐显曲线"
        })
    ], RenderOpacityAnimCC.prototype, "showEaseType", void 0);
    __decorate([
        apeng.property({
            displayName: "渐隐速度"
        })
    ], RenderOpacityAnimCC.prototype, "hideSpeed", void 0);
    __decorate([
        apeng.property({
            type: apeng.EEaseType,
            displayName: "渐隐曲线"
        })
    ], RenderOpacityAnimCC.prototype, "hideEaseType", void 0);
    RenderOpacityAnimCC = __decorate([
        apeng.ccclass("RenderOpacityAnimCC"),
        apeng.menuAnim("RenderOpacityAnimCC")
    ], RenderOpacityAnimCC);
    apeng.RenderOpacityAnimCC = RenderOpacityAnimCC;
})(apeng || (apeng = {}));
/// <reference path="./RenderOpacityAnimCC.ts" />

(function (apeng) {
    let OpacityLoopAnimCC = class OpacityLoopAnimCC extends apeng.RenderOpacityAnimCC {
        constructor() {
            super(...arguments);
            this.backupDescribe = "透明度循环动画";
            this.showDelay = 1;
            this.hideDelay = 1;
        }
        onEnable() {
            super.onEnable();
            this.hide();
        }
        show() {
            this.play(true, () => {
                this.scheduleOnce(this.hide, this.showDelay);
            });
        }
        hide() {
            this.play(false, () => {
                this.scheduleOnce(this.show, this.hideDelay);
            });
        }
    };
    __decorate([
        apeng.property({
            displayName: "显示停留时间"
        })
    ], OpacityLoopAnimCC.prototype, "showDelay", void 0);
    __decorate([
        apeng.property({
            displayName: "隐藏停留时间"
        })
    ], OpacityLoopAnimCC.prototype, "hideDelay", void 0);
    OpacityLoopAnimCC = __decorate([
        apeng.ccclass("OpacityLoopAnimCC"),
        apeng.menuAnim("OpacityLoopAnimCC")
    ], OpacityLoopAnimCC);
    apeng.OpacityLoopAnimCC = OpacityLoopAnimCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let ParticleSystem2DCC = class ParticleSystem2DCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "粒子2D";
            this.isAutoPlay = true;
            this.delayPlay = 0;
        }
        onLoad() {
            super.onLoad();
            this.ParticleSystem2D.playOnLoad = false;
        }
        onEnable() {
            super.onEnable();
            if (!apeng.EDITOR) {
                if (this.isAutoPlay)
                    if (this.delayPlay > 0)
                        this.scheduleOnce(this._play, this.delayPlay);
                    else
                        this._play();
            }
        }
        onDisable() {
            super.onDisable();
            if (!apeng.EDITOR)
                this.ParticleSystem2D.stopSystem();
        }
        play(complete) {
            if (!this.isAutoPlay)
                this._play();
            let duration = this.ParticleSystem2D.duration;
            if (duration)
                this.scheduleOnce(complete, duration + 5);
        }
        _play() {
            this.ParticleSystem2D.resetSystem();
        }
    };
    __decorate([
        apeng.property({
            displayName: "激活自动播放"
        })
    ], ParticleSystem2DCC.prototype, "isAutoPlay", void 0);
    __decorate([
        apeng.property({
            displayName: "延迟时间",
            visible() { return this.isAutoPlay; },
        })
    ], ParticleSystem2DCC.prototype, "delayPlay", void 0);
    ParticleSystem2DCC = __decorate([
        apeng.ccclass("ParticleSystem2DCC"),
        apeng.requireComponent(apeng.ParticleSystem2D),
        apeng.menuAnim("ParticleSystem2DCC")
    ], ParticleSystem2DCC);
    apeng.ParticleSystem2DCC = ParticleSystem2DCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const v3T = new apeng.Vec3();
    const CRatio = {
        min: 38,
        max: 101
    };
    let ProgressCC = class ProgressCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                COMPLETE: "COMPLETE",
                CHANGE: "CHANGE",
            };
            this.backupDescribe = "进度条";
            this.sp = null;
            this.lb = null;
            this.lb2 = null;
            this.strAfterPix = "";
            this.strLastPix = "%";
            this.ratioBySpriteLitte = 3;
            this.ratioByLabelLitte = 0;
            this.ratioFollowNode = null;
            this.isDragRatioFollowNode = false;
            this.followNodeXScale = 1;
            this.followNodeXOffset = 0;
            this.ratioPrefab = null;
            this.isToMax = false;
            this.clickAddNode = null;
            this.clickSubNode = null;
            this.clickAddRatio = .1;
            this.maxShow = -1;
            this._ratioPrefabValues = [];
            this._ratio = 0;
            this.onEditorUpdateData = this.updateView;
            this.progress = null;
            this.dtCount = 0;
            this.dtCount2 = 0;
            this.addSpeed = 5;
            this.addSpeed2 = 30;
            this.isRun = false;
            this.maxShowMin = 0;
        }
        set ratio(value) {
            if (this._ratio == value)
                return;
            this._ratio = this.isToMax ? value : apeng.Maths.clamp01(value);
            if (this.maxShow > 0) {
                let one = 1 / this.maxShow;
                let count = Math.max(this.maxShowMin, Math.round(this._ratio / one));
                this._ratio = one * count;
            }
            else if (this.maxShow == 0) {
                this._ratio = 0;
            }
            this.node.emit(this.EventType.CHANGE, this._ratio);
            this.updateView();
        }
        get ratio() { return this._ratio; }
        set ratioPrefabValues(value) {
            this._ratioPrefabValues = value;
            this.updateView();
        }
        get ratioPrefabValues() { return this._ratioPrefabValues; }
        /**模拟进度跑慢 */
        get isRunMax() { return this.dtCount == CRatio.max && this.dtCount2 == CRatio.min; }
        onEditorClearData() {
            let ratioPrefabValuesParent = this.getChildByCreate("ratioPrefabValuesParent", () => { });
            apeng.Sets.forEach(ratioPrefabValuesParent.children, node => {
                node.destroy();
            }, true);
        }
        onLoad() {
            super.onLoad();
            if (this.isDragRatioFollowNode)
                if (this.ratioFollowNode)
                    this.addEvent(apeng.Node.EventType.TOUCH_MOVE, (e) => {
                        v3T.set(e.getUILocation().x, 0, 0);
                        this.convertToNodeSpaceAR(v3T, v3T);
                        v3T.x += this.UITransform.width * this.UITransform.anchorX;
                        this.ratio = apeng.Maths.clamp01(v3T.x / this.UITransform.width);
                    }, this, this.ratioFollowNode);
            if (this.clickAddNode)
                apeng.EventHandlerCC.onClick(this.clickAddNode, () => {
                    this.ratio += this.clickAddRatio;
                }, this);
            if (this.clickSubNode)
                apeng.EventHandlerCC.onClick(this.clickSubNode, () => {
                    this.ratio -= this.clickAddRatio;
                }, this);
            this.updateView();
        }
        onUpdate() {
            if (!this.isRun)
                return;
            let ratio = 0;
            if (this.progress)
                ratio = this.progress();
            let dt = apeng._timer.dtDefault;
            this.dtCount = Math.min(this.dtCount + dt * this.addSpeed2, CRatio.max);
            this.dtCount2 = Math.min(this.dtCount2 + dt * this.addSpeed, CRatio.min);
            let _ratio = (ratio * 70 + (this.dtCount + this.dtCount2) * .3) / 100;
            // 只加不减
            this.ratio = Math.max(_ratio, this._ratio);
            if (this._ratio >= 1) {
                this.isRun = false;
                this.dtCount = CRatio.max;
                this.dtCount2 = CRatio.min;
                this.node.emit(this.EventType.COMPLETE);
            }
        }
        /**
         * 设置分段显示
         * @param count
         */
        setMaxShow(maxCount, min = 0, curCount = -1) {
            this.maxShow = maxCount;
            this.maxShowMin = min;
            this.clickAddRatio = 1 / maxCount;
            if (curCount != -1) {
                this._ratio = -1;
                this.ratio = this.clickAddRatio * curCount;
            }
        }
        getMaxCurCount() {
            return Math.round(this._ratio * this.maxShow);
        }
        /**
         * 模拟进度
         * @param progress
         * @param durtion 持续时长
         */
        run(progress, durtion) {
            this.progress = progress;
            this.dtCount = 0;
            this.dtCount2 = 0;
            this.ratio = 0;
            if (durtion && durtion > 0) {
                this.addSpeed2 = CRatio.max / durtion;
                this.addSpeed = CRatio.min / durtion;
            }
            else {
                this.addSpeed = 5;
                this.addSpeed2 = 30;
            }
            this.isRun = true;
            this.updateView();
        }
        getRatioByLocalX(ratio) {
            return this.UITransform.width * (ratio - this.UITransform.anchorX);
        }
        getRatioByWorldX(ratio) {
            let x = this.getRatioByLocalX(ratio);
            v3T.set(x, 0, 0);
            this.convertToWorldSpaceAR(v3T, v3T);
            return v3T.x;
        }
        updateView() {
            let _ratio = this._ratio;
            if (this.sp) {
                let ratio = apeng.Maths.clamp01(_ratio);
                let mul = Math.pow(10, this.ratioBySpriteLitte);
                ratio = Math.floor(ratio * mul) / mul;
                this.sp.fillRange = ratio;
            }
            let strRatio = _ratio * 100;
            if (this.ratioByLabelLitte > 0)
                strRatio = strRatio.toFixed(this.ratioByLabelLitte);
            else
                strRatio = Math.floor(strRatio);
            if (this.maxShow >= 0)
                strRatio = this.getMaxCurCount();
            let str = this.strAfterPix + strRatio + this.strLastPix;
            if (this.maxShow >= 0)
                str += this.maxShow;
            if (this.lb)
                this.lb.string = str;
            if (this.lb2)
                this.lb2.string = str;
            v3T.set(this.getRatioByLocalX(apeng.Maths.clamp01(_ratio)) * this.followNodeXScale, 0, 0);
            v3T.x += this.followNodeXOffset;
            if (this.ratioFollowNode) {
                if (this.ratioFollowNode.parent == this.node)
                    apeng.NodeHelper.setPositionX(this.ratioFollowNode, v3T.x, false);
                else {
                    this.convertSelfToOtherNodeSpaceAR(v3T, this.ratioFollowNode.parent, v3T);
                    apeng.NodeHelper.setPositionX(this.ratioFollowNode, v3T.x, false);
                }
            }
            let ratioPrefabValuesParent = this.getChildByCreate("ratioPrefabValuesParent", () => { });
            apeng.Sets.updateItemCount(this._ratioPrefabValues.length, ratioPrefabValuesParent.children.length, (add) => {
                if (add) {
                    let node = apeng.instantiate(this.ratioPrefab);
                    apeng.NodeHelper.setPositionY(node, 0, false);
                    ratioPrefabValuesParent.addChild(node);
                }
                else {
                    let node = apeng.Sets.pop(this.node.children, false);
                    if (node) {
                        node.removeFromParent();
                        node.destroy();
                    }
                }
            });
            let i = 0;
            for (let node of ratioPrefabValuesParent.children) {
                let ratio = this._ratioPrefabValues[i];
                apeng.NodeHelper.setPositionX(node, this.getRatioByLocalX(ratio), false);
                let state = _ratio >= ratio ? 0 : 1;
                // 如果预制体上有这些组件 则设置状态
                let comp = node.getComponent("SwitchChildrenCC");
                if (comp)
                    comp.setIndex(state);
                let comp2 = node.getComponent("SwitchSpriteCC");
                if (comp2)
                    comp2.setIndex(state);
                let comp3 = node.getComponent("ControllerCC");
                if (comp3)
                    comp3.setIndex(state);
                i++;
            }
        }
        getRatioValues() {
            return this._ratioPrefabValues;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Sprite,
            displayName: "进度条图片"
        })
    ], ProgressCC.prototype, "sp", void 0);
    __decorate([
        apeng.property({
            type: apeng.Label,
            displayName: "文字"
        })
    ], ProgressCC.prototype, "lb", void 0);
    __decorate([
        apeng.property({
            type: apeng.FontCC,
            displayName: "文字2"
        })
    ], ProgressCC.prototype, "lb2", void 0);
    __decorate([
        apeng.property({
            displayName: "文字节点前缀",
            visible() { return !!(this.lb || this.lb2); },
        })
    ], ProgressCC.prototype, "strAfterPix", void 0);
    __decorate([
        apeng.property({
            displayName: "文字节点后缀",
            visible() { return !!(this.lb || this.lb2); },
        })
    ], ProgressCC.prototype, "strLastPix", void 0);
    __decorate([
        apeng.property({
            range: [0, 1, 0.01],
            slide: true,
            displayName: "进度百分比"
        })
    ], ProgressCC.prototype, "ratio", null);
    __decorate([
        apeng.property({
            displayName: "进度图片取几位小数",
            visible() { return !!this.sp; },
        })
    ], ProgressCC.prototype, "ratioBySpriteLitte", void 0);
    __decorate([
        apeng.property({
            displayName: "进度文本取几位小数",
            visible() { return !!(this.lb || this.lb2); },
        })
    ], ProgressCC.prototype, "ratioByLabelLitte", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "进度跟随节点"
        })
    ], ProgressCC.prototype, "ratioFollowNode", void 0);
    __decorate([
        apeng.property({
            displayName: "跟随节点可拖动",
            visible() { return !!this.ratioFollowNode; },
        })
    ], ProgressCC.prototype, "isDragRatioFollowNode", void 0);
    __decorate([
        apeng.property({
            range: [0, 1],
            slide: true,
            displayName: "跟随节点位置缩放比率",
            visible() { return !!this.ratioFollowNode; },
        })
    ], ProgressCC.prototype, "followNodeXScale", void 0);
    __decorate([
        apeng.property({
            displayName: "跟随节点位置偏移",
            visible() { return !!this.ratioFollowNode; },
        })
    ], ProgressCC.prototype, "followNodeXOffset", void 0);
    __decorate([
        apeng.property({
            type: apeng.Prefab,
            displayName: "比率节点"
        })
    ], ProgressCC.prototype, "ratioPrefab", void 0);
    __decorate([
        apeng.property({
            type: [apeng.CCFloat],
            visible() { return !!this.ratioPrefab; },
            displayName: "个数"
        })
    ], ProgressCC.prototype, "ratioPrefabValues", null);
    __decorate([
        apeng.property({
            displayName: "可超出1"
        })
    ], ProgressCC.prototype, "isToMax", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击+"
        })
    ], ProgressCC.prototype, "clickAddNode", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "点击-"
        })
    ], ProgressCC.prototype, "clickSubNode", void 0);
    __decorate([
        apeng.property({
            displayName: "点击递增比率"
        })
    ], ProgressCC.prototype, "clickAddRatio", void 0);
    __decorate([
        apeng.property({
            displayName: "最大值并滑动整数"
        })
    ], ProgressCC.prototype, "maxShow", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ProgressCC.prototype, "_ratioPrefabValues", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], ProgressCC.prototype, "_ratio", void 0);
    ProgressCC = __decorate([
        apeng.ccclass("ProgressCC"),
        apeng.executeInEditMode,
        apeng.menuUI("ProgressCC")
    ], ProgressCC);
    apeng.ProgressCC = ProgressCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let spSkeleton = apeng.sp ? apeng.sp.Skeleton : apeng.Asset;
    let SpineCC = class SpineCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "龙骨组件";
            this.anim = null;
            this.curPlayAnimName = "";
            this.loop = true;
            this.curState = null;
            this.lastPlayAnim = "";
            this.initTimeScale = 1;
            this.curPlayAnimNameCb = new apeng.CompleteCallBack();
        }
        onLoad() {
            super.onLoad();
            // 自动添加组件
            if (apeng.EDITOR) {
                if (!this.anim)
                    this.anim = this.getComponent(apeng.sp.Skeleton);
                return;
            }
            if (!this.anim)
                return;
            this.initTimeScale = this.anim.timeScale;
            this.anim.setCompleteListener(this.onEventAnimFinish.bind(this));
        }
        onDisable() {
            if (!apeng.EDITOR) {
                this.curPlayAnimName = "";
                this.lastPlayAnim = "";
                this.curState = null;
                this.stop();
            }
            super.onDisable();
        }
        onEventAnimFinish() {
            this.curPlayAnimNameCb.run();
        }
        stop() {
            if (!this.anim)
                return;
            // if (sp)
            //     if (this.anim.defaultCacheMode == sp.Skeleton.AnimationCacheMode.REALTIME)
            //         this.anim.clearTrack(0)
            this.curPlayAnimNameCb.clear();
        }
        /**暂停动画 */
        pause() {
            if (!this.anim)
                return;
            this.anim.timeScale = 0;
        }
        resume() {
            if (!this.anim)
                return;
            this.anim.timeScale = this.initTimeScale;
        }
        /**
         * 播放龙骨
         * @param animName 播放的名称
         * @param playTimes 播放次数 0循环
         * @param cb
         * @returns
         */
        play(animName, loop, cb, checkCur = true) {
            if (!this.anim)
                return;
            if (!animName)
                return;
            if (checkCur)
                if (this.curPlayAnimName == animName)
                    return;
            if (this.curPlayAnimName)
                this.lastPlayAnim = this.curPlayAnimName;
            this.curPlayAnimName = animName;
            this.loop = loop;
            this.curPlayAnimNameCb.set(cb);
            this.curState = this.anim.setAnimation(0, animName, loop);
        }
        playDefault(loop = false, cb) {
            if (!this.anim)
                return;
            let animName = this.anim.animation;
            if (!animName)
                animName = this.animNames()[0];
            this.play(animName, loop, cb, false);
        }
        playRandom(loop = false, cb) {
            if (!this.anim)
                return;
            this.play(apeng.Sets.random(this.animNames()), loop, cb);
        }
        /**当前动画是否播放完毕 */
        hasPlayComplete(animName = "") {
            if (!this.curState)
                return true;
            if (animName && this.curPlayAnimName != animName)
                return true;
            return this.curState.isComplete();
        }
        animNames() {
            if (!this.anim)
                return [];
            return this.anim.skeletonData.getRuntimeData().animations.map(v => v.name);
        }
    };
    __decorate([
        apeng.property({
            type: spSkeleton,
            displayName: "动画组件",
        })
    ], SpineCC.prototype, "anim", void 0);
    SpineCC = __decorate([
        apeng.ccclass("SpineCC"),
        apeng.menuAnim("SpineCC"),
        apeng.executeInEditMode,
        apeng.requireComponent(apeng.UITransform)
    ], SpineCC);
    apeng.SpineCC = SpineCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let SpriteEnableFadeInCC = class SpriteEnableFadeInCC extends apeng.RenderOpacityAnimCC {
        constructor() {
            super(...arguments);
            this.backupDescribe = "激活时渐显";
        }
        onEnable() {
            super.onEnable();
            this.play(true);
        }
    };
    SpriteEnableFadeInCC = __decorate([
        apeng.ccclass("SpriteEnableFadeInCC"),
        apeng.menuAnim("SpriteEnableFadeInCC")
    ], SpriteEnableFadeInCC);
    apeng.SpriteEnableFadeInCC = SpriteEnableFadeInCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let SpriteFrameAnimCCItem = class SpriteFrameAnimCCItem {
        constructor() {
            this.sfs = [];
        }
    };
    __decorate([
        apeng.property({
            type: [apeng.SpriteFrame],
            displayName: "帧图片",
        })
    ], SpriteFrameAnimCCItem.prototype, "sfs", void 0);
    SpriteFrameAnimCCItem = __decorate([
        apeng.ccclass("SpriteFrameAnimCCItem")
    ], SpriteFrameAnimCCItem);
    apeng.SpriteFrameAnimCCItem = SpriteFrameAnimCCItem;
    let SpriteFrameAnimCC = class SpriteFrameAnimCC extends apeng.Component {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**单次播放完成 */
                PLAY_COMPLETE: "PLAY_COMPLETE",
                /**总次数播放完成 */
                PLAY_COUNT_COMPLETE: "PLAY_COUNT_COMPLETE",
            };
            this.backupDescribe = "序列帧动画";
            this.items = [];
            this.itemIndex = 0;
            this.fps = 10;
            this.autoPlay = true;
            this.playCount = 0;
            this.sp = null;
            this._dts = 0;
            this._index = 0;
            this._count = 0;
            this.isPause = false;
        }
        get item() { return this.items[this.itemIndex]; }
        onLoad() {
            this.sp = this.getComponent(apeng.Sprite);
        }
        onEnable() {
            this._index = 0;
            this._dts = 0;
            this._count = 0;
            this.setIndex(this.item, this._index);
            if (this.autoPlay)
                this.isPause = false;
            else
                this.isPause = true;
        }
        update(dt) {
            if (this.isPause)
                return;
            this._dts += dt;
            if (this._dts > (1 / this.fps)) {
                this._dts = 0;
                this._index++;
                let item = this.item;
                if (item) {
                    let len = item.sfs.length;
                    let index = this._index % len;
                    this.setIndex(item, index);
                    if (this.playCount > 0)
                        if (index == len - 1) {
                            this._count++;
                            this.node.emit(this.EventType.PLAY_COMPLETE);
                            if (this._count >= this.playCount) {
                                this.isPause = false;
                                this.node.emit(this.EventType.PLAY_COUNT_COMPLETE);
                            }
                        }
                }
            }
        }
        registAnimComplete(cb) {
            this.node.once(this.EventType.PLAY_COUNT_COMPLETE, cb);
        }
        setIndex(item, index) {
            if (item)
                this.sp.spriteFrame = item.sfs[index] || null;
        }
    };
    __decorate([
        apeng.property({
            type: [SpriteFrameAnimCCItem],
            displayName: "帧队列",
        })
    ], SpriteFrameAnimCC.prototype, "items", void 0);
    __decorate([
        apeng.property({
            displayName: "队列索引",
        })
    ], SpriteFrameAnimCC.prototype, "itemIndex", void 0);
    __decorate([
        apeng.property({
            tooltip: "一秒多少帧,1/fps"
        })
    ], SpriteFrameAnimCC.prototype, "fps", void 0);
    __decorate([
        apeng.property({
            displayName: "激活播放",
        })
    ], SpriteFrameAnimCC.prototype, "autoPlay", void 0);
    __decorate([
        apeng.property({
            tooltip: "0无限循环，>0指定次数",
            displayName: "播放次数",
        })
    ], SpriteFrameAnimCC.prototype, "playCount", void 0);
    SpriteFrameAnimCC = __decorate([
        apeng.ccclass("SpriteFrameAnimCC"),
        apeng.executeInEditMode,
        apeng.menuAnim("SpriteFrameAnimCC"),
        apeng.requireComponent(apeng.Sprite)
    ], SpriteFrameAnimCC);
    apeng.SpriteFrameAnimCC = SpriteFrameAnimCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let EAlignType;
    (function (EAlignType) {
        EAlignType[EAlignType["Left"] = 0] = "Left";
        EAlignType[EAlignType["Center"] = 1] = "Center";
        EAlignType[EAlignType["Right"] = 2] = "Right";
    })(EAlignType = apeng.EAlignType || (apeng.EAlignType = {}));
    apeng.ccenum(EAlignType);
    let EVertAlignType;
    (function (EVertAlignType) {
        EVertAlignType[EVertAlignType["Top"] = 0] = "Top";
        EVertAlignType[EVertAlignType["Middle"] = 1] = "Middle";
        EVertAlignType[EVertAlignType["Bottom"] = 2] = "Bottom";
    })(EVertAlignType = apeng.EVertAlignType || (apeng.EVertAlignType = {}));
    apeng.ccenum(EVertAlignType);
    let ESpriteSimpleFillType;
    (function (ESpriteSimpleFillType) {
        ESpriteSimpleFillType[ESpriteSimpleFillType["None"] = 0] = "None";
        /**自由缩放 */
        ESpriteSimpleFillType[ESpriteSimpleFillType["Scale"] = 1] = "Scale";
        /**等比缩放(适应高度) */
        ESpriteSimpleFillType[ESpriteSimpleFillType["ScaleByHeight"] = 2] = "ScaleByHeight";
        /**等比缩放(适应宽度) */
        ESpriteSimpleFillType[ESpriteSimpleFillType["ScaleByWidth"] = 3] = "ScaleByWidth";
        /**等比缩放(显示全部) */
        ESpriteSimpleFillType[ESpriteSimpleFillType["ScaleShowAll"] = 4] = "ScaleShowAll";
        /**等比缩放(无边框) */
        ESpriteSimpleFillType[ESpriteSimpleFillType["ScaleNoBorder"] = 5] = "ScaleNoBorder";
    })(ESpriteSimpleFillType = apeng.ESpriteSimpleFillType || (apeng.ESpriteSimpleFillType = {}));
    apeng.ccenum(ESpriteSimpleFillType);
    const v2T = new apeng.Vector2();
    let SpriteLoaderCC = class SpriteLoaderCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "模拟fgui装载器";
            this.isLanguage = false;
            this.enterLoadQueue2 = true;
            this.autoLoad = true;
            this.spriteFrameByUuid = "";
            this.spriteFrameDeep = null;
            this._alignType = EAlignType.Center;
            this._vertAlignType = EVertAlignType.Middle;
            this._spriteSimpleFillType = ESpriteSimpleFillType.None;
            this._shrinkOnly = false;
            this._bindLoad = true;
            this._autoSize = false;
            this._isTrim = true;
            this._mat = null;
            this._spriteFrame = null;
            this._spriteColor = new apeng.Color(255, 255, 255, 255);
            this.spriteFrameUrl = "";
            this.orginSpriteFrameUrl = "";
            /**图片是否加载成功 */
            this.isLoadSpriteFrame = false;
            this.loadSpriteFrames = new apeng.Sets();
            this._listByMark = false;
            this._listByMarkUrl = "";
            this._loadSf = null;
            this._sp = null;
        }
        set mat(value) {
            if (this._mat == value)
                return;
            this._mat = value;
            this.getSprite().customMaterial = this._mat;
        }
        get mat() { return this._mat; }
        set bindLoad(value) {
            if (this._bindLoad == value)
                return;
            this._bindLoad = value;
            this.updateBindLoad();
        }
        get bindLoad() { return this._bindLoad; }
        set spriteColor(value) {
            if (this._spriteColor.equals(value))
                return;
            this._spriteColor = value;
            let _sprite = this.getSprite();
            if (_sprite && _sprite.spriteFrame)
                _sprite.color = this._spriteColor;
        }
        get spriteColor() { return this._spriteColor; }
        set spriteFrame(value) {
            if (this._spriteFrame == value)
                return;
            this._spriteFrame = value;
            this.spriteFrameByUuid = this._spriteFrame ? this._spriteFrame._uuid : "";
            this.updateLayout();
        }
        get spriteFrame() { return this._spriteFrame; }
        set spriteSimpleFillType(value) {
            if (this._spriteSimpleFillType == value)
                return;
            this._spriteSimpleFillType = value;
            this.updateLayout();
        }
        get spriteSimpleFillType() { return this._spriteSimpleFillType; }
        set isTrim(value) {
            if (this._isTrim == value)
                return;
            this._isTrim = value;
            this.updateLayout();
        }
        get isTrim() { return this._isTrim; }
        set shrinkOnly(value) {
            if (this._shrinkOnly == value)
                return;
            this._shrinkOnly = value;
            this.updateLayout();
        }
        get shrinkOnly() { return this._shrinkOnly; }
        set autoSize(value) {
            if (this._autoSize == value)
                return;
            this._autoSize = value;
            this.updateLayout();
        }
        get autoSize() { return this._autoSize; }
        set alignType(value) {
            if (this._alignType == value)
                return;
            this._alignType = value;
            this.updateLayout();
        }
        get alignType() { return this._alignType; }
        set vertAlignType(value) {
            if (this._vertAlignType == value)
                return;
            this._vertAlignType = value;
            this.updateLayout();
        }
        get vertAlignType() { return this._vertAlignType; }
        onEditorUpdateData() {
            this.updateLayout();
            this.updateBindLoad();
        }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                this.updateLayout();
                this.updateBindLoad();
                return;
            }
            this._spriteFrame = null;
            // 打包后 图片已剔除 异步加载
            if (this.autoLoad)
                this.loadDefaultSpriteFrame();
            // 包释放完成时 重新加载图片
            // this.addEvent(ResoucesMgr.EventType.RELEASE_ALL, () => {
            // 	if (this.spriteFrameUrl)
            // 		this.setSpriteFrameUrl(this.spriteFrameUrl)
            // 	else
            // 		this.loadDefaultSpriteFrame()
            // }, this, ResoucesMgr)
            if (this.isLanguage)
                this.addEvent(apeng._language.EventType.CHANGE, (complete) => {
                    if (this.orginSpriteFrameUrl)
                        this.setSpriteFrameUrl(apeng._language.converSpriteFrameUrl(this.orginSpriteFrameUrl), true, null, complete);
                    else
                        complete();
                }, this, apeng._language);
        }
        onEnable() {
            super.onEnable();
            if (!apeng.EDITOR)
                if (this.isLanguage)
                    if (this.orginSpriteFrameUrl)
                        this.setSpriteFrameUrl(this.orginSpriteFrameUrl, true);
        }
        onDisable() {
            if (!apeng.EDITOR) {
                if (!this._sp || !this._sp.spriteFrame)
                    this.spriteFrameUrl = "";
                // 取消加载的队列
                apeng._resouces.cancleSpriteFrame(this._loadSf);
            }
            super.onDisable();
        }
        onDestroy() {
            this.loadSpriteFrames.forEach(v => {
                v.decRef(true);
            });
            this.loadSpriteFrames.clear();
            super.onDestroy();
        }
        /**显示后加载图片 */
        listByMark(visible) {
            this._listByMark = visible;
            // 真正加载
            if (!visible)
                this.scheduleOnceCover(this.onDelayListByMarkSetSprite, 1);
        }
        onDelayListByMarkSetSprite() {
            if (!this._listByMark)
                this.setSpriteFrameUrl(this._listByMarkUrl, true);
        }
        /**加载默认的图片 */
        loadDefaultSpriteFrame(cb) {
            this._spriteFrame = null;
            this.setSpriteFrameUrl(apeng._resouces.getUuidByUrl(this.spriteFrameByUuid), false, cb);
        }
        setSpriteFrameUrl(url, update = false, cb, cb2) {
            if (this._listByMark) {
                this._listByMarkUrl = url;
                cb && cb();
                cb2 && cb2();
                return;
            }
            if (!url) {
                console.error("检查图片路径--节点名:" + this.node.name);
                cb && cb();
                cb2 && cb2();
                return;
            }
            this.orginSpriteFrameUrl = url;
            if (this.isLanguage && !apeng.EDITOR) {
                let sfName = "/spriteFrame";
                let index = url.indexOf(sfName);
                if (index != -1)
                    url = url.substr(0, index);
                url = apeng._language.getSpriteFrame(url);
            }
            if (this.spriteFrameUrl == url && !update) {
                cb2 && cb2();
                return;
            }
            this.spriteFrameUrl = url;
            let sp = this.getSprite();
            this._loadSf = apeng._resouces.setSpriteFrame(sp, url, (sf) => {
                if (!sf) {
                    this.spriteFrameUrl = "";
                    cb2 && cb2();
                    return;
                }
                this._spriteFrame = sf;
                this.isLoadSpriteFrame = true;
                if (this._spriteFrame)
                    this.spriteFrameByUuid = this._spriteFrame._uuid;
                this._spriteFrame.addRef();
                this.loadSpriteFrames.add(this._spriteFrame);
                sp.spriteFrame = this._spriteFrame;
                this.updateLayout();
                cb && cb();
                cb2 && cb2();
            }, this.enterLoadQueue2);
        }
        setSpriteFrame(sf) {
            this._spriteFrame = sf;
            this.updateLayout();
        }
        updateBindLoad() {
            if (!this._spriteFrame)
                return;
            if (this.autoLoad) {
                if (this.bindLoad)
                    this.spriteFrameDeep = this._spriteFrame;
                else
                    this.spriteFrameDeep = null;
            }
            else
                this.spriteFrameDeep = null;
        }
        getSprite() {
            if (!this._sp)
                this._sp = this.getChildByCreate(this.uuid + "sprite", (node) => {
                    let trans = node.getComponent(apeng.UITransform);
                    trans.setAnchorPoint(0, 1);
                    let sp = node.addComponent(apeng.Sprite);
                    if (this._mat && !sp.customMaterial) {
                        sp.customMaterial = this._mat;
                    }
                    // sp.spriteFrame = this._spriteFrame
                    sp.type = apeng.Sprite.Type.SIMPLE;
                }, 0).getComponent(apeng.Sprite);
            return this._sp;
        }
        onSizeChange() {
            this.updateLayout();
        }
        updateLayout() {
            let sp = this.getSprite();
            if (apeng.EDITOR)
                sp.spriteFrame = this._spriteFrame;
            sp.color = this._spriteColor;
            sp.trim = this._isTrim;
            if (!this._spriteFrame)
                return;
            let sourceSize = this._spriteFrame.originalSize;
            let cw = sourceSize.width;
            let ch = sourceSize.height;
            let pivotCorrectX = -(this.UITransform.anchorX) * this.UITransform.width;
            let pivotCorrectY = (this.UITransform.anchorY) * this.UITransform.height;
            if (this._autoSize) {
                if (cw == 0)
                    cw = 50;
                if (ch == 0)
                    ch = 30;
                this.setSize(cw, ch);
                pivotCorrectX = -(this.UITransform.anchorX) * this.UITransform.width;
                pivotCorrectY = (1 - this.UITransform.anchorY) * this.UITransform.height;
                sp.getComponent(apeng.UITransform).setContentSize(cw, ch);
                v2T.set(pivotCorrectX, pivotCorrectY);
                apeng.NodeHelper.setPositionXY(sp.node, v2T, false);
                return;
            }
            let sx = 1, sy = 1;
            if (this._spriteSimpleFillType != ESpriteSimpleFillType.None) {
                sx = this.UITransform.width / sourceSize.width;
                sy = this.UITransform.height / sourceSize.height;
                if (sx != 1 || sy != 1) {
                    if (this._spriteSimpleFillType == ESpriteSimpleFillType.ScaleByHeight)
                        sx = sy;
                    else if (this._spriteSimpleFillType == ESpriteSimpleFillType.ScaleByWidth)
                        sy = sx;
                    else if (this._spriteSimpleFillType == ESpriteSimpleFillType.Scale) {
                        if (sx > sy)
                            sx = sy;
                        else
                            sy = sx;
                    }
                    else if (this._spriteSimpleFillType == ESpriteSimpleFillType.ScaleNoBorder) {
                        if (sx > sy)
                            sy = sx;
                        else
                            sx = sy;
                    }
                    if (this._shrinkOnly) {
                        if (sx > 1)
                            sx = 1;
                        if (sy > 1)
                            sy = 1;
                    }
                    cw = sourceSize.width * sx;
                    ch = sourceSize.height * sy;
                }
            }
            sp.getComponent(apeng.UITransform).setContentSize(cw, ch);
            let nx, ny;
            if (this._alignType == EAlignType.Left)
                nx = 0;
            else if (this._alignType == EAlignType.Center)
                nx = Math.floor((this.UITransform.width - cw) / 2);
            else
                nx = this.UITransform.width - cw;
            if (this._vertAlignType == EVertAlignType.Top)
                ny = 0;
            else if (this._vertAlignType == EVertAlignType.Middle)
                ny = Math.floor((this.UITransform.height - ch) / 2);
            else
                ny = this.UITransform.height - ch;
            ny = -ny;
            v2T.set(pivotCorrectX + nx, pivotCorrectY + ny);
            apeng.NodeHelper.setPositionXY(sp.node, v2T, false);
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Material,
            displayName: "设置材质"
        })
    ], SpriteLoaderCC.prototype, "mat", null);
    __decorate([
        apeng.property({
            tooltip: "使用多语言 的路径加载",
            displayName: "多语言"
        })
    ], SpriteLoaderCC.prototype, "isLanguage", void 0);
    __decorate([
        apeng.property({
            tooltip: "加载图片队列 一部分一部分加载",
            displayName: "进入加载队列"
        })
    ], SpriteLoaderCC.prototype, "enterLoadQueue2", void 0);
    __decorate([
        apeng.property({
            displayName: "激活自动加载",
        })
    ], SpriteLoaderCC.prototype, "autoLoad", void 0);
    __decorate([
        apeng.property({
            tooltip: "绑定到资源加载时加载，反之onLoad加载",
            displayName: "绑定加载",
            visible() { return this.autoLoad; }
        })
    ], SpriteLoaderCC.prototype, "bindLoad", null);
    __decorate([
        apeng.property({
            type: apeng.Color,
            displayName: "颜色"
        })
    ], SpriteLoaderCC.prototype, "spriteColor", null);
    __decorate([
        apeng.property({
            // readonly: true,
            tooltip: "会在onLoad时进行加载图片",
            displayName: "图片uuid"
        })
    ], SpriteLoaderCC.prototype, "spriteFrameByUuid", void 0);
    __decorate([
        apeng.property({
            type: apeng.SpriteFrame,
            displayName: "原图片"
        })
    ], SpriteLoaderCC.prototype, "spriteFrame", null);
    __decorate([
        apeng.property({
            // readonly: true,
            type: apeng.SpriteFrame,
            displayName: "引用图片 方便绑定加载",
            visible() { return this.autoLoad && this.bindLoad; }
        })
    ], SpriteLoaderCC.prototype, "spriteFrameDeep", void 0);
    __decorate([
        apeng.property({
            type: ESpriteSimpleFillType,
            displayName: "填充处理"
        })
    ], SpriteLoaderCC.prototype, "spriteSimpleFillType", null);
    __decorate([
        apeng.property({
            displayName: "裁剪透明像素"
        })
    ], SpriteLoaderCC.prototype, "isTrim", null);
    __decorate([
        apeng.property({
            displayName: "仅允许缩小"
        })
    ], SpriteLoaderCC.prototype, "shrinkOnly", null);
    __decorate([
        apeng.property({
            displayName: "自动大小"
        })
    ], SpriteLoaderCC.prototype, "autoSize", null);
    __decorate([
        apeng.property({
            type: EAlignType,
            displayName: "横向对齐"
        })
    ], SpriteLoaderCC.prototype, "alignType", null);
    __decorate([
        apeng.property({
            type: EVertAlignType,
            displayName: "纵向对齐"
        })
    ], SpriteLoaderCC.prototype, "vertAlignType", null);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_alignType", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_vertAlignType", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_spriteSimpleFillType", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_shrinkOnly", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_bindLoad", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_autoSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_isTrim", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_mat", void 0);
    __decorate([
        apeng.property({ serializable: true, editorOnly: true })
    ], SpriteLoaderCC.prototype, "_spriteFrame", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], SpriteLoaderCC.prototype, "_spriteColor", void 0);
    SpriteLoaderCC = __decorate([
        apeng.ccclass("SpriteLoaderCC"),
        apeng.executeInEditMode,
        apeng.menuUI("SpriteLoaderCC")
    ], SpriteLoaderCC);
    apeng.SpriteLoaderCC = SpriteLoaderCC;
})(apeng || (apeng = {}));
/// <reference path="./../helper/DirectorHelper.ts" />

(function (apeng) {
    /**
     * 子域组件
     * 解决自带的分组bug
     */
    let SubContextViewCC = class SubContextViewCC extends apeng.SubContextView {
        onLoad() {
            this._content.layer = this.node.layer;
            super.onLoad();
            if (this._openDataContext) {
                let trans = apeng.NodeHelper.getUITransform(this.node);
                this._openDataContext.postMessage({
                    event: 'canvasSize',
                    width: trans.contentSize.width,
                    height: trans.contentSize.height,
                });
            }
        }
        onEnable() {
            super.onEnable();
            if (this._openDataContext)
                this._openDataContext.postMessage({
                    event: 'updateRender',
                });
        }
        /**重写父类 以节点设置画布大小 */
        _initSharedCanvas() {
            if (this._openDataContext) {
                const sharedCanvas = this._openDataContext.canvas;
                let trans = apeng.NodeHelper.getUITransform(this.node);
                sharedCanvas.width = trans.contentSize.width;
                sharedCanvas.height = trans.contentSize.height;
            }
        }
    };
    SubContextViewCC = __decorate([
        apeng.ccclass("SubContextViewCC"),
        apeng.menuUI("SubContextViewCC")
    ], SubContextViewCC);
    apeng.SubContextViewCC = SubContextViewCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let SwitchChildrenCC = class SwitchChildrenCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                CHANGE: "CHANGE"
            };
            this.backupDescribe = "只显示一个子节点";
            this.noIndex = false;
            this._index = 0;
            this.onEditorUpdateData = this.updateView;
        }
        set index(vlaue) {
            if (vlaue == this._index)
                return;
            this._index = apeng.Maths.clampf(vlaue, 0, this.node.children.length - 1);
            this.updateView();
            this.node.emit(this.EventType.CHANGE, this._index);
        }
        get index() { return this._index; }
        onEnable() {
            super.onEnable();
            this.updateView();
        }
        setIndex(index) {
            if (typeof index == "string")
                index = Number(index);
            this.index = index;
        }
        updateView() {
            for (let i = 0; i < this.node.children.length; i++)
                this.node.children[i].active = this.noIndex ? i != this._index : i == this._index;
        }
        getIndexNode() {
            return this.node.children[this._index];
        }
    };
    __decorate([
        apeng.property({
            displayName: "反向显示"
        })
    ], SwitchChildrenCC.prototype, "noIndex", void 0);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "显示索引",
        })
    ], SwitchChildrenCC.prototype, "index", null);
    __decorate([
        apeng.property({ serializable: true })
    ], SwitchChildrenCC.prototype, "_index", void 0);
    SwitchChildrenCC = __decorate([
        apeng.ccclass("SwitchChildrenCC"),
        apeng.executeInEditMode,
        apeng.menuUI("SwitchChildrenCC")
    ], SwitchChildrenCC);
    apeng.SwitchChildrenCC = SwitchChildrenCC;
})(apeng || (apeng = {}));

(function (apeng) {
    let SwitchSpriteCC = class SwitchSpriteCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "切换图片";
            this.sp = null;
            this.sfs = [];
            this._index = 0;
            this.onEditorUpdateData = this.updateSp;
        }
        set index(vlaue) {
            if (vlaue == this._index)
                return;
            this._index = apeng.Maths.clampf(vlaue, 0, this.sfs.length - 1);
            this.updateSp();
        }
        get index() { return this._index; }
        onLoad() {
            super.onLoad();
            // 自动添加组件
            if (apeng.EDITOR) {
                if (!this.sp) {
                    this.sp = this.getComponent(apeng.Sprite);
                    if (this.sp) {
                        if (!this.sfs[0])
                            this.sfs[0] = this.sp.spriteFrame;
                    }
                }
            }
        }
        onEnable() {
            super.onEnable();
            this.updateSp();
        }
        setIndex(index) {
            if (typeof index == "string")
                index = Number(index);
            this.index = index;
        }
        updateSp() {
            if (!this.enabled)
                return;
            let sf = this.sfs[this._index];
            this.sp.spriteFrame = sf;
        }
    };
    __decorate([
        apeng.property({
            type: apeng.Sprite,
            displayName: "图片节点"
        })
    ], SwitchSpriteCC.prototype, "sp", void 0);
    __decorate([
        apeng.property({
            type: [apeng.SpriteFrame],
            displayName: "图片",
            visible() { return this.sp; }
        })
    ], SwitchSpriteCC.prototype, "sfs", void 0);
    __decorate([
        apeng.property({
            step: 1,
            displayName: "显示索引",
            visible() { return this.sp; }
        })
    ], SwitchSpriteCC.prototype, "index", null);
    __decorate([
        apeng.property({ serializable: true })
    ], SwitchSpriteCC.prototype, "_index", void 0);
    SwitchSpriteCC = __decorate([
        apeng.ccclass("SwitchSpriteCC"),
        apeng.executeInEditMode,
        apeng.menuUI("SwitchSpriteCC")
    ], SwitchSpriteCC);
    apeng.SwitchSpriteCC = SwitchSpriteCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const v3T = new apeng.Vec3();
    let SyncPositionTargetCC = class SyncPositionTargetCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "同步目标节点位置";
            this.target = null;
            this.isWorldPos = false;
            this.lerpRatio = 1;
            this.isOffset = true;
            this.offsetPosition = new apeng.Vec3();
        }
        get curPos() {
            if (this.isWorldPos)
                return this.node.worldPosition;
            else
                return this.node.position;
        }
        get targetPos() {
            if (this.isWorldPos)
                return this.target.worldPosition;
            else
                return this.target.position;
        }
        onLoad() {
            super.onLoad();
            if (this.isOffset)
                if (this.target)
                    apeng.Vector3.sub(this.offsetPosition, this.curPos, this.targetPos);
        }
        onUpdate() {
            if (!this.target)
                return;
            apeng.Vector3.add(v3T, this.offsetPosition, this.targetPos);
            if (this.lerpRatio < 1)
                apeng.NodeHelper.lerpTarget(this.node, v3T, this.lerpRatio * apeng._timer.dtSecond, undefined, this.isWorldPos);
            else
                this.setPosition(v3T, this.isWorldPos);
        }
    };
    __decorate([
        apeng.property({
            type: _cc_.Node,
            tooltip: "自动对齐父节点",
            displayName: "目标节点",
        })
    ], SyncPositionTargetCC.prototype, "target", void 0);
    __decorate([
        apeng.property({
            tooltip: "使用世界坐标对齐",
            displayName: "世界坐标",
        })
    ], SyncPositionTargetCC.prototype, "isWorldPos", void 0);
    __decorate([
        apeng.property({
            range: [0, 1, .001],
            slide: true,
            tooltip: "解决抖动 从快到慢的动画, 1不使用插值",
            displayName: "插值跟随",
        })
    ], SyncPositionTargetCC.prototype, "lerpRatio", void 0);
    __decorate([
        apeng.property({
            tooltip: "初始化时 记录偏移值，始终保持偏移",
            displayName: "保留偏移",
        })
    ], SyncPositionTargetCC.prototype, "isOffset", void 0);
    SyncPositionTargetCC = __decorate([
        apeng.ccclass("SyncPositionTargetCC"),
        apeng.menuUI("SyncPositionTargetCC")
    ], SyncPositionTargetCC);
    apeng.SyncPositionTargetCC = SyncPositionTargetCC;
})(apeng || (apeng = {}));

(function (apeng) {
    const loadResPositionHide = new apeng.Vector2(5000);
    let BaseEntity = class BaseEntity extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "实体组件";
            this.CLOSE_ON_CC = true;
            /**添加在头部 最先更新update */
            this.updateStateMachineHead = false;
            /**放到数组最后 所有更新完了后 */
            this.lateUpdateState = false;
            /**优先加载资源 */
            this.isPreLoadResouces = false;
            this.isLoadResouces = true;
            /**第一次加载 */
            this.isLoadResoucesOnce = true;
            this.entityMgr = null;
            this.orginCreatePrefabDelayPositon = null;
            /**加载的路径方便回收 */
            this.url = "";
            /**创建时的唯一id */
            this.entityID = 0;
            /**自身生命周期 */
            this.entityStateMackine = new apeng.StateMackine({
                caller: this,
                states: [{
                        type: apeng.EEntityState.Load,
                        onEnter: this.onStateEnterLoad,
                    }, {
                        type: apeng.EEntityState.Run,
                        onEnter: this.onStateEnterRun,
                        onUpdate: this.onStateUpdateRun,
                    }, {
                        type: apeng.EEntityState.Reset,
                        onEnter: this.onStateEnterReset,
                        onUpdate: this.onStateUpdateReset,
                    }, {
                        type: apeng.EEntityState.Over,
                        onEnter: this.onStateEnterOver,
                        onUpdate: this.onStateUpdateOver,
                    }, {
                        type: apeng.EEntityState.Exit,
                        onEnter: this.onStateEnterExit,
                    }]
            });
        }
        onStateEnterLoad() {
            let node = this.getDelayVisibleNode();
            if (node) {
                this.orginCreatePrefabDelayPositon = new apeng.Vector2(node.position);
                apeng.NodeHelper.setPositionXY(node, loadResPositionHide, false);
            }
            this.isLoadResoucesOnce = true;
        }
        onStateEnterRun() {
        }
        onStateUpdateRun() {
        }
        onStateEnterReset() {
        }
        onStateUpdateReset() {
        }
        onStateEnterOver(isWin) {
            this.unscheduleAllCallbacks();
        }
        onStateUpdateOver() {
        }
        onStateEnterExit() {
            this.unscheduleAllCallbacks();
            apeng._timer.clearAll(this);
        }
        loadResouces(cb) {
            if (typeof cb != "function")
                cb = null;
            if (this.onLoadResouces)
                this.onLoadResouces();
            let fn = () => {
                let _fn = () => {
                    if (this.onLoadResoucesComplete)
                        this.onLoadResoucesComplete();
                    let node = this.getDelayVisibleNode();
                    if (node) {
                        this.scheduleOnce(() => {
                            apeng.NodeHelper.setPositionXY(node, this.orginCreatePrefabDelayPositon, false);
                        });
                    }
                    if (cb)
                        cb();
                    this.isLoadResoucesOnce = false;
                };
                if (this.loadOtherResouces)
                    apeng._resouces.loadDir(this.loadOtherResouces(), _fn);
                else
                    _fn();
            };
            let cb2 = () => {
                let url = this.getResoucesUrl();
                if (url) {
                    this.loadResoucesByComp(url, fn);
                }
                else
                    fn();
            };
            if (this.preLoadBundles)
                apeng._resouces.loadBundles(this.preLoadBundles(), cb2);
            else
                cb2();
        }
        loadResoucesByComp(url, complete) {
            if (this.SpriteLoaderCC) {
                this.setSpriteLoaderCCUrl(url, complete);
            }
            else {
                if (this.CreatePrefabToEditorCC) {
                    this.CreatePrefabToEditorCC.preloadPrefab(url, true, complete);
                }
                else {
                    if (this.getCreatePrefabToEditorOnceCC())
                        this.getCreatePrefabToEditorOnceCC().preloadPrefab(url, true, complete);
                    else
                        complete();
                }
            }
        }
        setSpriteLoaderCCUrl(url, complete) {
            this.SpriteLoaderCC.setSpriteFrameUrl(url, true, complete);
        }
        getResoucesUrl() {
            if (!this.isLoadResouces)
                return null;
            if (this.SpriteLoaderCC)
                return apeng._resouces.getUuidByUrl(this.SpriteLoaderCC.spriteFrameByUuid);
            if (this.CreatePrefabToEditorCC)
                return apeng._resouces.getUuidByUrl(this.CreatePrefabToEditorCC.prefabItemByUuid);
            if (this.getCreatePrefabToEditorOnceCC())
                return apeng._resouces.getUuidByUrl(this.getCreatePrefabToEditorOnceCC().prefabItemByUuid);
            return "";
        }
        getDelayVisibleNode() {
            if (!this.isLoadResouces)
                return null;
            if (this.CreatePrefabToEditorCC)
                return this.CreatePrefabToEditorCC.node;
            if (this.getCreatePrefabToEditorOnceCC())
                return this.getCreatePrefabToEditorOnceCC().node;
            return null;
        }
        getCreatePrefabToEditorOnceCC() {
            return this.CreatePrefabToEditorOnceCC;
        }
    };
    BaseEntity = __decorate([
        apeng.ccclass("BaseEntity"),
        apeng.menuEntity("main/entity/BaseEntity")
    ], BaseEntity);
    apeng.BaseEntity = BaseEntity;
})(apeng || (apeng = {}));

(function (apeng) {
    /**战斗实体管理 */
    class BaseEntityMgr {
        constructor(scene) {
            this.CLEAR_EXIT = "CLEAR_EXIT";
            this.pool = new apeng.Pool(100000, (url) => apeng.instantiate(apeng._resouces.get(url)), (data) => data.removeFromParent(), (data) => data.destroy());
            /**所有entity集合 */
            this.entites = new apeng.Maps();
            /**需要刷新状态机的集合 */
            this.entitesUpdateState = [];
            this.entitesLateUpdateState = [];
            /**通过 type 分类的entity */
            this.entitesType = new apeng.Maps();
            /**下发给entity的id */
            this.entityID = 0;
            this.scene = null;
            this.queueResoucseLoad = null;
            this.scene = scene;
        }
        /**异步加载资源 */
        loadQueueResouces(loadResouces) {
            this.queueResoucseLoad = new apeng.Queue(() => {
                if (this.onLoadQueueResoucesComplete)
                    this.onLoadQueueResoucesComplete();
            }, apeng._platform.isNative ? -1 : 0);
            let queueEntites = [];
            let preEntites = [];
            this.entites.forEach(v => {
                if (v.isPreLoadResouces)
                    preEntites.push(v);
                else
                    queueEntites.push(v);
            });
            for (let entity of preEntites) {
                entity.loadResouces(null);
                if (loadResouces)
                    loadResouces(entity);
            }
            let sort = this.getQueueResoucesPriority();
            apeng.Sets.sortMin(queueEntites, a => sort.indexOf(a.entityType));
            for (let entity of queueEntites)
                this.queueResoucseLoad.add((complele) => {
                    entity.loadResouces(complele);
                    if (loadResouces)
                        loadResouces(entity);
                });
            this.queueResoucseLoad.run();
        }
        updateStateMachine() {
            for (let value of this.entitesUpdateState)
                value.entityStateMackine.onUpdate();
            for (let value of this.entitesLateUpdateState)
                value.entityStateMackine.onUpdate();
        }
        add(entity) {
            this.entityID++;
            entity.entityMgr = this;
            // 添加到entity分组里面
            let entites = this.entitesType.get(entity.entityType);
            if (!entites) {
                entites = new apeng.Maps();
                this.entitesType.set(entity.entityType, entites);
            }
            entites.set(this.entityID, entity);
            // 添加全局管理entity
            this.entites.set(this.entityID, entity);
            if (typeof entity.isUpdateStateMackine == "boolean" ? entity.isUpdateStateMackine : entity.isUpdateStateMackine())
                if (entity.updateStateMachineHead)
                    this.entitesUpdateState.unshift(entity);
                else {
                    if (entity.lateUpdateState)
                        this.entitesLateUpdateState.push(entity);
                    else
                        this.entitesUpdateState.push(entity);
                }
            entity.entityID = this.entityID;
        }
        remove(entity) {
            if (entity.entityStateMackine.state == apeng.EEntityState.None) {
                console.log("已被回收", entity.entityType, entity.entityID);
                return;
            }
            entity.entityStateMackine.change(apeng.EEntityState.Exit, [this.CLEAR_EXIT]);
            this.entites.delete(entity.entityID);
            if (typeof entity.isUpdateStateMackine == "boolean" ? entity.isUpdateStateMackine : entity.isUpdateStateMackine())
                if (entity.lateUpdateState)
                    apeng.Sets.delete(this.entitesLateUpdateState, entity);
                else
                    apeng.Sets.delete(this.entitesUpdateState, entity);
            let entites = this.entitesType.get(entity.entityType);
            if (entites)
                entites.delete(entity.entityID);
            entity.entityStateMackine.change(apeng.EEntityState.None);
            entity.entityID = 0;
            if (!entity.node)
                throw new Error("节点为空，检测子父节点是否嵌套");
            entity._onDisable();
            entity.onDestroy();
            if (entity.url && entity.isPut) {
                this.pool.put(entity.node);
            }
            else {
                if (entity.isDestroy)
                    entity.node.destroy();
            }
        }
        changeState(state) {
            this.entites.forEach(entity => entity.entityStateMackine.change(state));
        }
        clear(clearPool) {
            this.entites.forEach(entity => this.remove(entity), true);
            this.entites.clear();
            this.entitesUpdateState.length = 0;
            this.entitesLateUpdateState.length = 0;
            this.entitesType.forEach(e => e.clear());
            this.entitesType.clear();
            this.entityID = 0;
            if (clearPool)
                this.pool.clear();
            if (this.queueResoucseLoad)
                this.queueResoucseLoad.clear();
        }
        create(url, addEntity = true) {
            let node = null;
            let _url = "";
            if (typeof url == "string") {
                _url = url;
                node = this.pool.get(url);
            }
            else
                node = url;
            let entity = node.getComponent("BaseEntity");
            if (!entity)
                return null;
            entity.url = _url;
            if (addEntity)
                this.add(entity);
            this.runLife(entity);
            return entity;
        }
        /**
         * 执行component生命周期方法
         * @param entity
         */
        runLife(entity) {
            entity.autoMember();
            entity.__preload();
            entity._onLoad();
            entity._onEnable();
        }
    }
    apeng.BaseEntityMgr = BaseEntityMgr;
})(apeng || (apeng = {}));

(function (apeng) {
    let EEntityState;
    (function (EEntityState) {
        /**无效状态 */
        EEntityState[EEntityState["None"] = 0] = "None";
        /**加载 实例化数据 */
        EEntityState[EEntityState["Load"] = 1] = "Load";
        /**进入战斗前 重置数据 */
        EEntityState[EEntityState["Reset"] = 2] = "Reset";
        /**进行中 驱动entity状态机 */
        EEntityState[EEntityState["Run"] = 3] = "Run";
        /**结束 */
        EEntityState[EEntityState["Over"] = 4] = "Over";
        /**退出战斗 清理资源 */
        EEntityState[EEntityState["Exit"] = 5] = "Exit";
    })(EEntityState = apeng.EEntityState || (apeng.EEntityState = {}));
})(apeng || (apeng = {}));

(function (apeng) {
    class AStarCell {
        constructor(x, y) {
            this.x = -1;
            this.y = -1;
            /**从起点到指定格子耗费 */
            this.g = -1;
            /**从当前到终点耗费 */
            this.h = -1;
            /**g+h */
            this.f = -1;
            /**回遡 寻找路径 */
            this.parent = null;
            /**待检测 */
            this.isOpen = false;
            /**已检测 */
            this.isClose = false;
            /**走斜线 */
            this.isSlash = false;
            /**可行走 */
            this.isFind = true;
            this.x = x;
            this.y = y;
        }
        /**曼哈顿算法 */
        static manhattan(x, y, otherX, otherY) {
            return Math.abs(x - otherX) + Math.abs(y - otherY);
        }
        clear() {
            this.g = -1;
            this.h = -1;
            this.f = -1;
            this.parent = null;
            this.isOpen = false;
            this.isClose = false;
            this.isSlash = false;
        }
        disponse() {
            this.clear();
            this.isFind = true;
        }
    }
    apeng.AStarCell = AStarCell;
    const pool = new apeng.PoolOnce(10000, () => new AStarCell(0, 0), (data) => data.disponse());
    class AStarHelper {
        constructor() {
            this.cells = [];
            this.xMax = 0;
            this.yMax = 0;
            /**走斜线 */
            this.isSlash = false;
            this.startCell = null;
            this.endCell = null;
            this._finds = [];
            this.findRes = [];
        }
        init(xMax, yMax, isSlash) {
            this.xMax = xMax;
            this.yMax = yMax;
            this.isSlash = isSlash;
            for (let x = 0; x < this.xMax; x++) {
                this.cells[x] = [];
                for (let y = 0; y < this.yMax; y++)
                    this.cells[x][y] = apeng.Vector2.set(pool.get(), x, y);
            }
        }
        /**查找可行走路径，(不包含 终点 起点) */
        run() {
            this._finds.length = 0;
            this.findRes.length = 0;
            if (!this.startCell || !this.endCell)
                return this.findRes;
            for (let _cells of this.cells)
                for (let cell of _cells)
                    cell.clear();
            // 翻转 路径从起点到终点
            let tempCell = this.endCell;
            this.endCell = this.startCell;
            this.startCell = tempCell;
            this.startCell.g = 0;
            this.startCell.h = AStarCell.manhattan(this.startCell.x, this.startCell.y, this.endCell.x, this.endCell.y);
            this.startCell.f = this.startCell.g + this.startCell.h;
            this._finds[this._finds.length] = this.startCell;
            this.startCell.isOpen = true;
            while (this._finds.length > 0) {
                let parent = this._finds.shift();
                parent.isClose = true;
                // 完成查找
                if (parent.x == this.endCell.x && parent.y == this.endCell.y) {
                    // 回溯 
                    // this.findRes[this.findRes.length] = parent
                    while (parent.parent) {
                        parent = parent.parent;
                        if (parent.parent)
                            this.findRes[this.findRes.length] = parent;
                    }
                    break;
                }
                // 查找周边
                this.findByCell(parent, 1, 0);
                this.findByCell(parent, -1, 0);
                this.findByCell(parent, 0, -1);
                this.findByCell(parent, 0, 1);
                if (this.isSlash) {
                    this.findByCell(parent, 1, -1);
                    this.findByCell(parent, 1, 1);
                    this.findByCell(parent, -1, 1);
                    this.findByCell(parent, -1, -1);
                }
                this._finds.sort((a, b) => a.f > b.f ? 1 : -1);
            }
            return this.findRes;
        }
        findByCell(parent, offsetX, offsetY) {
            let x = parent.x + offsetX;
            if (x < 0 || x >= this.xMax)
                return false;
            let values = this.cells[x];
            if (!values)
                return;
            let y = parent.y + offsetY;
            if (y < 0 || y >= this.yMax)
                return;
            let child = values[y];
            if (!child)
                return;
            if (!child.isFind)
                return;
            if (child.isClose)
                return;
            if (!child.parent || parent.g < child.g) {
                child.g = parent.g + (child.isSlash ? Math.SQRT2 : 1);
                if (child.h == -1)
                    child.h = AStarCell.manhattan(child.x, child.y, this.endCell.x, this.endCell.y);
                child.f = child.g + child.h;
                child.parent = parent;
                child.isSlash = Math.abs(offsetX + offsetY) != 1;
            }
            if (!child.isOpen) {
                this._finds[this._finds.length] = child;
                child.isOpen = true;
            }
        }
        dispose() {
            this.startCell = null;
            this.endCell = null;
            this._finds.length = 0;
            this.findRes.length = 0;
            for (let _cells of this.cells)
                for (let cell of _cells)
                    pool.put(cell);
            this.cells.length = 0;
        }
        /**根据一维索引获取格子 */
        getIndexByCell(index) {
            let y = index % this.yMax;
            let x = Math.floor(index / this.yMax);
            return this.cells[x][y];
        }
        /**通过格子转换为一维索引 */
        getCellByIndex(cell) {
            return cell.x * this.yMax + cell.y;
        }
    }
    apeng.AStarHelper = AStarHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 自动注册事件
     * 自动赋值成员变量
     */
    class AutoMemberNodeAttribute {
        static clearMember(caller) {
            return;
            // for (let key in caller) {
            // 	if (caller[key]) {
            // 		let memberIndex = Strings.indexOf(key, AutoMemberNodeAttribute.memberByNodeNamePrefix)
            // 		// 成员函数前缀相同
            // 		if (memberIndex == 0) {
            // 			let addMember = caller[key]["AutoMemberNodeAttribute"]
            // 			if (addMember && Sets.has(addMember, caller.uuid))
            // 				if (caller[key] instanceof Component || caller[key] instanceof BaseNode) {
            // 					Sets.delete(addMember, caller.uuid)
            // 					caller[key] = null
            // 				}
            // 		}
            // 	}
            // }
        }
        /**
         * andorid for in 循环不到函数 只能遍历全部节点
         *
         * 注册 caller点击事件 caller成员变量
         *
         * caller.onClick{node.name}
         * 注册点击事件 onClick事件前缀， node.name 节点名 ButtonCC可忽略
         *
         * caller.c{node.name} = null
         * 赋值成员变量，c子节点前缀 node.name节点名
         * 如节点名内含有@ccclass("name") 则获取组件返回
         *
         * @param parent
         * @param caller
         */
        static init(parent, caller) {
            let matchChildrenName = [];
            for (let key in caller) {
                if (caller[key] == null) {
                    let memberIndex = apeng.Strings.indexOf(key, AutoMemberNodeAttribute.memberByNodeNamePrefix);
                    // 成员函数前缀相同
                    if (memberIndex == 0) {
                        let lastLndex = apeng.Strings.lastIndexOf(key, AutoMemberNodeAttribute.memberByNodeNamePrefix);
                        matchChildrenName.push(key.slice(lastLndex));
                    }
                }
            }
            apeng.NodeHelper.walkAllChild(parent, (node) => {
                // 赋值成员变量
                if (matchChildrenName.length > 0)
                    if (apeng.Sets.has(matchChildrenName, node.name)) {
                        apeng.Sets.delete(matchChildrenName, node.name);
                        let CCkey = null;
                        let compName = apeng.Maps.filterKey(apeng.js._nameToClass, (value, key) => {
                            let index = apeng.Strings.indexOf(key, "cc.");
                            if (index == 0) {
                                CCkey = key.slice(apeng.Strings.lastIndexOf(key, "cc."));
                                if (apeng.Strings.indexOf(node.name, CCkey) == 0)
                                    return true;
                                else
                                    CCkey = null;
                            }
                            else if (apeng.Strings.indexOf(node.name, key) == 0)
                                return true;
                        }, true);
                        // 先使用自定义组件
                        if (compName && CCkey) {
                            CCkey += "CC";
                            if (apeng.Strings.indexOf(node.name, CCkey) == 0)
                                if (apeng.js._nameToClass[CCkey])
                                    compName = CCkey;
                        }
                        let callerKey = AutoMemberNodeAttribute.memberByNodeNamePrefix + node.name;
                        if (!compName) {
                            caller[callerKey] = node;
                        }
                        else {
                            caller[callerKey] = node.getComponent(compName);
                            // 出现同名前缀组件
                            if (!caller[callerKey]) {
                                console.log("no find component: ", compName, node.name);
                            }
                        }
                        if (caller[callerKey]) {
                            if (caller[callerKey]["AutoMemberNodeAttribute"] == undefined)
                                caller[callerKey]["AutoMemberNodeAttribute"] = [];
                            apeng.Sets.add(caller[callerKey]["AutoMemberNodeAttribute"], caller.uuid);
                        }
                        if (AutoMemberNodeAttribute.isLog)
                            console.log("auto_add_member>>:", node.name, ";", callerKey, "; success:", caller[callerKey] ? caller[callerKey].name : null);
                    }
                // 注册点击事件 2d节点才可注册
                if (apeng.NodeHelper.getUITransform(node)) {
                    let nodeName = node.name;
                    // button节点名不必写前缀
                    let index = apeng.Strings.indexOf(nodeName, "ButtonCC");
                    if (index == 0)
                        nodeName = nodeName.slice(apeng.Strings.lastIndexOf(nodeName, "ButtonCC"));
                    let callerKey = AutoMemberNodeAttribute.registClickEventPrefix + nodeName;
                    let callerValue = caller[callerKey];
                    if (callerValue && typeof callerValue == "function") {
                        apeng.EventHandlerCC.onClick(node, caller[callerKey], caller);
                        if (AutoMemberNodeAttribute.isLog)
                            console.log("auto_regist_click_event>>:", node.name, "; ", callerKey);
                    }
                }
            });
        }
    }
    AutoMemberNodeAttribute.isLog = false;
    /**自动注册 btn事件的 成员函数 前缀 */
    AutoMemberNodeAttribute.registClickEventPrefix = "onClick";
    /**自动找到子节点对应的 成员变量 的前缀 */
    AutoMemberNodeAttribute.memberByNodeNamePrefix = "c";
    apeng.AutoMemberNodeAttribute = AutoMemberNodeAttribute;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    class ConfigHelper {
        constructor(configs, define) {
            /**数组形式的配置数据 */
            this.arr = {};
            /**对象形式的配置数据 */
            this.obj = {};
            let objs = this.deParse(configs);
            // 解析配置表
            for (let configName in define) {
                let obj = objs[configName];
                this.arr[configName] = [];
                if (configName.indexOf("language") != -1) {
                    for (let key in obj)
                        this.arr[configName].push(obj[key]);
                }
                else {
                    for (let key in obj) {
                        obj[key].id = Number(key);
                        obj[key].configName = configName;
                        this.arr[configName].push(obj[key]);
                        let parseKey = define[configName];
                        if (parseKey !== null)
                            obj[key] = obj[key][parseKey];
                    }
                }
                this.obj[configName] = obj;
            }
        }
        // 解压缩
        deParse(sources) {
            let obj = {};
            for (let key in sources) {
                let value = null;
                if (key.indexOf("language") != -1) {
                    value = sources[key][1];
                    for (let _k in value) {
                        for (let i = 0; i < value[_k].length; i++) {
                            let v = value[_k][i];
                            if (v && typeof v == "string")
                                value[_k][i] = v.split("\\n").join("\n");
                            else
                                value[_k][i] = v + "";
                        }
                    }
                }
                else {
                    value = {};
                    let k = [];
                    for (let _k of sources[key][0])
                        k.push(_k);
                    let v = sources[key][1];
                    for (let _k in v) {
                        value[_k] = {};
                        for (let i = 0; i < k.length; i++)
                            value[_k][k[i]] = v[_k][i];
                    }
                }
                obj[key] = value;
            }
            return obj;
        }
    }
    apeng.ConfigHelper = ConfigHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    class DataLogicHelper extends apeng.EventDispatcher {
        constructor(poolCreate, poolClear) {
            super();
            this.poolCreate = poolCreate;
            this.poolClear = poolClear;
            this.EventType = {
                /**删除 index */
                REMOVE: "REMOVE",
                RESET: "RESET",
            };
            this.pool = new apeng.PoolOnce(100000, () => this.poolCreate(), (data) => this.poolClear(data));
            this.datas = [];
        }
        create() {
            let data = this.pool.get();
            this.datas.push(data);
            return data;
        }
        count() {
            let count = 0;
            for (let v of this.datas)
                if (v)
                    count++;
            return count;
        }
        hasZero() {
            for (let v of this.datas)
                if (v)
                    return false;
            return true;
        }
        reset() {
            for (let v of this.datas)
                if (v)
                    this.pool.put(v);
            this.datas.length = 0;
            this.emit(this.EventType.RESET);
        }
        remove(index) {
            let data = this.datas[index];
            if (!data)
                return;
            this.datas[index] = null;
            this.pool.put(data);
            this.emit(this.EventType.REMOVE, index);
        }
    }
    apeng.DataLogicHelper = DataLogicHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**编辑器环境解析数据永久储存 */
    let EditorParseDataCC = class EditorParseDataCC {
        constructor() {
            this.data = "";
            this.info = "";
        }
        set(data) {
            this.data = JSON.stringify(data);
            let len = this.data.length;
            this.info = "长度" + len + "; 大小" + apeng.Maths.toFixed(len / 1024, 2) + "kb";
        }
        get() {
            return JSON.parse(this.data);
        }
    };
    __decorate([
        apeng.property({
            // multiline: true,
            // readonly: true,
            displayName: "数据源",
        })
    ], EditorParseDataCC.prototype, "data", void 0);
    __decorate([
        apeng.property({
            readonly: true,
            displayName: "数据信息",
        })
    ], EditorParseDataCC.prototype, "info", void 0);
    EditorParseDataCC = __decorate([
        apeng.ccclass("EditorParseDataCC")
    ], EditorParseDataCC);
    apeng.EditorParseDataCC = EditorParseDataCC;
})(apeng || (apeng = {}));

(function (apeng) {
    /**间隔时间 */
    class IntervalTimeHelper {
        constructor(
        /**方便使用模块缓存 */
        storage, 
        /**缓存时的前缀 */
        cachePrefix, 
        /**间隔时间 */
        interval, 
        /**使用函数时间戳 秒 */
        cacheTimeFn, 
        /**减少 剩余的时间 */
        onSub) {
            this.storage = storage;
            this.cachePrefix = cachePrefix;
            this.interval = interval;
            this.cacheTimeFn = cacheTimeFn;
            this.onSub = onSub;
        }
        static instance(interval, cacheTime) {
            this._instance.interval = interval;
            this._instance.cacheTimeFn = () => cacheTime;
            return this._instance;
        }
        /**缓存时的时间戳 */
        get cacheTime() {
            if (this.cacheTimeFn)
                return this.cacheTimeFn();
            return this.storage.get(this.cachePrefix + "_a", apeng.Times.second());
        }
        /**获取剩余间隔的时间 */
        get sub() { return Math.max(0, this.cacheTime + this.interval - apeng.Times.second() - (this.onSub ? this.onSub() : 0)); }
        /**不限制 */
        get subMax() { return this.cacheTime + this.interval - apeng.Times.second() - (this.onSub ? this.onSub() : 0); }
        /**获取已经过的时间 进度，1为可领取 最大为0～1 */
        get ratio() { return apeng.Maths.clamp01((this.interval - this.sub) / this.interval); }
        /**获取已经过了的时间，可超过1 */
        get ratioMax() { return (this.interval - this.subMax) / this.interval; }
        /**根据时间获取倍率 */
        getMul(allTime, interval = this.interval) { return allTime / interval; }
        /**设置间隔时间 */
        setCache() { this.storage.set(this.cachePrefix + "_a", apeng.Times.second()); }
        /**获取离线时 的倍率 */
        getOfflineMul(add = 0, interval = this.interval) {
            let sub = apeng.Times.second() - this.cacheTime + add;
            if (sub <= 0)
                return -1;
            return this.getMul(sub, interval);
        }
        disponse() {
            this.storage.delete(this.cachePrefix + "_a");
        }
    }
    IntervalTimeHelper._instance = new IntervalTimeHelper(apeng.StorageOnceMgr, "test", -1);
    apeng.IntervalTimeHelper = IntervalTimeHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**关卡管理 */
    class LevelHelper extends apeng.EventDispatcher {
        constructor(
        /**方便使用模块缓存 */
        storage, 
        /**使用测试读取关卡 */
        test, 
        /**缓存的前缀 */
        cacheKey, 
        /**已配置的最大关卡 */
        max, 
        /**可超出最大关卡 */
        toMax, 
        /**超过配置关卡后 随机之前的关卡，需要排除的关卡 */
        exclude, defautCacheData, _parseDataCb = null) {
            super();
            this.storage = storage;
            this.test = test;
            this.cacheKey = cacheKey;
            this.max = max;
            this.toMax = toMax;
            this.exclude = exclude;
            this.defautCacheData = defautCacheData;
            this._parseDataCb = _parseDataCb;
            this._parseData = new apeng.Maps();
        }
        /**获取当前关 */
        get cur() {
            // 通过配置进入关卡 方便测试
            if (this.test > 0)
                return this.test;
            return this.storage.get(this.cacheKey + ".cur", 1);
        }
        /**当前已转换的关卡 */
        get curConverLevel() { return this.getConverLevel(this.cur); }
        /**当前关卡数据 */
        get curData() { return this.getData(this.cur); }
        /**当前关卡的缓存数据 */
        get curCache() { return this.getCache(this.cur); }
        /**设置当前关卡的缓存数据 */
        setCurCache(data) { this.setCache(this.cur, data); }
        /**获取关卡对应数据块 */
        getData(level) {
            if (!this._parseDataCb)
                return null;
            let value = this._parseData.get(level);
            if (!value) {
                value = this._parseDataCb(level);
                this._parseData.set(level, value);
            }
            return value;
        }
        /**设置关卡缓存数据 */
        setCache(level, data) {
            this.storage.set(this.cacheKey + ".curData" + level, data, false);
            this.emit(LevelHelper.EventType.CACHE_CHANGE, level, data);
        }
        /**
         * 获取全部缓存数据
         * @param cb
         */
        getAllCache(cb) {
            let values = [];
            for (let i = 1; i <= this.max; i++)
                values.push(cb(this.getCache(i)));
            return values;
        }
        /**获取关卡缓存数据 */
        getCache(level) {
            return this.storage.get(this.cacheKey + ".curData" + level, this.defautCacheData);
        }
        add() {
            let cur = this.cur;
            if (this.toMax || cur < this.max) {
                this.set(cur + 1);
                this.emit(LevelHelper.EventType.ADD, cur + 1);
                return true;
            }
            return false;
        }
        set(level) {
            this.storage.set(this.cacheKey + ".cur", level);
            this.emit(LevelHelper.EventType.CHNAGE);
        }
        /**
         * 经过转换后 读取文件的level
         * @param level
         * @returns
         */
        getConverLevel(level) {
            let cacheUrl = this.storage.get(this.cacheKey + ".cacheUrl", null);
            if (!cacheUrl)
                cacheUrl = {};
            if (!cacheUrl[level]) {
                // 超过配置关卡后 随机之前的关卡
                let newLevel = 1;
                if (level > this.max) {
                    if (this.max <= 2)
                        newLevel = this.max;
                    else {
                        let last = this.storage.get(this.cacheKey + ".lastRandomCacheUrl", -1);
                        while (true) {
                            newLevel = apeng.Maths.minToMax(1, this.max);
                            if (last != newLevel)
                                if (this.exclude.indexOf(newLevel) == -1) {
                                    this.storage.set(this.cacheKey + ".lastRandomCacheUrl", newLevel);
                                    break;
                                }
                        }
                    }
                    cacheUrl[level] = newLevel;
                    this.storage.set(this.cacheKey + ".cacheUrl", cacheUrl);
                    console.log("超过配置最大关卡 随机已有关卡:", level);
                }
            }
            if (cacheUrl[level])
                level = cacheUrl[level];
            return level;
        }
    }
    LevelHelper.EventType = {
        /**调用 setCache时 */
        CACHE_CHANGE: "CACHE_CHANGE",
        ADD: "ADD",
        CHNAGE: "CHNAGE",
    };
    apeng.LevelHelper = LevelHelper;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Rectangle.ts" />

(function (apeng) {
    const ccVec3up = new apeng.Vec3(0, 1, 0);
    const ccVec3zero = new apeng.Vec3();
    const v3T = new apeng.Vec3();
    const v3T2 = new apeng.Vec3();
    const v3T3 = new apeng.Vec3();
    const quatT = new apeng.Quat();
    const quatT2 = new apeng.Quat();
    const matrixT = new apeng.Mat4();
    const colorT = new apeng.Color();
    const RectangleT = new apeng.Rectangle();
    const sizeT = new apeng.Size();
    const grayColor = new apeng.Color(150, 150, 150, 255);
    const grayColorOpacity = new apeng.Color(150, 150, 150, 0);
    class NodeHelper {
        static setHideFlags(node, ...flags) {
            if (!apeng.EDITOR)
                return;
            let flag = 0;
            for (let value of flags)
                flag |= value;
            node.hideFlags = flag;
        }
        /**
         * 获取一个子节点
         * @param parent
         * @param nodeName
         * @param createCb
         * @param addChildIndex 默认添加到最后
         * @returns
         */
        static getChildByCreate(parent, nodeName, createCb, addChildIndex = -1, editorShow = false, addChildComplete) {
            let node = parent.getChildByName(nodeName);
            if (!node) {
                node = new apeng.Node(nodeName);
                node.layer = parent.layer;
                if (!editorShow)
                    this.setHideFlags(node, apeng.CCObject.Flags.HideInHierarchy, apeng.CCObject.Flags.DontSave);
                if (this.getUITransform(parent))
                    node.addComponent(apeng.UITransform);
                if (createCb)
                    createCb(node);
                parent.insertChild(node, addChildIndex == -1 ? parent.children.length : addChildIndex);
                if (addChildComplete)
                    addChildComplete(node);
            }
            return node;
        }
        /**
         * 指定level插入到parent中
         * 如果找到了 则返回当前节点
         * 如果没用 则创建一个
         * @param parent
         * @param level
         * @returns 当前等级得节点
         */
        static insertChild(parent, level) {
            let nodeName = level.toString();
            let childrenParent = parent.getChildByName(nodeName);
            if (childrenParent)
                return childrenParent;
            for (let i = 0, children = parent.children, length = children.length; i < length; i++) {
                let value = children[i];
                if (Number(value.name) > level)
                    return this.getChildByCreate(parent, nodeName, null, i);
            }
            return this.getChildByCreate(parent, nodeName);
        }
        static setSize(node, width = null, height = null) {
            if (width != null && height != null) {
                NodeHelper.getUITransform(node).setContentSize(width, height);
                return;
            }
            if (width && width instanceof apeng.Size)
                NodeHelper.getUITransform(node).setContentSize(width);
            else {
                if (width != null && height != null) {
                    sizeT.set(width, height);
                    NodeHelper.getUITransform(node).setContentSize(sizeT);
                }
                else {
                    if (width != null)
                        NodeHelper.getUITransform(node).width = width;
                    if (height != null)
                        NodeHelper.getUITransform(node).height = height;
                }
            }
        }
        static getUITransform(node) {
            return node._uiProps.uiTransformComp;
        }
        static getUIRenderer(node) {
            return node.getComponent(apeng.UIRenderer);
        }
        /**
         * 朝目标方向移动
         * @param node
         * @param dir
         * @param speed
         * @param isWorld
         * @returns
         */
        static move(node, dir, speed, isWorld) {
            apeng.Vector3.set(v3T, dir);
            apeng.Vector3.mul(v3T, v3T, (speed * apeng._timer.dt));
            apeng.Vector3.add(v3T, v3T, NodeHelper.getPosition(node, isWorld));
            NodeHelper.setPosition(node, v3T, isWorld);
            return v3T;
        }
        /**
        * 获取节点上可操作的逻辑脚本
        * @param node
        * @returns
        */
        static getNodeComponents(node, comps) {
            let values = [];
            for (let comp of comps) {
                let value = node.getComponents(comp);
                if (value.length > 0)
                    values.push(...value);
            }
            return values;
        }
        /**递归父节点存在的组件 */
        static getParentByComponent(parent, comp) {
            while (parent) {
                let res = parent.getComponent(comp);
                if (res)
                    return res;
                parent = parent.parent;
            }
            return null;
        }
        static gray(parent, isGray) {
            if (!parent || !parent.activeInHierarchy)
                return;
            let fn = (node) => {
                // 父节点有 ButtonByChildGrayExcludeCC组件 则不进行置灰
                if (node.getComponent("ButtonByChildGrayExcludeCC"))
                    return 1;
                if (!node.active)
                    return;
                let sp = node.getComponent(apeng.Sprite);
                if (sp) {
                    if (sp.enabled)
                        sp.grayscale = isGray;
                }
                else {
                    let lb = node.getComponent(apeng.Label);
                    if (lb) {
                        if (lb.enabled) {
                            let orginLabelColor = lb["orginLabelColor"];
                            if (!orginLabelColor)
                                orginLabelColor = lb["orginLabelColor"] = lb.color.clone();
                            if (isGray) {
                                grayColor.a = orginLabelColor.a;
                                lb.color = grayColor;
                            }
                            else
                                lb.color = orginLabelColor;
                            // fnt
                            let outline = lb["outlineColor"];
                            if (outline) {
                                let orginLabelOutlineColor = lb["orginLabelOutlineColor"];
                                if (!orginLabelOutlineColor)
                                    orginLabelOutlineColor = lb["orginLabelOutlineColor"] = outline.clone();
                                if (isGray)
                                    lb.outlineColor = grayColorOpacity;
                                else
                                    lb.outlineColor = orginLabelOutlineColor;
                            }
                        }
                    }
                }
            };
            fn(parent);
            if (parent.children.length > 0)
                this.walkAllDeepChild(parent, fn);
        }
        /**递归父节点相等的name */
        static getParentByName(node, parentName) {
            let parent = node.parent;
            while (parent) {
                if (parent.name == parentName)
                    return parent;
                parent = parent.parent;
            }
            return null;
        }
        /**递归父节点相等的name的子节点 */
        static getParentByNameChild(node, parentName) {
            let parent = node.parent;
            let childParent = node;
            while (parent) {
                if (parent.name == parentName)
                    return childParent;
                childParent = parent;
                parent = parent.parent;
            }
            return null;
        }
        static getChildrenByComponent(node, comp) {
            for (let value of node.children) {
                let res = value.getComponent(comp);
                if (res)
                    return res;
            }
            return null;
        }
        /**获取当前或所有子节点第一个匹配的组件 */
        static getAllByComponent(node, comp) {
            let value = node.getComponent(comp);
            if (!value)
                value = node.getComponentInChildren(comp);
            if (!value)
                value = null;
            return value;
        }
        static getChildrenByComponents(node, comp, cb, out) {
            let i = 0;
            for (let value of node.children) {
                let res = value.getComponent(comp);
                if (res) {
                    if (out != undefined)
                        out.push(res);
                    if (cb)
                        cb(res, i);
                    i++;
                }
            }
            return out;
        }
        /**
         * 看向目标点
         * @param node
         * @param target
         * @param rotate 角度制
         */
        static lookAt(node, target, rotate = null, defaultRotate = 90) {
            if (NodeHelper.getUITransform(node)) {
                if (!apeng.Vector2.equals(node.worldPosition, target, .1)) {
                    defaultRotate = apeng.Vector2.angle360(node.worldPosition, target, rotate || 0);
                }
                v3T.set(0, 0, defaultRotate);
                NodeHelper.setRotate(node, v3T, false);
            }
            else {
                apeng.Vector3.set(v3T, target);
                node.lookAt(v3T, ccVec3up);
                // 旋转朝向
                if (rotate != 0) {
                    quatT.set();
                    rotate = apeng.Maths.toRadian(rotate);
                    apeng.Quat.rotateY(quatT, quatT, rotate);
                    node.rotate(quatT, apeng.Node.NodeSpace.WORLD);
                }
            }
        }
        /**
         * 返回值越小越前 越大越在上层
         * @param nodes
         * @param fn
         */
        static zIndexSort(nodes, fn) {
            let datas = nodes.map((node, index) => ({ node, zIndex: fn(node, index) }));
            apeng.Sets.sortMin(datas, a => a.zIndex);
            for (let i = 0; i < datas.length; i++)
                datas[i].node.setSiblingIndex(i);
        }
        /**
         * 当前节点朝着目标点移动
         * @param node 移动节点
         * @param target 目标位置
         * @param speed 移动速度
         * @param rotate 看向目标点(角度制)
         * @return {boolean} 到达目标点
         */
        static followTarget(node, target, speed, rotate = null, isWorld = true, defaultRotate) {
            let isTarget = false;
            // 移动坐标
            apeng.Vector3.set(v3T, target);
            apeng.Vector3.set(v3T3, NodeHelper.getPosition(node, isWorld));
            if (apeng.Vector3.equalsZero(v3T, v3T3))
                return true;
            apeng.Vector3.set(v3T2, target);
            apeng.Vector3.sub(v3T, v3T, v3T3);
            // 限制移动最大的增量 保证移动到目标点
            let dis = apeng.Vector3.len(v3T);
            if (dis < 0.001)
                return true;
            // 加上帧率 显示平滑
            if (typeof speed == "number") {
                speed = (speed * apeng._timer.dtSecond);
                if (speed > dis) {
                    isTarget = true;
                    speed = dis;
                }
            }
            else {
                apeng.Vector3.mul(speed, speed, 60 * apeng._timer.dt);
                if (apeng.Vector3.len(speed) > dis) {
                    isTarget = true;
                    apeng.Vector3.normalize(speed, speed);
                    apeng.Vector3.mul(speed, speed, dis);
                }
            }
            apeng.Vector3.normalize(v3T, v3T);
            apeng.Vector3.mul(v3T, v3T, speed);
            apeng.Vector3.add(v3T3, v3T, NodeHelper.getPosition(node, isWorld));
            NodeHelper.setPosition(node, v3T3, isWorld);
            // 旋转朝向
            if (rotate != null)
                NodeHelper.lookAt(node, v3T2, rotate, defaultRotate);
            return isTarget;
        }
        /**
         * 插值到目标点
         * @param node
         * @param target
         * @param ratio 插值比率 0~1
         * @param rotate 看向目标点(弧度制)
         * @returns 到达目标点
         */
        static lerpTarget(node, target, ratio, rotate = null, isWorld = true, defaultRotate, min = .001) {
            apeng.Vector3.set(v3T, target);
            apeng.Vector3.set(v3T2, NodeHelper.getPosition(node, isWorld));
            if (apeng.Vector3.equalsZero(v3T, v3T2))
                return true;
            apeng.Vector3.set(v3T3, target);
            let dis = apeng.Vector3.distance(v3T, v3T2);
            if (dis < min) {
                NodeHelper.setPosition(node, v3T, isWorld);
                return true;
            }
            apeng.Vector3.lerp(v3T2, v3T2, v3T, ratio);
            NodeHelper.setPosition(node, v3T2, isWorld);
            // 旋转朝向
            if (rotate != null)
                NodeHelper.lookAt(node, v3T3, rotate, defaultRotate);
            return false;
        }
        /**触点坐标转换为游戏视图坐标 */
        static converScreenToWorld(out, position, camear) {
            apeng.Vector3.set(v3T, position);
            // 摄像机缩放加偏移
            if (camear)
                camear.screenToWorld(v3T, v3T);
            else
                apeng.view._convertToUISpace(v3T);
            apeng.Vector3.set(out, v3T);
            return out;
        }
        /**游戏坐标转换为触点坐标 */
        static converSceneToUI(out, worldPosition, sceneCamear) {
            apeng.Vector3.set(v3T, worldPosition);
            sceneCamear.worldToScreen(v3T, v3T);
            NodeHelper.converScreenToWorld(v3T, v3T, this.UICamera);
            apeng.Vector3.set(out, v3T);
            return out;
        }
        /**
       * 插值到目标点
       * @param node
       * @param target
       * @param ratio 插值比率 0~1
       * @param rotate 看向目标点(弧度制)
       * @returns 到达目标点
       */
        static lerpScaleTarget(node, target, ratio, isWorld = true) {
            if (typeof target == "number")
                apeng.Vector3.set(v3T, target, target, target);
            else
                apeng.Vector3.set(v3T, target);
            apeng.Vector3.set(v3T2, NodeHelper.getScale(node, isWorld));
            if (apeng.Vector3.equalsZero(v3T, v3T2))
                return true;
            let dis = this.getUITransform(node) ? apeng.Vector2.distance(v3T, v3T2) : apeng.Vector3.distance(v3T, v3T2);
            if (dis < 0.001) {
                NodeHelper.setScale(node, v3T, isWorld);
                return true;
            }
            apeng.Vector3.lerp(v3T2, v3T2, v3T, ratio);
            NodeHelper.setScale(node, v3T2, isWorld);
            return false;
        }
        static lerpRotateTarget(node, target, ratio, isWorld = true) {
            if (typeof target == "number")
                apeng.Vector3.set(v3T, target, target, target);
            else
                apeng.Vector3.set(v3T, target);
            apeng.Vector3.set(v3T2, NodeHelper.getRotateV3(node, isWorld));
            if (apeng.Vector3.equalsZero(v3T, v3T2))
                return true;
            let dis = this.getUITransform(node) ? (v3T.z - v3T2.z) : apeng.Vector3.distance(v3T, v3T2);
            if (dis < 0.001) {
                NodeHelper.setRotate(node, v3T, isWorld);
                return true;
            }
            apeng.Vector3.lerp(v3T2, v3T2, v3T, ratio);
            NodeHelper.setRotate(node, v3T2, isWorld);
            return false;
        }
        static lerpQuatTarget(node, target, ratio) {
            quatT2.set(target);
            node.getRotation(quatT);
            if (apeng.Quat.strictEquals(quatT, quatT2))
                return true;
            quatT2.getEulerAngles(v3T);
            quatT.getEulerAngles(v3T2);
            if (apeng.Vector3.distance(v3T, v3T2) < 0.001) {
                node.setRotation(quatT2);
                return true;
            }
            apeng.Quat.lerp(quatT, quatT, quatT2, ratio);
            if (NodeHelper.getUITransform(node)) {
                quatT.getEulerAngles(v3T);
                NodeHelper.setRotateZ(node, v3T.z, false);
            }
            else
                node.setRotation(quatT);
            return false;
        }
        /**
         * 遍历所有子节点
         * 默认广度便利 方便查找浅层节点
         * @param parent
         * @param cb true时 终止循环
         * @param deep true深度便利 false广度便利
         * @returns true 终止循环，
         */
        static walkAllChild(parent, cb, deep = false) {
            if (deep)
                for (let node of parent.children)
                    if (cb(node))
                        break;
                    else
                        NodeHelper.walkAllChild(node, cb, deep);
            else {
                let nodes = [...parent.children];
                for (let i = 0; i < nodes.length; i++)
                    if (cb(nodes[i]))
                        break;
                    else
                        nodes.push(...nodes[i].children);
            }
        }
        /**
         * 深度遍历子节点
         * @param parent
         * @param cb
         * @returns 1不遍历子节点 2终止循环
         */
        static walkAllDeepChild(parent, cb) {
            for (let node of parent.children) {
                let res = cb(node);
                if (res === 1)
                    continue;
                else if (res === 2)
                    break;
                else
                    NodeHelper.walkAllDeepChild(node, cb);
            }
        }
        static setRotate(node, value, isWorld) {
            apeng.Vector3.set(v3T, value);
            if (isWorld)
                node.setWorldRotationFromEuler(v3T.x, v3T.y, v3T.z);
            else
                node.setRotationFromEuler(v3T);
        }
        static setRotateX(node, x, isWorld) {
            quatT.set(NodeHelper.getRotate(node, isWorld));
            quatT.getEulerAngles(v3T);
            v3T.x = x;
            NodeHelper.setRotate(node, v3T, isWorld);
        }
        static setRotateY(node, y, isWorld) {
            quatT.set(NodeHelper.getRotate(node, isWorld));
            quatT.getEulerAngles(v3T);
            v3T.y = y;
            NodeHelper.setRotate(node, v3T, isWorld);
        }
        static setRotateZ(node, z, isWorld) {
            node.angle = z;
        }
        static rotateX(node, angle, isWorld) {
            quatT.set();
            apeng.Quat.rotateX(quatT, quatT, apeng.Maths.toRadian(angle));
            node.rotate(quatT, isWorld ? apeng.Node.NodeSpace.WORLD : apeng.Node.NodeSpace.LOCAL);
        }
        static rotateY(node, angle, isWorld) {
            quatT.set();
            apeng.Quat.rotateY(quatT, quatT, apeng.Maths.toRadian(angle));
            node.rotate(quatT, isWorld ? apeng.Node.NodeSpace.WORLD : apeng.Node.NodeSpace.LOCAL);
        }
        static rotateZ(node, angle, isWorld) {
            quatT.set();
            apeng.Quat.rotateZ(quatT, quatT, apeng.Maths.toRadian(angle));
            node.rotate(quatT, isWorld ? apeng.Node.NodeSpace.WORLD : apeng.Node.NodeSpace.LOCAL);
        }
        static setScale(node, value, isWorld) {
            apeng.Vector2.set(v3T, value);
            if (value.z != undefined)
                v3T.z = value.z;
            if (this.getUITransform(node))
                v3T.z = 1;
            if (!apeng.Vector3.equalsZero(v3T, NodeHelper.getScale(node, isWorld)))
                if (isWorld)
                    node.setWorldScale(v3T);
                else
                    node.setScale(v3T);
        }
        static setScaleNum(node, num, isWorld) {
            if (node.scale.x === num)
                return;
            if (this.getUITransform(node))
                apeng.Vector3.set(v3T, num, num, 1);
            else
                apeng.Vector3.set(v3T, num, num, num);
            NodeHelper.setScale(node, v3T, isWorld);
        }
        static getRotate(node, isWorld) {
            if (isWorld)
                return node.worldRotation;
            else
                return node.rotation;
        }
        static getRotateV3(node, isWorld) {
            return NodeHelper.getRotate(node, isWorld).getEulerAngles(this._getRotateV3);
        }
        static getRotateZ(node) {
            return node.angle;
        }
        static getScale(node, isWorld) {
            if (isWorld)
                return node.worldScale;
            else
                return node.scale;
        }
        static setScaleX(node, x, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getScale(node, isWorld));
            v3T.x = x;
            NodeHelper.setScale(node, v3T, isWorld);
        }
        static setScaleY(node, y, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getScale(node, isWorld));
            v3T.y = y;
            NodeHelper.setScale(node, v3T, isWorld);
        }
        static setScaleZ(node, z, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getScale(node, isWorld));
            v3T.z = z;
            NodeHelper.setScale(node, v3T, isWorld);
        }
        static setPositionX(node, x, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getPosition(node, isWorld));
            v3T.x = x;
            NodeHelper.setPosition(node, v3T, isWorld);
        }
        static setPositionY(node, y, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getPosition(node, isWorld));
            v3T.y = y;
            NodeHelper.setPosition(node, v3T, isWorld);
        }
        static setPositionZ(node, z, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getPosition(node, isWorld));
            v3T.z = z;
            NodeHelper.setPosition(node, v3T, isWorld);
        }
        static setPositionXY(node, value, isWorld) {
            apeng.Vector3.set(v3T, NodeHelper.getPosition(node, isWorld));
            apeng.Vector2.set(v3T, value);
            NodeHelper.setPosition(node, v3T, isWorld);
        }
        static setPosition(node, value, isWorld, offsetX, offsetY, offsetZ) {
            apeng.Vector3.set(v3T, value);
            if (isNaN(v3T.z))
                v3T.z = 0;
            if (offsetX)
                v3T.x += offsetX;
            if (offsetY)
                v3T.y += offsetY;
            if (offsetZ)
                v3T.z += offsetZ;
            if (isWorld) {
                if (!apeng.Vector3.equalsZero(node.worldPosition, v3T))
                    node.setWorldPosition(v3T);
            }
            else {
                if (!apeng.Vector3.equalsZero(node.position, v3T))
                    node.setPosition(v3T);
            }
        }
        /**
         *
         * @param node
         * @param opacity  0~1
         */
        static setOpacity(node, opacity) {
            let render = node.getComponent(apeng.UIRenderer);
            if (render && !(render instanceof apeng.Graphics)) {
                colorT.set(render.color);
                colorT.a = opacity * 255;
                if (render.color.a != colorT.a)
                    render.color = apeng.EDITOR ? colorT.clone() : colorT;
            }
            else {
                let comp = node.getComponent(apeng.UIOpacity);
                if (!comp)
                    comp = node.addComponent(apeng.UIOpacity);
                if (comp.opacity != opacity * 255)
                    comp.opacity = opacity * 255;
            }
        }
        static getOpacity(node) {
            let render = node.getComponent(apeng.UIRenderer);
            if (render)
                return render.color.a / 255;
            else {
                let comp = node.getComponent(apeng.UIOpacity);
                if (!comp)
                    comp = node.addComponent(apeng.UIOpacity);
                return comp.opacity / 255;
            }
        }
        static getPosition(node, isWorld, offsetX, offsetY, offsetZ) {
            if (!node) {
                this._getPosition.set(ccVec3zero);
                return this._getPosition;
            }
            if (isWorld)
                apeng.Vector3.set(this._getPosition, node.worldPosition);
            else
                apeng.Vector3.set(this._getPosition, node.position);
            if (offsetX)
                this._getPosition.x += offsetX;
            if (offsetY)
                this._getPosition.y += offsetY;
            if (offsetZ)
                this._getPosition.z += offsetZ;
            return this._getPosition;
        }
        static distance(node1, node2, type = "xyz") {
            switch (type) {
                case "xyz":
                    return apeng.Vector3.distance(node1.worldPosition, node2.worldPosition);
                case "xy":
                    return apeng.Vector2.distance(node1.worldPosition, node2.worldPosition);
                case "x":
                    return Math.abs(node1.worldPosition.x - node2.worldPosition.x);
                case "y":
                    return Math.abs(node1.worldPosition.y - node2.worldPosition.y);
                case "z":
                    return Math.abs(node1.worldPosition.z - node2.worldPosition.z);
            }
        }
        static convertToWorldSpaceAR(out, node, point) {
            let transform = NodeHelper.getUITransform(node);
            return transform.convertToWorldSpaceAR(point, out);
        }
        static convertToNodeSpaceAR(out, node, point) {
            let transform = NodeHelper.getUITransform(node);
            v3T.set(point.x, point.y);
            return transform.convertToNodeSpaceAR(v3T, out);
        }
        /**
         * 将 self下的坐标转化为 other下的坐标
         * @param self
         * @param other
         * @param point
         * @returns
         */
        static convertSelfToOtherNodeSpaceAR(out, self, other, point) {
            if (self == other)
                return apeng.Vector3.set(out, point);
            NodeHelper.convertToWorldSpaceAR(out, self, point);
            NodeHelper.convertToNodeSpaceAR(out, other, out);
            return out;
        }
        static isHit(node, point) {
            NodeHelper.getRectangle(RectangleT, node, true);
            return RectangleT.contains(point);
        }
        static getRectangle(out, node, isWorld, ignoreSclae = false) {
            v3T.set(NodeHelper.getXMin(node, isWorld, ignoreSclae), NodeHelper.getYMin(node, isWorld, ignoreSclae));
            v3T2.set(NodeHelper.getXMax(node, isWorld, ignoreSclae), NodeHelper.getYMax(node, isWorld, ignoreSclae));
            return apeng.Rectangle.fromMinMax(out, v3T, v3T2);
        }
        static getYMin(node, isWorld, ignoreSclae = false) {
            let trans = NodeHelper.getUITransform(node);
            let y = isWorld ? node.worldPosition.y : node.position.y;
            return y - (trans.height * (ignoreSclae ? 1 : node.scale.y)) * trans.anchorY;
        }
        static getYMax(node, isWorld, ignoreSclae = false) {
            let trans = NodeHelper.getUITransform(node);
            let y = isWorld ? node.worldPosition.y : node.position.y;
            return y + (trans.height * (ignoreSclae ? 1 : node.scale.y)) * (1 - trans.anchorY);
        }
        static getXMax(node, isWorld, ignoreSclae = false) {
            let trans = NodeHelper.getUITransform(node);
            let x = isWorld ? node.worldPosition.x : node.position.x;
            return x + (trans.width * (ignoreSclae ? 1 : node.scale.x)) * (1 - trans.anchorX);
        }
        static getXMin(node, isWorld, ignoreSclae = false) {
            let trans = NodeHelper.getUITransform(node);
            let x = isWorld ? node.worldPosition.x : node.position.x;
            return x - (trans.width * (ignoreSclae ? 1 : node.scale.x)) * trans.anchorX;
        }
        /**
          * 找到子节点第一个匹配的 name
          * @param node
          * @param name
          */
        static findChildrenByNameOnce(parent, childrenName) {
            let res = null;
            NodeHelper.walkAllChild(parent, (node) => {
                if (node.name == childrenName) {
                    res = node;
                    return true;
                }
            });
            return res;
        }
        /**
        * 找到子节点第一个前缀匹配的
        * @param node
        * @param name
        */
        static findChildrenByPrefixNameOnce(parent, prefixName) {
            let res = null;
            NodeHelper.walkAllChild(parent, (node) => {
                if (apeng.Strings.indexOf(node.name, prefixName) == 0) {
                    res = node;
                    return true;
                }
            });
            return res;
        }
        /**
         * 获取所有子节点 前缀匹配的所有节点
         * @param node
         */
        static findChildrenByNamePrefixs(parent, prefixName, cb) {
            let values = [];
            NodeHelper.walkAllChild(parent, (node) => {
                if (apeng.Strings.indexOf(node.name, prefixName) == 0) {
                    values.push(node);
                    if (cb)
                        cb(node);
                }
            });
            return values;
        }
        /**
         * 将3D节点转换到ui节点下
         * 返回远近比和ui坐标
         * @param out
         * @param uiParent
         * @param converNode
         * @param camera
         * @param distance 距相机多少距离为正常显示计算大小
         * @param useScale 是否是缩放映射
         * @returns
         */
        static coordinateTracker(out, uiParent, converNode, camera, distance, useScale) {
            let wPos = converNode.worldPosition;
            // camera.camera.update()
            camera.convertToUINode(wPos, uiParent, out.converPosition);
            if (useScale)
                apeng.Vec3.transformMat4(v3T2, wPos, camera.camera.matView);
            out.scale = distance / Math.abs(v3T2.z);
            return out;
        }
        /**
     * 保存截图到本地 返回地址
     * @param node
     */
        static getSaveImageUrl(node) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve) => {
                    var _a;
                    if (!node)
                        return resolve("");
                    let contentSize = (_a = node.getComponent(apeng.UITransform)) === null || _a === void 0 ? void 0 : _a.contentSize;
                    if (!contentSize)
                        return resolve("");
                    if (!apeng._platform.isNative)
                        return resolve("");
                    let camera = apeng._ui.UICamera;
                    if (!camera)
                        return resolve("");
                    let renderTex = new apeng.RenderTexture();
                    renderTex.reset({
                        width: apeng.view.getVisibleSize().width,
                        height: apeng.view.getVisibleSize().height,
                    });
                    camera.targetTexture = renderTex;
                    let ablePath = apeng.native.fileUtils.getWritablePath();
                    let fileName = "renderTexture.png";
                    let fillPath = ablePath + fileName;
                    //--删除该文件，存在即删除
                    apeng.native.fileUtils.removeFile(fillPath);
                    //--延时一针，等摄像机绘制
                    apeng._timer.once(null, () => {
                        let wPos = node.getWorldPosition();
                        let _buffer = renderTex.readPixels(Math.round(wPos.x), Math.round(wPos.y), contentSize.width, contentSize.height);
                        apeng.native.saveImageData(_buffer, contentSize.width, contentSize.height, fillPath)
                            .then(() => {
                            camera.targetTexture = null;
                            renderTex.decRef();
                            return resolve(fillPath);
                        }).catch(() => {
                            camera.targetTexture = null;
                            renderTex.decRef();
                            return resolve("");
                        });
                    }, 1 / 60);
                });
            });
        }
    }
    NodeHelper.UICamera = null;
    NodeHelper._getRotateV3 = new apeng.Vec3();
    NodeHelper._getPosition = new apeng.Vec3();
    apeng.NodeHelper = NodeHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 道具管理
     */
    class PropHelper extends apeng.EventDispatcher {
        constructor(
        /**方便使用模块缓存 */
        storage, 
        /**配置表名字 */
        configName, id, 
        /**初始数量 */
        defaultCount, 
        /**最大数量 */
        _maxCount, 
        /**当前数量可超出最大数量 */
        toMax = false, 
        /**缓存前缀 */
        cachePrefix = "") {
            super();
            this.storage = storage;
            this.configName = configName;
            this.id = id;
            this.defaultCount = defaultCount;
            this._maxCount = _maxCount;
            this.toMax = toMax;
            this.cachePrefix = cachePrefix;
            this.intervalTime = null;
            this.autoResumeCount = -1;
            this.isAutoResumeOffline = false;
            /**变换添加时数量 */
            this.addCountConver = null;
            /**变换减少时数量 */
            this.subCountConver = null;
            /**变换最大值 */
            this.maxCountConver = null;
            if (!this.defaultCount)
                this.defaultCount = 0;
            if (!this._maxCount || this._maxCount < 0)
                this._maxCount = 9999999;
        }
        /**是否调用过add接口 */
        get isAdd() { return this.storage.get(this.getCacheKey("a"), "false") == "true"; }
        /**当前数量 */
        get cur() { return this.storage.get(this.getCacheKey("c"), this.defaultCount); }
        /**最大数量 */
        get maxCount() { return this.maxCountConver ? this.maxCountConver(this._maxCount) : this._maxCount; }
        /**
         * 添加数量
         * @param count
         */
        add(count, isAutoResume = false) {
            // console.log("add",count)
            if (count <= 0)
                return;
            if (this.addCountConver)
                count = this.addCountConver(count);
            let _count = this.cur + count;
            if (!this.toMax)
                if (_count > this.maxCount)
                    _count = this.maxCount;
            this.set(_count);
            if (this.cur >= this.maxCount)
                apeng._timer.clear(this, this.onLoopAutoResume);
            let isNew = false;
            if (!this.isAdd) {
                isNew = true;
                this.storage.set(this.getCacheKey("a"), "true");
                this.emit(PropHelper.EventType.ADD_ONCE, count);
            }
            this.emit(PropHelper.EventType.ADD, count, isAutoResume, isNew);
        }
        /**减少数量 */
        sub(count) {
            if (count <= 0)
                return;
            if (this.subCountConver)
                count = this.subCountConver(count);
            let cur = this.cur;
            let _count = this.cur - count;
            if (_count < 0)
                _count = 0;
            this.set(_count);
            // 满体力时重新计算
            if (this.intervalTime)
                if (cur >= this.maxCount)
                    this.intervalTime.setCache();
            // 开启自动恢复
            this.openAutoResume();
        }
        /**
         * 设置当前数量
         * @param count
         */
        set(count, emit = true) {
            if (this.cur == count)
                return;
            let lastCount = this.cur;
            this.storage.set(this.getCacheKey("c"), count);
            if (emit)
                this.emit(PropHelper.EventType.CHANGE, count, lastCount);
        }
        has(count) {
            if (this.cur < count)
                return false;
            return true;
        }
        /**开启自动恢复 */
        openAutoResume() {
            if (this.intervalTime)
                if (this.cur < this.maxCount)
                    apeng._timer.loop(this, this.onLoopAutoResume, 1, -1, 1);
        }
        /**开启自动恢复 */
        initAutoResume(interval, count, offline) {
            this.intervalTime = new apeng.IntervalTimeHelper(this.storage, this.getCacheKey("i"), interval);
            this.autoResumeCount = count;
            this.isAutoResumeOffline = offline;
        }
        /**自动恢复 */
        onLoopAutoResume() {
            if (!this.intervalTime)
                return;
            if (this.intervalTime.sub <= 0) {
                this.intervalTime.setCache();
                this.add(this.autoResumeCount, true);
            }
        }
        /**离线计算收益 */
        autoResumeByOffline(interval, count = this.autoResumeCount) {
            if (!this.isAutoResumeOffline)
                return;
            let mul = this.intervalTime.getOfflineMul(interval);
            let value = mul * count;
            if (value < 1)
                return;
            // 限制最大数量
            let toMax = this.toMax;
            this.toMax = false;
            this.add(Math.floor(value), true);
            this.toMax = toMax;
            this.intervalTime.setCache();
        }
        getCacheKey(value) { return this.cachePrefix + this.configName + this.id + "" + value; }
        dispose() {
            this.storage.delete(this.getCacheKey("a"));
            this.storage.delete(this.getCacheKey("c"));
            if (this.intervalTime)
                this.intervalTime.disponse();
            this.intervalTime = null;
            this.clearEvent();
        }
    }
    PropHelper.EventType = {
        /** id 数量改变时 当前；上一次 */
        CHANGE: "CHANGE",
        /**第一次调用add接口 */
        ADD_ONCE: "ADD_ONCE",
        /**添加数量时 count isAutoResume */
        ADD: "ADD",
    };
    apeng.PropHelper = PropHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
 * 多道具管理
 */
    class PropsHelper {
        constructor(
        /**方便使用模块缓存 */
        storage, 
        /**配置表名字 */
        configName, addOnce, configDatas, 
        /**初始数量 */
        defaultCount, 
        /**最大数量 */
        maxCount, 
        /**当前数量可超出最大数量 */
        toMax, 
        /**自动恢复 */
        isAutoResume, autoResumeIntervale, 
        /**自动恢复增加数量 */
        autoResumeCount, 
        /**离线计算收益 */
        isAutoResumeOffline, 
        /**监听添加数量时 */
        addCount, 
        /**监听数量改变时 */
        changeCount, cachePrefix = "", _updateCount = null) {
            this.storage = storage;
            this.configName = configName;
            this.addOnce = addOnce;
            this.configDatas = configDatas;
            this.defaultCount = defaultCount;
            this.maxCount = maxCount;
            this.toMax = toMax;
            this.isAutoResume = isAutoResume;
            this.autoResumeIntervale = autoResumeIntervale;
            this.autoResumeCount = autoResumeCount;
            this.isAutoResumeOffline = isAutoResumeOffline;
            this.addCount = addCount;
            this.changeCount = changeCount;
            this.cachePrefix = cachePrefix;
            this._updateCount = _updateCount;
            this.datas = new apeng.Maps();
        }
        /**获取已有的所有道具ID */
        getAll(exclude) {
            let ids = [];
            apeng.Maps.forEach(this.configDatas, (v, id) => {
                id = Number(id);
                if (exclude)
                    if (exclude.indexOf(id) != -1)
                        return;
                if (this.get(id).cur > 0)
                    ids.push(id);
            });
            return ids;
        }
        /**获取已调用过 add 接口的 */
        getAdds() {
            let ids = [];
            apeng.Maps.forEach(this.configDatas, (v, id) => {
                if (this.get(id).isAdd)
                    ids.push(id);
            });
            return ids;
        }
        updateCount() {
            if (this._updateCount)
                this._updateCount();
            for (let id in this.configDatas) {
                let data = this.get(Number(id));
                data._maxCount = this.maxCount(data.id);
                data.defaultCount = this.defaultCount(data.id);
                data.set(data.defaultCount, false);
            }
        }
        /**获取当前数据 */
        get(id) {
            let data = this.datas.get(id);
            if (!data) {
                data = new apeng.PropHelper(this.storage, this.configName, Number(id), this.defaultCount(id), this.maxCount(id), this.toMax(id), this.cachePrefix);
                if (this.isAutoResume
                    && this.autoResumeIntervale
                    && this.autoResumeCount
                    && this.isAutoResumeOffline
                    && this.isAutoResume(id))
                    data.initAutoResume(this.autoResumeIntervale(id), this.autoResumeCount(id), this.isAutoResumeOffline(id));
                if (this.addCount)
                    data.once(apeng.PropHelper.EventType.ADD_ONCE, () => {
                        this.addOnce(id);
                    }, this);
                if (this.addCount)
                    data.on(apeng.PropHelper.EventType.ADD, (count, isAutoResume, isNew) => {
                        this.addCount(id, count, isAutoResume, isNew);
                    }, this);
                if (this.changeCount)
                    data.on(apeng.PropHelper.EventType.CHANGE, (count) => {
                        this.changeCount(id, count);
                    }, this);
                //  校验最大数量
                if (this._updateCount) {
                    if (!data.toMax) {
                        if (data.cur > data.maxCount)
                            data.set(data.maxCount, false);
                    }
                }
                this.datas.set(id, data);
            }
            return data;
        }
    }
    apeng.PropsHelper = PropsHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 皮肤管理
     */
    class SkinHelper extends apeng.EventDispatcher {
        constructor(
        /**方便使用模块缓存 */
        storage, 
        /**配置表的名称 */
        configName, 
        /**默认解锁的ID */
        defaultID) {
            super();
            this.storage = storage;
            this.configName = configName;
            this.defaultID = defaultID;
            this.configDatas = null;
            this._defaultUnlocks = null;
            this.configDatas = apeng._config_.obj[this.configName];
        }
        /**当前皮肤ID */
        get cur() { return this.storage.get(this.getCacheKey("c"), this.defaultID); }
        /**上次使用的ID */
        get lastCur() { return this.storage.get(this.getCacheKey("l"), this.defaultID); }
        /**已解锁的 */
        get unlocks() { return this.storage.get(this.getCacheKey("u"), this.getDefaultUnlocks()); }
        /**未解锁的皮肤 */
        get noUnlocks() {
            let res = [];
            apeng.Maps.forEach(this.configDatas, (config, k) => {
                let id = Number(k);
                if (!this.has(id))
                    res.push(id);
            });
            return res;
        }
        getCacheKey(value) { return this.configName + "s" + value; }
        /**是否已解锁 */
        has(id) { return apeng.Sets.has(this.unlocks, id); }
        /**解锁皮肤 */
        unlock(id) {
            if (this.has(id))
                return;
            this.unlocks.push(id);
            this.storage.set(this.getCacheKey("u"), this.unlocks);
            this.emit(SkinHelper.EventType.UNLOCK, id);
        }
        /**
         * 使用皮肤
         * @param id
         * @param isTip
         * @returns
        */
        use(id) {
            if (this.cur == id)
                return;
            if (!this.has(id))
                return;
            // 上一次使用的id
            this.storage.set(this.getCacheKey("l"), this.cur);
            this.storage.set(this.getCacheKey("c"), id);
            this.emit(SkinHelper.EventType.CHANGE_AFTER, id);
            this.emit(SkinHelper.EventType.CHANGE, id);
        }
        /**获取当前类型 中 未解锁的ID */
        getUnlockTypeByNoIDs(type) {
            let ids = [];
            apeng.Maps.forEach(this.configDatas, (config, k) => {
                let id = Number(k);
                if (config.unlock_type == type)
                    if (!this.has(id))
                        ids.push(id);
            });
            return ids;
        }
        /**是否可以使用 反之则未开放状态 */
        hasIDUse(id) { return this.configDatas[id].is_use == 1; }
        /**默认解锁的 */
        getDefaultUnlocks() {
            if (this._defaultUnlocks == null) {
                this._defaultUnlocks = [];
                apeng.Maps.forEach(this.configDatas, (config, k) => {
                    let id = Number(k);
                    if (config.is_unlock == 1)
                        this._defaultUnlocks.push(id);
                });
            }
            return this._defaultUnlocks;
        }
    }
    SkinHelper.EventType = {
        /** id */
        CHANGE_AFTER: "CHANGE_AFTER",
        /** id */
        CHANGE: "CHANGE",
        /** id */
        UNLOCK: "UNLOCK",
    };
    apeng.SkinHelper = SkinHelper;
})(apeng || (apeng = {}));

(function (apeng) {
    const v2T = new apeng.Vector2();
    class BaseHollow {
        constructor() {
            /**点击镂空区域时 */
            this.clickShape = null;
            /**分发事件流node */
            this.eventNode = null;
            /**延迟绘制 */
            this.delay = -1;
            this.fingerNode = null;
            this.itemParent = null;
            this.graphics = null;
            this.outlineGraphics = null;
            /**显示手指动画 */
            this.isFingerAnim = false;
            /**播放镂空的缩放动画 */
            this.isScaleAnim = false;
            /**绘制 */
            this.isDraw = true;
            this.scaleMax = 5;
            this.scaleDuration = .5;
            this.scaleEase = apeng.EEaseType.quintOut;
            /**手指相对于形状中心点的偏移 */
            this.fingerOffsetPoint = null;
            this.fingerAngle = 0;
            /**脏标记 */
            this.dirty = true;
            this._curScale = 0;
        }
        init(itemParent, graphics, outline) {
            this.itemParent = itemParent;
            this.graphics = graphics;
            this.outlineGraphics = outline;
            if (this.onCreate)
                this.onCreate();
            this.updateFingerPosition();
            if (this.isScaleAnim)
                this._onScaleStart();
            else {
                if (this.isFingerAnim)
                    this.updateFingerPosition();
                if (this.outlineGraphics)
                    this.outlineGraphics.node.active = true;
            }
            return this;
        }
        setDelay(delay) {
            this.delay = delay;
            return this;
        }
        setIsDraw(isDraw) {
            this.isDraw = isDraw;
            return this;
        }
        setFinger(offset, angle = 0) {
            this.isFingerAnim = true;
            this.fingerAngle = angle;
            this.fingerOffsetPoint = new apeng.Vector2(offset);
            return this;
        }
        setAnim(duration, scaleMax = this.scaleMax, ease = this.scaleEase) {
            this.scaleDuration = duration;
            this.scaleMax = scaleMax;
            this.scaleEase = ease;
            this.isScaleAnim = true;
            return this;
        }
        setClick(cb, node) {
            this.clickShape = cb;
            this.eventNode = node;
            return this;
        }
        onClick(e) {
            if (this.clickShape)
                this.clickShape(e);
            if (this.eventNode) {
                let node = typeof this.eventNode == "function" ? this.eventNode() : this.eventNode;
                apeng.EventHandlerCC.runClick(node, e);
            }
        }
        updateFingerPosition() {
            if (!this.isFingerAnim)
                return;
            apeng.Vector2.add(v2T, this.getShapeCenter(), this.fingerOffsetPoint);
            apeng.NodeHelper.setPositionXY(this.fingerNode, v2T, true);
        }
        onUpdate2() {
            if (!this.isScaleAnim)
                return;
            if (this._curScale == 1)
                return;
            this.dirty = true;
            this._curScale = this._curScale + apeng._timer.dtDefault * (1 / this.scaleDuration);
            if (this._curScale > 1)
                this._curScale = 1;
            let scale = this.scaleMax * (1 - apeng.easing(this.scaleEase, this._curScale)) + 1;
            this.onScaleing(scale);
            if (this._curScale == 1)
                this._onScaleEnd();
        }
        _onScaleStart() {
            if (this.isFingerAnim)
                this.fingerNode.active = false;
            if (this.outlineGraphics)
                this.outlineGraphics.node.active = false;
            if (this.onScaleStart)
                this.onScaleStart();
        }
        _onScaleEnd() {
            if (this.isFingerAnim)
                this.fingerNode.active = true;
            if (this.outlineGraphics)
                this.outlineGraphics.node.active = true;
            if (this.onScaleEnd)
                this.onScaleEnd();
        }
    }
    apeng.BaseHollow = BaseHollow;
})(apeng || (apeng = {}));
/// <reference path="./BaseHollow.ts" />

(function (apeng) {
    class CircleHollow extends apeng.BaseHollow {
        constructor(_circle, circleHeight = null) {
            super();
            this._circle = _circle;
            this.circleHeight = circleHeight;
            this.circle = null;
            this.copyCircle = null;
        }
        onCreate() {
            if (typeof this._circle == "function")
                this.circle = this._circle();
            else
                this.circle = this._circle;
            if (this.isScaleAnim)
                this.copyCircle = this.circle.clone();
        }
        onScaleing(scale) {
            this.copyCircle.mul(this.circle, scale);
        }
        draw() {
            if (this.circleHeight) {
                this.graphics.ellipse(this.circle.x, this.circle.y, this.circle.radius, this.circleHeight);
                if (this.outlineGraphics)
                    this.outlineGraphics.ellipse(this.circle.x, this.circle.y, this.circle.radius, this.circleHeight);
            }
            else {
                this.graphics.circle(this.circle.x, this.circle.y, this.circle.radius);
                if (this.outlineGraphics)
                    this.outlineGraphics.circle(this.circle.x, this.circle.y, this.circle.radius);
            }
        }
        getShapeCenter() {
            return this.circle.position;
        }
        intersection(touchPosition) {
            return this.circle.contains(touchPosition);
        }
    }
    apeng.CircleHollow = CircleHollow;
})(apeng || (apeng = {}));

(function (apeng) {
    /**节点镂空 拷贝节点到遮罩之上 */
    class NodeHollow extends apeng.BaseHollow {
        /**
         *
         * @param node 复制的节点
         * @param syncPosition 实时同步世界坐标
         */
        constructor(_node, syncPosition = false, createCopyNode) {
            super();
            this._node = _node;
            this.syncPosition = syncPosition;
            this.createCopyNode = createCopyNode;
            this.node = null;
            this.copyNode = null;
            this.rect = new apeng.Rectangle();
        }
        onCreate() {
            if (typeof this._node == "function")
                this.node = this._node();
            else
                this.node = this._node;
            apeng.NodeHelper.getRectangle(this.rect, this.node, true);
            this.copyNode = apeng.instantiate(this.node);
            this.copyNode.active = true;
            apeng.NodeHelper.setPositionX(this.copyNode, -10000, false);
            this.itemParent.addChild(this.copyNode);
            apeng.NodeHelper.setPosition(this.copyNode, this.node.worldPosition, true);
            this.copyNode.pauseSystemEvents(true);
            if (this.createCopyNode)
                this.createCopyNode(this.copyNode);
        }
        onScaleing(scale) {
        }
        onUpdate() {
            if (this.syncPosition && this.node && this.copyNode) {
                apeng.NodeHelper.setPosition(this.copyNode, this.node.worldPosition, true);
                apeng.NodeHelper.getRectangle(this.rect, this.node, true);
                this.updateFingerPosition();
            }
        }
        getShapeCenter() {
            return this.rect.center;
        }
        intersection(touchPosition) {
            return this.rect.contains(touchPosition);
        }
    }
    apeng.NodeHollow = NodeHollow;
})(apeng || (apeng = {}));
/// <reference path="./../utils/Vector3.ts" />

(function (apeng) {
    const v3T = new apeng.Vector3();
    class PolygonHollow extends apeng.BaseHollow {
        constructor(_polygon) {
            super();
            this._polygon = _polygon;
            this.polygon = null;
            this.copyPolygon = null;
            this.centerPolygon = null;
        }
        onCreate() {
            if (typeof this._polygon == "function")
                this.polygon = this._polygon();
            else
                this.polygon = this._polygon;
            if (this.isScaleAnim) {
                this.copyPolygon = [];
                this.centerPolygon = new apeng.Vector2(this.getShapeCenter());
                for (let value of this.polygon)
                    this.copyPolygon.push(new apeng.Vector2(value).subSelf(this.centerPolygon));
            }
        }
        onScaleStart() {
        }
        onScaleEnd() {
        }
        onScaleing(scale) {
            let i = 0;
            for (let value of this.copyPolygon) {
                apeng.Vector2.mul(v3T, value, scale);
                apeng.Vector2.add(this.polygon[i], v3T, this.centerPolygon);
                i++;
            }
        }
        draw() {
            if (this.outlineGraphics)
                this.outlineGraphics.moveTo(this.polygon[0].x, this.polygon[0].y);
            this.graphics.moveTo(this.polygon[0].x, this.polygon[0].y);
            for (let i = 1; i < this.polygon.length; i++) {
                let point = this.polygon[i];
                this.graphics.lineTo(point.x, point.y);
                if (this.outlineGraphics)
                    this.outlineGraphics.lineTo(point.x, point.y);
            }
            if (this.outlineGraphics)
                this.outlineGraphics.lineTo(this.polygon[0].x, this.polygon[0].y);
            this.graphics.lineTo(this.polygon[0].x, this.polygon[0].y);
        }
        getShapeCenter() {
            return apeng.Vector2.polygonByCenterPoint(v3T, this.polygon);
        }
        intersection(touchPosition) {
            return apeng.Polygon.pointInPolygon(touchPosition, this.polygon);
        }
    }
    apeng.PolygonHollow = PolygonHollow;
})(apeng || (apeng = {}));

(function (apeng) {
    class RectHollow extends apeng.BaseHollow {
        constructor(_rect, rectRadius = null) {
            super();
            this._rect = _rect;
            this.rectRadius = rectRadius;
            this.rect = null;
            this.copyRect = null;
        }
        onCreate() {
            if (typeof this._rect == "function")
                this.rect = this._rect();
            else
                this.rect = this._rect;
            if (this.isScaleAnim)
                this.copyRect = this.rect.clone();
        }
        onScaleing(scale) {
            this.copyRect.mul(this.rect, scale);
        }
        draw() {
            if (this.rectRadius) {
                if (this.outlineGraphics)
                    this.outlineGraphics.roundRect(this.rect.x, this.rect.y, this.rect.width, this.rect.height, this.rectRadius);
                this.graphics.roundRect(this.rect.x, this.rect.y, this.rect.width, this.rect.height, this.rectRadius);
            }
            else {
                if (this.outlineGraphics)
                    this.outlineGraphics.rect(this.rect.x, this.rect.y, this.rect.width, this.rect.height);
                this.graphics.rect(this.rect.x, this.rect.y, this.rect.width, this.rect.height);
            }
        }
        getShapeCenter() {
            return this.rect.center;
        }
        intersection(touchPosition) {
            return this.rect.contains(touchPosition);
        }
    }
    apeng.RectHollow = RectHollow;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let AudioModule = class AudioModule extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            /**音频资源池 */
            this.datas = new Map();
            this.curMusicUrl = "";
        }
        onLogic() {
            apeng._main.once(apeng._main.EventType.TOUCH_DOWN, () => {
                // 检测背景音乐未开启
                apeng._timer.once(null, () => {
                    if (this.checkPlaying(this.curMusicUrl))
                        this.playMusic(this.curMusicUrl);
                }, .5);
            });
        }
        /**设置全部音量 控制开关 */
        setVolume(music, ratio) {
            if (this.getVolume(music) == ratio)
                return;
            this.storage.set("AudioMgr.allVolume" + music, ratio);
            this.datas.forEach((data, url) => {
                if (music) {
                    if (data.music && data.source)
                        if (data.source.playing)
                            data.source.volume = this.getCurVolume(url);
                }
                else {
                    if (!data.music && data.source)
                        if (data.source.playing)
                            data.source.volume = this.getCurVolume(url);
                }
            });
        }
        getVolume(music) { return this.storage.get("AudioMgr.allVolume" + music, 1); }
        setDefalutVolume(url, ratio) {
            if (!url)
                return;
            let data = this.getData(url);
            data.volume = ratio;
        }
        setStartTime(url, time) {
            if (!url)
                return;
            let data = this.getData(url);
            data.startTime = time;
        }
        /**设置音量缩放 */
        setScaleVolume(url, ratio) {
            if (!url)
                return;
            let data = this.getData(url);
            data.volumeScale = ratio;
            if (data.source)
                data.source.volume = this.getCurVolume(url);
        }
        /**当前的真正音量大小 */
        getCurVolume(url) {
            let data = this.getData(url);
            return data.volume * this.getVolume(data.music) * data.volumeScale;
        }
        /**播放音频，默认停止上一个 如需不停止 使用 this.playMore接口 */
        play(url, loop = false, music = false, reset = true) {
            if (!url)
                return;
            let data = this.getData(url);
            if (!data.source) {
                this.load(url, -1, (success) => {
                    if (success)
                        this.play(url, loop, music);
                });
                return;
            }
            data.music = music;
            if (reset || data.source.state != apeng.AudioSource.AudioState.PLAYING) {
                data.source.loop = loop;
                this._playSource(url, data.source);
            }
        }
        /**不停止上一个 需要已加载完毕的 才可播放 */
        playMore(url) {
            let data = this.getData(url);
            if (!data.source) {
                let clip = apeng._resouces.get(url, apeng.AudioClip);
                if (clip)
                    data.source = this.addAudioSouce(clip);
                else
                    return;
            }
            let source = null;
            for (let v of data.sources)
                if (v.state != apeng.AudioSource.AudioState.PLAYING) {
                    source = v;
                    break;
                }
            if (!source) {
                source = this.addAudioSouce(data.source.clip);
                data.sources.push(source);
            }
            this._playSource(url, source);
        }
        _playSource(url, source) {
            let data = this.getData(url);
            source.volume = this.getCurVolume(url);
            source.play();
            if (data.startTime != 0)
                source.currentTime = data.startTime;
        }
        playMusic(url) {
            if (!url)
                return;
            if (this.curMusicUrl == url) {
                if (this.checkPlaying(url))
                    this.play(url, true, true, false);
                return;
            }
            // 停止之前的
            this.datas.forEach(v => {
                if (v.url == url)
                    return;
                if (v.music)
                    this.stop(v.url);
            });
            this.curMusicUrl = url;
            this.checkPlaying(url);
            this.play(url, true, true, false);
        }
        checkPlaying(url) {
            let data = this.getData(url);
            if (data && data.source) {
                if (data.source.state == apeng.AudioSource.AudioState.INIT) {
                    if (data.source)
                        data.source.node.removeFromParent();
                    data.source = null;
                    console.log("检测到背景声未播放 清除数据");
                    return true;
                }
            }
            return false;
        }
        resumeAll() {
            this.datas.forEach((data, url) => {
                this.resume(url);
            });
        }
        pauseAll() {
            this.datas.forEach((data, url) => {
                this.pause(url);
            });
        }
        resume(url) {
            if (!url)
                return;
            let data = this.getData(url);
            if (!data.source)
                return;
            if (data.source.state == apeng.AudioSource.AudioState.PAUSED)
                data.source.play();
        }
        pause(url) {
            if (!url)
                return;
            let data = this.getData(url);
            if (!data.source)
                return;
            if (data.source.state == apeng.AudioSource.AudioState.PLAYING)
                data.source.pause();
        }
        stop(url) {
            if (!url)
                return;
            let data = this.getData(url);
            if (!data.source)
                return;
            data.source.stop();
        }
        /**
         * 加载一个音频
         * @param url
         * @param cb
         */
        load(url, delay = -1, cb) {
            if (!url)
                return;
            let data = this.getData(url);
            if (data.source) {
                if (cb)
                    cb(true);
                return;
            }
            apeng._timer.once(this, () => {
                apeng._resouces.load({ url, type: apeng.AudioClip }, (clip) => {
                    if (clip)
                        data.source = this.addAudioSouce(clip);
                    if (cb)
                        cb(!!clip);
                }, null, true);
            }, delay);
        }
        addAudioSouce(clip) {
            let comp = apeng.NodeHelper.getChildByCreate(apeng._ui.getLayerParent(apeng.EUILayer.Top), "_audio_")
                .addComponent(apeng.AudioSource);
            comp.clip = clip;
            return comp;
        }
        getData(url) {
            let data = this.datas.get(url);
            if (!data) {
                data = {
                    source: null,
                    sources: [],
                    url,
                    volume: 1,
                    music: false,
                    volumeScale: 1,
                    startTime: 0,
                };
                this.datas.set(url, data);
            }
            return data;
        }
    };
    AudioModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.audio)
    ], AudioModule);
    apeng.AudioModule = AudioModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let GmModule = class GmModule extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.datas = [];
        }
        onLogic() {
            if (apeng.initData.openGm)
                apeng._ui.open("gm/prefab/GMUI", null, null, null, false);
        }
        addData(data) {
            this.datas[this.datas.length] = data;
            return this;
        }
        getDatas() {
            return this.datas;
        }
        /**执行 dec 的点击 方便命令行调试 */
        click(dec, input) {
            let data = apeng.Sets.filterValue(this.datas, v => v.dec === dec);
            if (data)
                data.click(input);
        }
    };
    GmModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.gm)
    ], GmModule);
    apeng.GmModule = GmModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let GuideModule = class GuideModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**新手引导完成 */
                NEW_USER_COMPLETE: "NEW_USER_COMPLETE",
                /**新手引导 队列 */
                NEW_USER_COMPLETE_QUEUE: "NEW_USER_COMPLETE_QUEUE",
                FINGER_CLICK: "FINGER_CLICK",
            };
            this.models = {};
        }
        /**新手引导已完成 */
        get newUserComplete() { return this.storage.get("isComplete", "false") == "true"; }
        // public get newUserComplete() { return true }
        /**新手引导当前步骤 */
        get newUserCur() { return this.storage.get("GuideModule.newUserCur", 0); }
        /**新手引导的索引 data数组索引*/
        get newUserIndex() { return this.storage.get("GuideModule.newUserIndex", -1); }
        onCreate() {
            apeng._ui.setPreLoadUrls("guide/prefab/GuideMaskUI", () => [
                { url: apeng.CGuideDefine.fingerUrl, type: apeng.Prefab }
            ]);
        }
        trigger() {
            // 开启新手引导
            if (!this.newUserComplete) {
                apeng._ui.blockTouchEvent(true, apeng.EUILayer.ItemUp, apeng._ui.stageUp);
                // 进入阶段引导
                let model = this.models[this.newUserCur];
                if (this.newUserIndex >= model.completeIndex)
                    // 进入下一引导
                    this.next(true);
                else {
                    // 重新开始当前引导
                    this.storage.set("GuideModule.newUserCur", this.newUserCur - 1);
                    this.storage.set("GuideModule.newUserIndex", -1);
                    this.next(true);
                }
            }
        }
        /**从后往前获取数组索引 */
        getLastByIndex(type, lastIndex) {
            let model = this.models[type];
            return model.datas.length - lastIndex - 1;
        }
        /**添加模块引导 */
        add(type, data) {
            this.models[type] = data;
            if (data.completeIndex == -1)
                data.completeIndex = data.datas.length - 1;
            return this;
        }
        addOnce(data) {
            this.add(0, data);
            return this;
        }
        getOnceLastByIndex(lastIndex) {
            return this.getLastByIndex(0, lastIndex);
        }
        /**当前步骤完成 */
        complete() {
            if (this.newUserComplete)
                return;
            this.storage.set("GuideModule.newUserIndex", this.newUserIndex + 1);
            let model = this.models[this.newUserCur];
            console.log("引导:", this.newUserCur, this.newUserIndex, model.completeIndex, this.newUserIndex >= model.completeIndex);
            let data = model.datas[this.newUserIndex];
            if (!data)
                // 进入下个模块
                this.next();
            else
                data();
        }
        /**下一模块 */
        next(isOnce = false) {
            let newModel = this.models[this.newUserCur + 1];
            // 引导完成
            if (!newModel) {
                console.log("引导完成");
                apeng._ui.blockTouchEvent(false, apeng.EUILayer.ItemUp, apeng._ui.stageUp);
                this.storage.set("isComplete", "true");
                this.emit(this.EventType.NEW_USER_COMPLETE);
                this.emitQueue(this.EventType.NEW_USER_COMPLETE_QUEUE, -1, () => {
                    console.log("引导队列完成");
                }, index => index + "");
            }
            else {
                this.storage.set("GuideModule.newUserCur", this.newUserCur + 1);
                this.storage.set("GuideModule.newUserIndex", -1);
                apeng._main.changeScene(newModel.sceneUrl, () => {
                    newModel.enter(() => this.complete());
                }, isOnce ? 2 : -1);
            }
        }
        moveFinger(framWorldPosition, toWorldPosition) {
            apeng._guide.mask({
                drag: {
                    framWorldPosition,
                    toWorldPosition,
                }
            });
        }
        dialogue(data) {
            apeng._ui.open("guide/prefab/GuideDialogueUI", data, null, null, false);
        }
        mask(data) {
            apeng._ui.open("guide/prefab/GuideMaskUI", data, null, null, false);
        }
        finger(finger) {
            apeng._ui.open("guide/prefab/GuideFingerUI", finger, null, null, false);
        }
        closeDialogue() {
            apeng._ui.close("guide/prefab/GuideDialogueUI");
        }
        closeMask() {
            apeng._ui.close("guide/prefab/GuideMaskUI");
        }
        closeFinger() {
            apeng._ui.close("guide/prefab/GuideFingerUI");
        }
        /**单个ui模块引导 */
        ui(uiUrl, cacheKey, cb, delay = 0) {
            apeng._ui.once(apeng._ui.EventType.OPEN, (url) => {
                if (url == uiUrl) {
                    if (this.storage.get(cacheKey, "false") == "false") {
                        let ui = apeng._ui.getModule(uiUrl).ui;
                        apeng._ui.blockTouchEvent(true, apeng.EUILayer.ItemUp, apeng._ui.stageUp);
                        apeng._timer.once(this, () => {
                            cb(ui, () => {
                                this.storage.set(cacheKey, "true");
                                apeng._ui.blockTouchEvent(false, apeng.EUILayer.ItemUp, apeng._ui.stageUp);
                            });
                        }, delay);
                        return true;
                    }
                    return false;
                }
                return false;
            });
        }
        maskByPolygon(collider, conver, worldPosition) {
            let hollow = new apeng.PolygonHollow(() => {
                let shape = collider.getShape(1, worldPosition || collider.node.worldPosition);
                if (conver)
                    conver(shape);
                return shape.getPolygon();
            })
                .setFinger([0, 0])
                .setAnim(.5);
            apeng._timer.callLater(this, this.mask, [{
                    clickShapeByCloseUI: true,
                    hollows: [hollow]
                }]);
            return hollow;
        }
        maskByCircle(node, conver, closeUI = true) {
            let pos = node.worldPosition;
            let hollow = new apeng.CircleHollow(() => {
                let circle = new apeng.Circle(pos.x, pos.y, apeng.NodeHelper.getUITransform(node).width / 2);
                if (conver)
                    conver(circle);
                return circle;
            })
                .setFinger([0, 0])
                .setAnim(.5);
            apeng._timer.callLater(this, this.mask, [{
                    clickShapeByCloseUI: closeUI,
                    hollows: [hollow]
                }]);
            return hollow;
        }
        maskByRect(node, radius, conver, closeUI = true) {
            let hollow = new apeng.RectHollow(() => {
                let rect = apeng.NodeHelper.getRectangle(new apeng.Rectangle(), node, true);
                if (conver)
                    conver(rect);
                return rect;
            }, radius)
                .setFinger([0, 0])
                .setAnim(.5);
            apeng._timer.callLater(this, this.mask, [{
                    clickShapeByCloseUI: closeUI,
                    hollows: [hollow]
                }]);
            return hollow;
        }
    };
    GuideModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.guide)
    ], GuideModule);
    apeng.GuideModule = GuideModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let LanguageModule = class LanguageModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                CHANGE: "CHANGE",
            };
            this.cur = null;
            this.curStr = null;
            this._datas = {};
        }
        onCreate() {
            this.updateType();
            // 集合语言表数据
            for (let configName in apeng.initData.configDefine)
                if (configName.indexOf("language") != -1) {
                    let configs = apeng._config_.obj[configName];
                    for (let id in configs)
                        this._datas[id] = configs[id];
                }
            let languageDefine = apeng.initData.languageDefine;
            if (languageDefine && languageDefine.chinese) {
                for (let id in languageDefine.chinese) {
                    //@ts-ignore
                    this._datas[id] = [languageDefine.chinese[id]];
                }
                for (let key in languageDefine) {
                    let index = apeng.ELanguageType[key];
                    if (index) {
                        let datas = languageDefine[key];
                        for (let id in datas) {
                            //@ts-ignore
                            this._datas[id][index] = datas[id];
                        }
                    }
                }
                this.updateType();
            }
        }
        onLogic() {
            apeng._gm
                .addData({
                dec: "切换为中文",
                click: () => {
                    this.change(apeng.ELanguageType.chinese);
                }
            })
                .addData({
                dec: "切换为繁体",
                click: () => {
                    this.change(apeng.ELanguageType.traditional);
                }
            })
                .addData({
                dec: "切换为英文",
                click: () => {
                    this.change(apeng.ELanguageType.english);
                }
            })
                .addData({
                dec: "切换为西班牙",
                click: () => {
                    this.change(apeng.ELanguageType.spanish);
                }
            })
                .addData({
                dec: "切换为葡萄牙",
                click: () => {
                    this.change(apeng.ELanguageType.portuguese);
                }
            })
                .addData({
                dec: "切换为越南",
                click: () => {
                    this.change(apeng.ELanguageType.vietnamese);
                }
            })
                .addData({
                dec: "切换为印尼",
                click: () => {
                    this.change(apeng.ELanguageType.indonesia);
                }
            });
        }
        change(type) {
            if (apeng.initData.getLanguageType(apeng.ELanguageType) == apeng.ELanguageType[type]) {
                apeng._ui.tip("是当前语言无需切换");
                return;
            }
            apeng._ui.Loading.wait(true);
            this.setLanguageType(type);
            this.updateType();
            console.log("切换语言" + this.curStr);
            apeng._ui
                .closeAll(apeng.EUILayer.Panel)
                .closeAll(apeng.EUILayer.Notice)
                .closeAll(apeng.EUILayer.Item);
            this.emitQueue(this.EventType.CHANGE, -1, () => {
                console.log("切换成功");
                apeng._timer.once(this, () => {
                    apeng._ui.Loading.wait(false);
                }, .3);
            });
            // PlatformMgr.reStart()
        }
        updateType() {
            this.curStr = apeng.initData.getLanguageType(apeng.ELanguageType);
            this.cur = apeng.ELanguageType[this.curStr];
        }
        /**设置当前的语言id */
        setLanguageType(type) {
            localStorage.setItem("language", type + "");
        }
        /**通过lang配置表获取对应的文本 */
        get(id) {
            let obj = this._datas[id];
            if (!obj)
                return "";
            return obj[this.cur];
        }
        replace(id, str) {
            return this.get(id).replace("{0}", str);
        }
        /**获取语言对应图片的路径 */
        getSpriteFrame(url) {
            if (this.cur == apeng.ELanguageType.chinese)
                return url;
            return "languageTexture/" + this.curStr + "/" + url;
        }
        /**格式化图片路径 */
        converSpriteFrameUrl(url) {
            let index = url.indexOf("languageTexture/");
            if (index == -1)
                return url;
            // "languageTexture/".length=16 +1 =17
            index = url.indexOf("/", index + 17);
            return url.substring(index + 1);
        }
    };
    LanguageModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.language)
    ], LanguageModule);
    apeng.LanguageModule = LanguageModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let LoginModule = class LoginModule extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            /**是新用户 */
            this.isNewUser = false;
            this._requests = new apeng.Maps();
        }
        get registTime() { return this.storage.get("registTime", -1); }
        get userData() { return this.storage.get("userData", null); }
        onInstance() {
            if (this.storage.get("isNewUser", "false") == "false") {
                this.storage.set("isNewUser", "true");
                this.storage.set("registTime", apeng.Times.second());
                this.isNewUser = true;
            }
            else
                this.isNewUser = false;
        }
        onLogic() {
            this.login();
        }
        updateInfo(value) {
            let data = this.userData;
            data.name = value.name;
            data.img_url = value.avatarUrl;
            this.storage.set("userData", data, false);
            this.request("user/updateInfo", new apeng.si.User.CSInfo(value.name, value.avatarUrl));
        }
        requestByLogin(path, data, complete, loading = false) {
            this.login(() => {
                this.request(path, data, complete, loading);
            });
        }
        login(complete) {
            if (!apeng.initData.server || !apeng.initData.server.gameId || !apeng.initData.server.requestIp)
                return;
            if (this.userData) {
                if (complete)
                    complete();
                return;
            }
            let _data = new apeng.si.User.CSLogin("", apeng._platform.config.appid, "", apeng.si.EPlatformType[apeng._platform.type]);
            let fn = () => {
                this.request("user/login", _data, (res) => {
                    this.storage.set("userData", res);
                    if (complete)
                        complete();
                });
            };
            switch (apeng._platform.type) {
                case apeng.EPlatformType.wx:
                    apeng._platform.instance.login((code) => {
                        _data.openid = "";
                        _data.jscode = code;
                        fn();
                    });
                    break;
                default:
                    apeng._platform.instance.getSystemId((code) => {
                        _data.openid = code;
                        _data.jscode = "";
                        fn();
                    });
                    break;
            }
        }
        request(path, data, complete, loading = false) {
            if (!apeng.initData.server || !apeng.initData.server.gameId || !apeng.initData.server.requestIp)
                return;
            data.game_id = apeng.initData.server.gameId;
            if (this.userData)
                data.user_id = this.userData.user_id;
            let request = this._requests.get(path);
            if (!request) {
                request = {
                    http: new apeng.HttpRequest(apeng.initData.server.requestIp, path, "POST", false),
                    cb: new apeng.CompleteCallBack()
                };
                this._requests.set(path, request);
                if (loading) {
                    let hide = () => apeng._ui.Loading.wait(false);
                    request.http.on(apeng.HttpRequest.EventType.START, () => apeng._ui.Loading.wait(true));
                    request.http.on(apeng.HttpRequest.EventType.COMPLETE, hide);
                    request.http.on(apeng.HttpRequest.EventType.NONE, hide);
                    request.http.on(apeng.HttpRequest.EventType.ERROR, hide);
                }
                request.http.on(apeng.HttpRequest.EventType.COMPLETE, (res) => {
                    if (!res.errorCode)
                        request.cb.run(res.data);
                });
            }
            request.cb.set(complete);
            request.http.send(data);
            return request.http;
        }
    };
    LoginModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.login)
    ], LoginModule);
    apeng.LoginModule = LoginModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    const v2T = new apeng.Vec2();
    const v2T2 = new apeng.Vec2();
    const v2T3 = new apeng.Vec2();
    let MainModule = class MainModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**新的一天 */
                NEW_DAY: "NEW_DAY",
                /**当日首次上线 不包括第一天*/
                TODAY_ONCE_ONLINE: "TODAY_ONCE_ONLINE",
                SHOW_QUERY: "SHOW_QUERY",
                /**为false 时播放点击特效 worldPosition */
                HAS_PLAY_CLICK_EFFECT: "HAS_PLAY_CLICK_EFFECT",
                /**手指按下时 */
                TOUCH_DOWN: "TOUCH_DOWN",
                TOUCH_UP: "TOUCH_UP",
                /**参数 false 播放完成 */
                VIDEO_COMPLETE: "VIDEO_COMPLETE",
            };
            /**循环定时器推送服务器间隔 一般用于存储时间 */
            this.loopIntervalServer = 30;
            /**游戏开始时的时间 秒 */
            this.startTime = -1;
            /**进入游戏时的离线时间 */
            this.offlineTime = -1;
            /**预加载队列 */
            this.preLoadQueue = null;
            /**是当前天 */
            this._isToDay = true;
            /**上次添加时间 */
            this.lastOnlineTimeAdd = apeng.Times.second();
            this.loadingCompleteColor = new apeng.Color();
            this.showVideoQuery = "video";
        }
        /**已在线所有时长 */
        get onlineTime() {
            this.updateLogicTime();
            return this.storage.get("MainModel.onlineTime", 0);
        }
        /**今日在线的时长 */
        get onlineTimeToDay() {
            this.updateLogicTime();
            return this.storage.get("MainModel.onlineTimeToDay", 0);
        }
        /**已离线了多少分钟 */
        get offlineByMinute() { return apeng.StorageLogic.offlineByMinute(this.offlineTime); }
        /**已离线了多少小时 */
        get offlineByHour() { return apeng.StorageLogic.offlineByHour(this.offlineTime); }
        /**已离线了多少天 */
        get offlineByDay() { return apeng.StorageLogic.offlineByDay(this.offlineTime); }
        /**是今天注册的玩家 */
        get dayNewUser() { return apeng.StorageLogic.dayNewUser(apeng._login.registTime); }
        /**已登录了多少天 */
        get allDayCount() { return this.storage.get("MainModel.allDayCount", 1); }
        onCreate() {
            this.loadingCompleteColor.fromHEX(apeng.initData.loadingCompleteColorAnim);
            // 解析是今天
            let day = apeng.Times.day(apeng.Times.now);
            this._isToDay = this.storage.get("MainModel._isToDay", day) == day;
            this.storage.set("MainModel._isToDay", day);
            this.updateNewDay();
            this.startTime = apeng.Times.second();
            this.offlineTime = apeng._login.storage.get("main-offlineTime", apeng.Times.second());
            this.updateLogicTime();
            this.preLoadQueue = new apeng.Queue(() => {
                console.log("预加载资源完成");
                apeng._resouces.setSfData(0, 2);
            }, .5);
            this.preLoadQueue
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tip, complete))
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tipSystemFont, complete))
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tipClick, complete))
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tipClickSystemFont, complete))
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tipTitleClick, complete))
                .add(complete => apeng._ui.load(apeng._ui.DefaultUrl.tipTitleClickSystemFont, complete))
                .add(complete => apeng._audio.load(apeng.EventHandlerCC.clickSoundUrl, -1, complete));
            if (apeng.initData.sceneChangeWaitUrl)
                this.preLoadQueue.add(complete => apeng._resouces.loadPrefab(apeng.initData.sceneChangeWaitUrl, complete));
            apeng._resouces.addRootBundle("main", "guide", "content");
            this.on(this.EventType.NEW_DAY, () => {
                this.storage.set("MainModel.allDayCount", this.allDayCount + 1);
                // 清除ui数据
                apeng._ui.clearOpenDayCount();
            });
            apeng._scene.once(apeng._scene.EventType.CHANG_SUCCESS, () => {
                apeng._timer.once(this, () => {
                    let lastDay = apeng.Times.day();
                    if (this.storage.get("MainModel.lastDay", -1) != lastDay)
                        this.storage.set("MainModel.lastDay", lastDay);
                    this.preLoadQueue.run();
                }, 1);
            });
            if (!apeng._platform.isIDE)
                apeng._platform._share_.onShareAppMessage(() => this.getShareData());
        }
        onLogic() {
            this.registTouch();
            apeng._guide.once(apeng._guide.EventType.NEW_USER_COMPLETE, () => {
                this.storage.set("MainModel.lastDay", apeng.Times.day());
            });
            apeng._gm
                .addData({
                dec: "清除本地缓存",
                click: () => this.changeOtherAccount()
            })
                .addData({
                dec: "重启游戏",
                click: () => {
                    apeng._platform.instance.reStart();
                }
            });
            // 进入标签时 刷新第二天时间，退出后台时，帧定时器暂停了
            apeng._platform.instance.onShow((obj) => {
                this.updateNewDay();
                // 监听从分享进入
                console.log("进入query", obj);
                this.checkLaunch(obj);
            });
        }
        onComplete() {
            if (!this._isToDay) {
                console.log("----------------是昨天 更新为新的一天");
                this.emit(this.EventType.NEW_DAY);
            }
            // 检测query
            this.checkLaunch();
        }
        changeScene(url, complete, delay = -1) {
            if (apeng._scene.curUrl == url) {
                if (complete)
                    complete();
                return;
            }
            apeng._ui.blockTouchEvent(true);
            let fn = () => {
                apeng._scene.change(url, () => {
                    // 延迟关闭 卡顿
                    apeng._timer.once(this, () => {
                        apeng._ui.blockTouchEvent(false);
                        apeng._ui.Loading.screen(false, this.loadingCompleteColor);
                        apeng._ui.Loading.wait(false, undefined, undefined, apeng.initData.sceneChangeWaitUrl);
                        if (complete)
                            complete();
                    }, .4);
                }, null, { duration: .6, url: apeng.initData.sceneChangeWaitUrl });
            };
            if (delay <= 0)
                fn();
            else {
                // TimesMgr.once 安卓端闪退
                setTimeout(fn, delay * 1000);
            }
        }
        registTouch() {
            let isTouchStart = false;
            let touchMove = (x, y) => {
                let node = apeng.NodeHelper.getChildByCreate(apeng._ui.getLayerParent(apeng.EUILayer.Top, apeng._ui.stageUp), "touchMove", (node) => {
                    if (apeng.initData.touchMovePrefabUrl)
                        apeng._resouces.loadPrefab(apeng.initData.touchMovePrefabUrl, () => {
                            node.addChild(apeng._ui.pool.get(apeng.initData.touchMovePrefabUrl));
                        });
                });
                v2T3.set(x, y);
                apeng.NodeHelper.setPositionXY(node, v2T3, true);
            };
            apeng.EventHandlerCC.touchEvent
                .on(apeng.Input.EventType.TOUCH_START, (e) => {
                apeng.EventHandlerCC.touchIsMove = false;
                isTouchStart = true;
                apeng.EventHandlerCC.touchIsMoveRun = false;
                e.getUILocation(v2T);
                if (!apeng.initData.touchClickPrefabUrl)
                    touchMove(v2T.x, v2T.y);
                this.emit(this.EventType.TOUCH_DOWN);
            })
                .on(apeng.Input.EventType.TOUCH_END, (e) => {
                apeng.EventHandlerCC.touchIsMove = false;
                isTouchStart = false;
                apeng.EventHandlerCC.touchIsMoveRun = false;
                touchMove(-10000, 0);
                e.getUILocation(v2T2);
                this.emit(this.EventType.TOUCH_UP, e);
                if (!apeng.Vector2.equals(v2T, v2T2))
                    return;
                for (let res of this.emit(this.EventType.HAS_PLAY_CLICK_EFFECT, v2T2))
                    if (!res)
                        return;
                if (apeng.initData.touchClickPrefabUrl)
                    apeng._resouces.loadPrefab(apeng.initData.touchClickPrefabUrl, () => {
                        let node = apeng._ui.pool.get(apeng.initData.touchClickPrefabUrl);
                        apeng._ui.getLayerParent(apeng.EUILayer.Top, apeng._ui.stageUp).addChild(node);
                        apeng.NodeHelper.setPositionXY(node, v2T2, true);
                        let fn = () => apeng._ui.pool.put(node);
                        let comp = node.getComponent("DragonBonesCC");
                        if (comp)
                            comp.playDefault(1, fn);
                        else {
                            let comp = node.getComponent("SpineCC");
                            if (comp)
                                comp.playDefault(false, fn);
                            else {
                                let comp = node.getComponent("AnimtorCC");
                                if (comp)
                                    comp.playDefault(fn);
                                else {
                                    let comp = node.getComponent("ParticleSystem2DCC");
                                    if (comp)
                                        comp.play(fn);
                                }
                            }
                        }
                    });
            })
                .on(apeng.Input.EventType.TOUCH_CANCEL, (e) => {
                apeng.EventHandlerCC.touchIsMove = false;
                isTouchStart = false;
                apeng.EventHandlerCC.touchIsMoveRun = false;
                touchMove(-10000, 0);
            })
                .on(apeng.Input.EventType.TOUCH_MOVE, (e) => {
                apeng.EventHandlerCC.touchIsMove = true;
                if (!isTouchStart)
                    return;
                e.getUILocation(v2T3);
                if (!apeng.EventHandlerCC.touchIsMoveRun)
                    if (!apeng.Vector2.equals(v2T, v2T3, 3))
                        apeng.EventHandlerCC.touchIsMoveRun = true;
                touchMove(v2T3.x, v2T3.y);
            });
        }
        checkLaunch(obj) {
            if (!obj)
                obj = apeng._platform.instance.getLaunchOptionsSync();
            console.log("启动参数:", obj);
            if (obj.query)
                if (obj.query.query)
                    this.emit(this.EventType.SHOW_QUERY, obj.query.query);
        }
        showVideo(report, complete, share = false, shareFail) {
            if (apeng.initData.rewardVideoUseShare || share) {
                apeng._platform._share_.show(this.getShareData(), (success) => {
                    if (success) {
                        this.emit(this.EventType.VIDEO_COMPLETE, true);
                        complete();
                    }
                    else {
                        if (apeng._platform.type != apeng.EPlatformType.tt)
                            apeng._ui.tip(apeng._language.get(40005));
                        this.emit(this.EventType.VIDEO_COMPLETE, false);
                        if (shareFail)
                            shareFail();
                    }
                });
            }
            else
                apeng._platform._rewardedVideo_.showByFinish(report, () => {
                    this.emit(this.EventType.VIDEO_COMPLETE, true);
                    complete();
                }, () => {
                    this.emit(this.EventType.VIDEO_COMPLETE, false);
                });
        }
        getShareData() {
            let param = apeng._platform._share_.getData();
            let reportObj = [
                this.showVideoQuery,
                param.imageUrl,
                apeng._platform.config.share.list.title.indexOf(param.title),
            ];
            // 携带query
            param.query = JSON.stringify(reportObj);
            apeng._platform.instance.reportEvent("share", {
                shareid: reportObj[1],
                sharetextid: reportObj[2],
                sharetype: 1,
            });
            return param;
        }
        updateNewDay() {
            let delay = apeng.Times.getToDayLeave() / 1000;
            console.log("距离第二天时间:" + apeng.Times.numHourCountDown(delay * 1000));
            apeng._timer.loop(this, this._updateNewDay, apeng.Times.dayOnce / 1000, -1, delay);
        }
        _updateNewDay() {
            this._isToDay = false;
            this.storage.set("MainModel._isToDay", apeng.Times.day());
            this.emit(this.EventType.NEW_DAY);
            this.storage.delete("MainModel.onlineTimeToDay");
            console.log("新的一天----------------------");
        }
        changeOtherAccount() {
            apeng._ui.Loading.wait(true);
            apeng.StorageMgr.clear();
            apeng._timer.once(this, () => apeng._platform.instance.reStart(), .3);
        }
        updateLogicTime() {
            let now = apeng.Times.second();
            let sub = now - this.lastOnlineTimeAdd;
            if (sub < 0)
                return;
            // 每秒存一下离线时间
            apeng._login.storage.set("main-offlineTime", now, false);
            // 已在线时长 
            this.storage.set("MainModel.onlineTime", this.storage.get("MainModel.onlineTime", 0) + sub, false);
            // 当天已在线时长
            this.storage.set("MainModel.onlineTimeToDay", this.storage.get("MainModel.onlineTimeToDay", 0) + sub, false);
            this.lastOnlineTimeAdd = now;
            // 间隔一定时间更新一次 防止服务端推送频繁
            apeng._timer.once(this, this.updateLogicTime, this.loopIntervalServer);
        }
        /**是新的一天 获取一次后 就不是新的一天了*/
        getNewDay(key) {
            let day = apeng.Times.Date.getDate();
            let cacheDay = this.storage.get("MainModel.newDay." + key, day);
            if (cacheDay == day)
                return false;
            this.storage.set("MainModel.newDay." + key, day);
            return true;
        }
        converBillToGold(count) {
            return Math.floor(count * 100);
        }
        /**获取用不重复的id id 从 1开始 */
        getAddId(key) {
            let index = this.storage.get(key, 0);
            index++;
            this.storage.set(key, index);
            return index;
        }
    };
    MainModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.main)
    ], MainModule);
    apeng.MainModule = MainModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />
/// <reference path="./../utils/Sets.ts" />

(function (apeng) {
    /**平台管理模块 */
    let PlatformModule = class PlatformModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                INIT: "INIT",
                /**从后台进入前台 */
                ON_SHOW: "ON_SHOW",
                /**从前台进入后台 */
                ON_HIDE: "ON_HIDE",
            };
            this.openWebSimulationUI = false;
            this.systemInfo = null;
            this.instance = null;
            this.config = null;
            this.type = null;
            this.initTime = -1;
            this.isInit = false;
            this.OpenDataContext = null;
            this._banner_ = null;
            this._blockOnce_ = null;
            this._interstitial_ = null;
            this._nativeTemp_ = null;
            this._record_ = null;
            this._rewardedVideo_ = null;
            this._share_ = null;
            this._vibrate_ = null;
            this._dayAdCount = { day: -1, count: 0 };
            this._bannerOrNativeTempType = apeng.EBottomAdType.None;
            this._blockOnceType = apeng.EBlockOnceAdType.None;
            this._settingData = null;
        }
        get _web() { return this.instance; }
        get _wx() { return this.instance; }
        get _qq() { return this.instance; }
        get _tt() { return this.instance; }
        get _vivo() { return this.instance; }
        get _oppo() { return this.instance; }
        get _hbs() { return this.instance; }
        get _xiaomi() { return this.instance; }
        get _overseas_android_xgame() { return this.instance; }
        get _a360() { return this.instance; }
        get _overseas_kwai() { return this.instance; }
        get _overseas_weiyou() { return this.instance; }
        get _ks() { return this.instance; }
        get _ios() { return this.instance; }
        /**网络在线 */
        get isNetWork() {
            let onLine = navigator.onLine;
            if (apeng.sys.isNative)
                onLine = apeng.sys.getNetworkType() != apeng.sys.NetworkType.NONE;
            return onLine;
        }
        /**是苹果机 */
        get isIOS() {
            return this.systemInfo.model.indexOf("hone") != -1;
        }
        /**是开发者工具 */
        get isIDE() {
            return this.systemInfo.brand.indexOf("devtools") != -1;
        }
        /**是长屏手机 */
        get isLongScreen() {
            let system = this.systemInfo;
            return system.screenHeight / system.screenWidth > 1.94;
        }
        get isNative() {
            return apeng.sys.isNative;
        }
        /**是海外版本 */
        get isOverseas() {
            return this.type == apeng.EPlatformType.overseas_weiyou
                || this.type == apeng.EPlatformType.ios
                || this.type == apeng.EPlatformType.web
                || this.type == apeng.EPlatformType.overseas_android_xgame;
        }
        onInstance() {
            this.type = apeng.EPlatformType[apeng.initData.platformType];
            this.openWebSimulationUI = this.type == apeng.EPlatformType.web && apeng.initData.openWebSimulationUI;
            this.isInit = true;
            this.initTime = apeng.Times.second();
            this.instance = apeng.platformMgr.instanceOnce(this.type);
        }
        init(complete) {
            let key = apeng.initData.configPlatform;
            if (!key)
                key = "platform";
            let config = apeng._config_.obj[key][this.type];
            this.config = {
                gameName: apeng.initData.gameName,
                appid: config.appid,
                startBlockAd: apeng.initData.startBlockAd,
                share: apeng.initData.share,
                blockOnce: {
                    id: config.blockOnce,
                    refreshInterval: 2 * 60,
                    idUpdate: config.blockOnce,
                },
                banner: {
                    id: config.banner,
                    // idUpdate: config.bannerUpdate,
                    refreshInterval: (this.type == apeng.EPlatformType.qq ? 1 : 5) * 60,
                    sizeRatio: 1,
                    active: true,
                },
                interstitial: {
                    id: (() => {
                        let ids = config.interstitial;
                        if (!Array.isArray(ids))
                            ids = [ids];
                        return ids;
                    })(),
                    coolingTime: 0
                },
                nativeTemp: {
                    id: config.nativeTemp,
                    idRoot: config.nativeTempRoot,
                    refreshInterval: 5 * 60,
                },
                rewardedVideo: {
                    id: config.rewardedVideo,
                    idOnce: config.rewardedVideoOnce,
                    showMaxCount: 999999,
                    isSuccess: false
                },
            };
            // 避免未配置 导致web弹窗未调起
            if (this.openWebSimulationUI) {
                this.config.banner.id = "webTest";
                this.config.banner.idUpdate = "webTest";
                this.config.blockOnce.id = "webTest";
                this.config.blockOnce.idUpdate = "webTest";
                this.config.interstitial.id = ["webTest"];
                this.config.nativeTemp.id = "webTest";
                this.config.nativeTemp.idRoot = "webTest";
                this.config.rewardedVideo.id = "webTest";
                this.config.rewardedVideo.idOnce = "webTest";
            }
            let dir = new apeng.LoadDir(3, complete);
            apeng.platformMgr.run(dir.subCount());
            this.OpenDataContext = this.instance.IOpenDataContext();
            // 注册接收原生平台接口
            if (this.isNative) {
                console.log("注册原生端接收消息接口");
                window["__onNative_"] = (value) => {
                    console.log("接收到原生端消息:", value);
                    let obj = JSON.parse(value);
                    this.emit(obj.eventType, obj.arg);
                };
            }
            this.instance.onShow(() => {
                console.log("后台进入前台");
                this.emit(this.EventType.ON_SHOW);
            });
            this.instance.onHide(() => {
                console.log("前台进入后台");
                this.emit(this.EventType.ON_HIDE);
            });
            this.systemInfo = this.instance.getSystemInfoSync();
            this.getSetting(dir.subCount());
            apeng.platformLogicMgr.instance(true);
            this._banner_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.banner);
            this._blockOnce_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.blockOnce);
            this._interstitial_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.interstitial);
            this._nativeTemp_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.nativeTemp);
            this._record_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.record);
            this._rewardedVideo_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.rewardedVideo);
            this._share_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.share);
            this._vibrate_ = apeng.platformLogicMgr.get(apeng.EPlatformLogicType.vibrate);
            this._banner_.isSimulate = apeng.initData.useWebSimulationUI;
            this._interstitial_.isSimulate = apeng.initData.useWebSimulationUI;
            this._nativeTemp_.isSimulate = apeng.initData.useWebSimulationUI;
            this._record_.isSimulate = apeng.initData.useWebSimulationUI;
            this._rewardedVideo_.isSimulate = apeng.initData.useWebSimulationUI;
            this._share_.isSimulate = apeng.initData.useWebSimulationUI;
            apeng.platformLogicMgr.run(dir.subCount(), apeng.EPlatformLogicType);
        }
        /**
         * 发送消息到原生平台
         * @param arg1
         * @param arg2
         */
        sendToNative(eventType, arg1 = "") {
            // if (!window["native" as any])
            if (!apeng.sys.isNative)
                return "";
            if (apeng.sys.platform == apeng.sys.Platform.ANDROID)
                return apeng.native.reflection.callStaticMethod("com/cocos/game/Main", "onScript", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", eventType, arg1);
            else if (apeng.sys.platform == apeng.sys.Platform.IOS)
                return apeng.native.reflection.callStaticMethod("UtilsHelper", "onScript", eventType, arg1);
            else
                return "";
        }
        /**获取每天播放广告的次数 */
        getDayAd(key) {
            key = key + "_count";
            let value = this.storage.get(key, this._dayAdCount);
            let curDay = apeng.Times.Date.getDay();
            if (value.day != curDay) {
                value.day = curDay;
                value.count = 0;
                this.storage.set(key, value);
            }
            return value;
        }
        addDayAdCount(key) {
            let value = this.getDayAd(key);
            value.count++;
            key = key + "_count";
            this.storage.set(key, value);
        }
        /**展示广告 */
        hasOpenAd() {
            if (this.config.startBlockAd == 0)
                return true;
            return this.initTime + this.config.startBlockAd < apeng.Times.second();
        }
        setKeepScreenOn() {
            if (!this.instance.root)
                return;
            if (this.instance.root.setKeepScreenOn)
                this.instance.root.setKeepScreenOn({
                    keepScreenOn: true
                });
        }
        setEnableDebug(enableDebug) {
            if (!this.instance.root)
                return;
            if (this.instance.root.setEnableDebug)
                this.instance.root.setEnableDebug({
                    enableDebug
                });
        }
        bannerOrNativeTemp(type) {
            this._bannerOrNativeTempType = type;
            if (!this.isInit)
                return;
            // 广告 1004后 改成 原生
            if (this.type == apeng.EPlatformType.qq)
                if (this._banner_.errHide) {
                    if (this._bannerOrNativeTempType == apeng.EBottomAdType.Banner) {
                        this._bannerOrNativeTempType = apeng.EBottomAdType.Native;
                    }
                }
            this._bannerOrNativeTemp(() => {
                apeng._timer.once(this, this._bannerOrNativeTemp, .5);
            });
        }
        _bannerOrNativeTemp(delay) {
            switch (this._bannerOrNativeTempType) {
                case apeng.EBottomAdType.None:
                    this._nativeTemp_.hide(delay);
                    this._banner_.hide(delay);
                    break;
                case apeng.EBottomAdType.Banner:
                    this._nativeTemp_.hide(delay);
                    this._banner_.show(delay);
                    break;
                case apeng.EBottomAdType.Native:
                    this._nativeTemp_.show(delay);
                    this._banner_.hide(delay);
                    break;
            }
        }
        blockOnce(type) {
            this._blockOnceType = type;
            if (!this.isInit)
                return;
            this.__blockOnce(() => {
                apeng._timer.once(this, this.__blockOnce, .5);
            });
        }
        __blockOnce(delay) {
            switch (this._blockOnceType) {
                case apeng.EBlockOnceAdType.None:
                    this._blockOnce_.hide(delay);
                    break;
                case apeng.EBlockOnceAdType.Show:
                    this._blockOnce_.show(delay);
                    break;
            }
        }
        getSetting(cb, cache = true) {
            if (cache && this._settingData)
                cb(this._settingData);
            else {
                this.instance.getSetting((res) => {
                    this._settingData = res;
                    cb(res);
                });
            }
        }
    };
    PlatformModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.platform)
    ], PlatformModule);
    apeng.PlatformModule = PlatformModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let PrivacyModule = class PrivacyModule extends apeng.BaseModule {
        show(openComplete, complete) {
            if (!apeng.initData.openPrivacy) {
                openComplete();
                complete();
                return;
            }
            // 要弹出
            if (apeng.StorageOnceMgr.get("PrivacyModule.success", "false") == "false") {
                apeng._ui.open("main/prefab/privacy/PrivacyUI", () => {
                    apeng.StorageOnceMgr.set("PrivacyModule.success", "true", false);
                    // 通知原生端 初始化sdk
                    apeng._platform.instance.privacyConfirm(complete);
                }, openComplete, null, false);
            }
            else {
                openComplete();
                apeng._platform.instance.privacyConfirm(complete);
                // complete()
            }
        }
        openDecUI() {
            apeng._ui.open("privacy/prefab/PrivacyDecUI", {
                path: "ad/dec/",
                count: 7,
                gameName: apeng.initData.gameName + "隐私政策",
            });
        }
        openUserUI() {
            apeng._ui.open("privacy/prefab/PrivacyDecUI", {
                path: "ad/user/",
                count: 9,
                gameName: apeng.initData.gameName + "用户协议",
            });
        }
    };
    PrivacyModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.privacy)
    ], PrivacyModule);
    apeng.PrivacyModule = PrivacyModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let PropModule = class PropModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.numRollAnimParam = "show";
            this.EventType = {
                /**飞行特效完成时 */
                FLY_TIP_COMPLETE: "FLY_TIP_COMPLETE",
                /**道具数量改变时 configName id count */
                CHANGE: "CHANGE",
                PROP_CHANGE: "PROP_CHANGE",
                PROP_SUB: "PROP_SUB",
            };
            this.propUseCount = {};
            /**所有单个道具值 */
            this.singles = null;
            /**多道具值 */
            this.plurals = {};
            /**多皮肤值 */
            this.skins = {};
            /**道具的世界坐标 做道具飞行 */
            this.singlesByUIWorldPosition = {};
            this.singlesOpenUIData = {};
        }
        onCreate() {
            // 创建多道具
            this.singles = this.create(this.storage, "prop");
        }
        onLogic() {
            // 添加离线道具收益
            for (let config of apeng._config_.arr.prop)
                this.singles.get(config.id).autoResumeByOffline();
            // 激活自动恢复
            for (let config of apeng._config_.arr.prop)
                this.singles.get(config.id).openAutoResume();
            apeng._main.on(apeng._main.EventType.NEW_DAY, () => {
                this.storage.delete("PropModel.toDayVideoMaxCount");
                /**每天重置上限 */
                apeng.Maps.forEach(apeng._config_.obj.prop, (config) => {
                    if (config.is_refull == 1) {
                        let data = this.singles.get(config.id);
                        if (config.max_count != -1)
                            if (data.cur < config.max_count)
                                data.add(config.max_count - data.cur, true);
                    }
                });
                this.storage.delete("propShareToDay");
            }, this);
        }
        flyTipByProp(config, startWorldPosition, itemCount) {
            apeng._ui.flyTip(startWorldPosition, apeng._prop.singlesByUIWorldPosition[config.id], config.icon_url, itemCount, () => {
                this.emit(this.EventType.FLY_TIP_COMPLETE, config.id);
            });
        }
        /**创建多道具管理 */
        create(storage, configName, render) {
            let config = apeng._config_.obj[configName];
            let props = new apeng.PropsHelper(storage, configName, (id) => {
            }, config, (id) => config[id].default_count || 0, (id) => config[id].max_count, (id) => true, (id) => config[id].auto_resume && config[id].auto_resume[0] != -1, (id) => config[id].auto_resume && config[id].auto_resume[0] * 60, (id) => config[id].auto_resume && config[id].auto_resume[1], (id) => config[id].auto_resume && config[id].auto_resume[2] != 0, (id, count, isAutoResume, isNew) => {
                if (!isAutoResume) {
                    if (config[id].is_fly == 1)
                        this.flyTipByProp(config[id], apeng.winCenterPostion());
                }
            }, (id, count) => this.emit(this.EventType.CHANGE, configName, id, count));
            this.plurals[configName] = props;
            return props;
        }
        setSinglesOpenUI(id, fn) {
            this.singlesOpenUIData[id] = fn;
            return this;
        }
        /**
         * 打开获取道具弹窗
         * @param id
         */
        openGetUI(prop) {
            let id = prop.id;
            if (this.singlesOpenUIData[id]) {
                this.singlesOpenUIData[id]();
                return;
            }
            let config = apeng._config_.obj.prop[id];
        }
        /**创建皮肤管理 */
        createSkin(storage, configName, defaultID, addItemRender) {
            let skin = new apeng.SkinHelper(storage, configName, defaultID);
            // 恭喜获得弹窗
            if (addItemRender)
                skin.on(apeng.SkinHelper.EventType.UNLOCK, (id) => {
                });
            skin.on(apeng.SkinHelper.EventType.CHANGE, () => {
                // AudioMgr.play("content/audio/replace_sound")
            });
            this.skins[configName] = skin;
            return skin;
        }
        addPropBuyShare(id) {
            let obj = this.storage.get("propShareToDay", {});
            obj[id] = "true";
            this.storage.set("propShareToDay", obj);
        }
        /**可打开的ui */
        hasOpenUI(prop) {
            let id = prop.id;
            if (this.singlesOpenUIData[id])
                return true;
            return false;
        }
        addProp(id) {
            this.addPropBuyShare(id);
            let config = apeng._config_.obj.prop[id];
            apeng._prop.singles.get(id).add(config.video_add_count);
            if (config.is_video_add_use === 1)
                this.useProp(id);
            else
                this.emit(this.EventType.PROP_CHANGE);
        }
        hasUseProp(id) {
            return this.storage.get("useProp" + id, "false") != "false";
        }
        resetProp() {
            for (let config of apeng._config_.arr.prop)
                this.propUseCount[config.id] = 0;
        }
        hasToDayMax(id) {
            return this.propUseCount[id] >= apeng._config_.obj.prop[id].today_max;
        }
        useProp(id) {
            apeng._prop.singles.get(id).sub(1);
            this.storage.set("useProp" + id, "true");
            this.propUseCount[id]++;
            this.emit(this.EventType.PROP_CHANGE);
            this.emit(this.EventType.PROP_SUB, id);
        }
    };
    PropModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.prop)
    ], PropModule);
    apeng.PropModule = PropModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let RankModule = class RankModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                CHANGE_PRIOVINCE: "CHANGE_PRIOVINCE",
                UPDATE_PROVINCE: "UPDATE_PROVINCE",
            };
            this.provinceConfigs = [];
            this.provinceAllData = [];
            this.randomSeed = new apeng.RandomSeed();
        }
        get curProvinceIndex() { return this.storage.get("priovinceIndex", 0); }
        get curFakeData() { return this.storage.get("curFakeData", null); }
        onCreate() {
            if (!this.curFakeData)
                this.updateFakeData();
            let curFakeData = this.curFakeData;
            for (let i = 0; i < apeng._config_.arr.province_item.length; i++) {
                let config = apeng._config_.arr.province_item[i];
                let fakeCount = curFakeData[i] || 0;
                this.provinceAllData[i] = { index: i, count: fakeCount };
                if (i != 0)
                    this.provinceConfigs.push(config);
            }
            apeng.Sets.sortMax(this.provinceAllData, v => v.count * 100 - (v.index == 0 ? 50 : v.index));
            // 无网环境下 使用上次的数据
            let provinceAllData = this.storage.get("rank.provinceAllData", "");
            if (provinceAllData)
                this.parseProvinceAll(provinceAllData);
            // this.parseProvinceAll(JSON.stringify(_config_.Array.province_item.map(v => 100)))
            apeng._ui.on(apeng._ui.EventType.OPEN_BEFORE, (url) => {
                if (url == "rank/prefab/RankUI"
                    || url == apeng.initData.uiUrl.index) {
                    // this.provinceAll()
                }
            });
        }
        onLogic() {
            apeng._main.on(apeng._main.EventType.NEW_DAY, () => {
                this.updateFakeData();
            });
        }
        getProvineData() {
            let datas = [];
            let selfRank = -1;
            let i = -1;
            for (let data of apeng._rank.provinceAllData) {
                i++;
                if (apeng._rank.curProvinceIndex == data.index)
                    selfRank = i;
                if (data.count > 0)
                    datas.push(data);
            }
            return { datas, selfRank };
        }
        updateFakeData() {
            let day = apeng.Times.day();
            let datas = {};
            for (let i = 0; i < apeng._config_.arr.province_item.length; i++) {
                let config = apeng._config_.arr.province_item[i];
                this.randomSeed.init(day + config.id);
                datas[i] = apeng.Maths.minToMax(config.fakemin || 0, config.fakemax || 0, true, this.randomSeed.run());
            }
            this.storage.set("curFakeData", datas);
        }
        parseProvinceAll(data) {
            let arr = JSON.parse(data);
            let curFakeData = this.curFakeData;
            for (let i = 0; i < apeng._config_.arr.province_item.length; i++) {
                let count = arr[i] || 0;
                let fakeCount = curFakeData[i] || 0;
                apeng.Sets.filterValue(this.provinceAllData, v => v.index == i).count = count + fakeCount;
            }
            apeng.Sets.sortMax(this.provinceAllData, v => v.count * 100 - (v.index == 0 ? 50 : v.index));
        }
        changePriovinceIndex(index) {
            apeng._login.storage.set("priovinceIndex", index, false);
            this.emit(this.EventType.CHANGE_PRIOVINCE);
        }
    };
    RankModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.rank)
    ], RankModule);
    apeng.RankModule = RankModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    let ResoucesModule = class ResoucesModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**包加载完成 包名 */
                BUNDLE_LOAD_COMPLETE: "BUNDLE_LOAD_COMPLETE",
                /**释放所有包时 */
                RELEASE_ALL: "RELEASE_ALL",
                /** setSpriteFrame 接口的 url加载完毕时 */
                SPRITEFRAME_COMPLETE: "SPRITEFRAME_COMPLETE",
            };
            /**加载过的所有资源 */
            this.loadMap = new Map();
            this.loadDirUrls = [];
            this.bundles = new apeng.Maps();
            this._rootBundle = new apeng.Sets();
            this.sfQueue = new apeng.Queue(() => {
                this.sfQueue.clear();
            }, 1);
            this.sfRunCount = 1;
            this._loadPrefab = { url: "", type: apeng.Prefab };
            this._loadSpriteFrame = { url: "", type: apeng.SpriteFrame };
            this.defaultSpriteFrameUrl = "main/texture/ui/preload/default_sprite_splash";
        }
        onInstance() {
            this.setSfData(-1, 100);
        }
        /**
         * 添加常驻包 切换场景不释放
         * @param bundleName
         */
        addRootBundle(...bundleName) {
            this._rootBundle.add(...bundleName);
        }
        /**加载预制体，调用load */
        loadPrefab(url, cb, progress, isCache = true) {
            this._loadPrefab.url = url;
            this.load(this._loadPrefab, cb, progress, isCache);
        }
        /**加载图片，调用load */
        loadSpriteFrame(url, cb, progress, isCache = true) {
            this._loadSpriteFrame.url = url;
            this.load(this._loadSpriteFrame, cb, progress, isCache);
        }
        /**
         * 加载本地资源 main/prefab/123
         * 暂不支持加载网络资源
         * @param url
         * @param type
         * @param cb
         * @param progress
         * @param isCache
         * @returns
         */
        load(_url, cb, progress, isCache = true) {
            let url = "", type = apeng.Asset;
            if (typeof _url == "string")
                url = _url;
            else {
                url = _url.url;
                type = _url.type;
            }
            if (!url) {
                if (progress)
                    progress(1);
                if (cb)
                    cb(null);
                return;
            }
            let cache = this.get(url);
            if (cache) {
                if (type && cache instanceof type) {
                    if (progress)
                        progress(1);
                    if (cb)
                        cb(cache);
                    return;
                }
            }
            let onProgress = null;
            if (progress)
                onProgress = (completedCount, totalCount) => {
                    progress(apeng.Maths.clamp01(completedCount / totalCount));
                };
            let complete = (err, asset) => {
                if (err) {
                    console.warn("error load resouces: " + url + ", check url", err);
                    if (progress)
                        progress(1);
                    if (cb)
                        cb(null);
                    return;
                }
                // 存入本地数据中
                if (isCache)
                    this.loadMap.set(url, asset);
                // console.log("complete load resouces: " + url)
                if (progress)
                    progress(1);
                if (cb)
                    cb(asset);
            };
            // 加载网络资源
            if (url.indexOf("http") != -1) {
                // if (Strings.lastIndexOf(url, ".png") == -1 && Strings.lastIndexOf(url, ".jpg") == -1) {
                // 	if (PlatformMgr.type == EPlatformType.OPPO)
                // 		url += ".png"
                // 	else
                // 		url += ".jpg"
                // }
                // url += ".png"
                let index = url.lastIndexOf(".");
                let ext = url.substring(index);
                console.log("load network resouces: ", url, ext);
                // 图片设置为 jpg 不然下不下来
                // if (PlatformMgr.type == EPlatformType.VIVO && ext == ".jpg")
                //     assetManager.downloader.downloadDomImage(url.substring(0, index), { ext: ".jpg" }, (this.onLoaded as any).bind(this, url, cb, isCache) as any)
                // else
                //     assetManager.loadRemote(url, (this.onLoaded as any).bind(this, url, cb, isCache) as any)
                // if (url.lastIndexOf(".png") != -1)
                // 	assetManager.loadRemote(url, complete)
                // else
                apeng.assetManager.loadRemote(url, { ext: ".png" }, complete);
            }
            else
                this.loadBundle(url, (bundle, path) => {
                    // console.log("enter load resouces: " + url)
                    // 加载图片需要添加后缀
                    if (type == apeng.SpriteFrame) {
                        let sfName = "/spriteFrame";
                        if (path.indexOf(sfName) == -1)
                            path += sfName;
                    }
                    if (!bundle) {
                        if (progress)
                            progress(1);
                        if (cb)
                            cb(null);
                    }
                    else
                        bundle.load(path, type, onProgress, complete);
                });
        }
        loadBundles(bundleNames, cb) {
            let dir = new apeng.LoadDir(bundleNames.length, cb);
            for (let bundleName of bundleNames)
                this.loadBundle("", dir.subCount(), bundleName);
        }
        /**
         * 加载一个包
         * @param url
         * @param cb
         */
        loadBundle(url, cb, bundleName) {
            let path = "";
            if (!bundleName) {
                bundleName = this.getUrlByBoundleName(url);
                path = this.getUrlByBoundlePath(url);
            }
            let bundle = this.getBundle(bundleName);
            if (bundle) {
                if (cb)
                    cb(bundle.bundle, path);
            }
            else {
                // console.log("enter load bundle: ", bundleName)
                apeng.assetManager.loadBundle(bundleName, (err, _bundle) => {
                    bundle = this.getBundle(bundleName);
                    if (bundle === undefined) {
                        console.warn("load bundle error:" + bundleName + ", check bundle", err);
                        return;
                    }
                    // 有依赖包
                    else if (bundle === null) {
                        let dep = apeng.assetManager.getBundle(bundleName).deps;
                        // console.log("当前包有依赖包，开始加载依赖包" + bundleName + "，依赖包:" + dep.toString())
                        let queue = new apeng.Queue(() => {
                            // console.log("依赖包加载完成" + bundleName)
                            this.loadBundle(url, cb);
                        });
                        apeng.Sets.forEach(dep, depName => {
                            queue.add((complete) => {
                                this.loadBundle(depName, complete);
                            });
                        }, true);
                        queue.run();
                        return;
                    }
                    // console.log("complete load bundle: ", bundleName)
                    if (cb)
                        cb(bundle.bundle, path);
                    this.emit(this.EventType.BUNDLE_LOAD_COMPLETE, bundleName);
                });
            }
        }
        getBundle(bundleName) {
            bundleName = this.getUrlByBoundleName(bundleName);
            let bundle = this.bundles.get(bundleName);
            if (!bundle) {
                let _bundle = apeng.assetManager.getBundle(bundleName);
                if (_bundle) {
                    for (let depName of _bundle.deps)
                        if (!apeng.assetManager.getBundle(depName))
                            return null;
                }
                else
                    return undefined;
                bundle = {
                    bundle: _bundle,
                    parent: [],
                    children: [],
                };
                this.bundles.set(bundleName, bundle);
                // 更新bundle引用
                bundle.parent.push(..._bundle.deps);
                for (let depName of _bundle.deps) {
                    let depBundle = this.getBundle(depName);
                    depBundle.children.push(bundleName);
                }
            }
            return bundle;
        }
        /**
         * 释放所有包
         * @param exclude 排除
         */
        releaseAllBundle(...exclude) {
            // 本地测试 浏览器不释放
            if (this.bundles.get("main2").children.length == 0)
                return;
            let release = new apeng.Sets();
            this.bundles.forEach((v, k) => {
                release.add(this.getUrlByBoundleName(k));
                release.add(...v.children);
            });
            for (let value of exclude) {
                let bundle = this.getBundle(value);
                if (bundle)
                    for (let _value of bundle.parent)
                        release.delete(_value);
                release.delete(this.getUrlByBoundleName(value));
            }
            this._rootBundle.forEach(value => {
                release.delete(this.getUrlByBoundleName(value));
            });
            release.forEach(v => {
                let bundle = this.getBundle(v);
                // if(bundle.bundle.)
                // bundle.bundle.releaseUnusedAssets()
            });
            // console.log("释放所有资源完毕" + release.toString())
            this.emit(this.EventType.RELEASE_ALL);
        }
        /**
         * 获取加载后的回调
         * @param url
         */
        get(_url, type = null) {
            let url = "";
            if (typeof _url == "string")
                url = _url;
            else {
                url = _url.url;
                type = _url.type;
            }
            if (!url)
                return null;
            let value = this.loadMap.get(url);
            if (value && !apeng.isValid(value, true)) {
                value = null;
                this.loadMap.delete(url);
            }
            let isBundle = !value;
            // 类型不一致 
            if (type && value) {
                if (!(value instanceof type)) {
                    // 网络图片
                    if (url.indexOf("http") != -1) {
                        if (type == apeng.SpriteFrame) {
                            value = apeng.SpriteFrame.createWithImage(value);
                            this.loadMap.set(url, value);
                        }
                    }
                    else
                        isBundle = true;
                }
            }
            if (isBundle) {
                let bundle = this.getBundle(this.getUrlByBoundleName(url));
                if (bundle) {
                    if (type && type == apeng.SpriteFrame) {
                        let url2 = url;
                        let sfName = "/spriteFrame";
                        if (url2.indexOf(sfName) == -1)
                            url2 += sfName;
                        value = bundle.bundle.get(this.getUrlByBoundlePath(url2), type);
                    }
                    else
                        value = bundle.bundle.get(this.getUrlByBoundlePath(url), type);
                    if (value)
                        this.loadMap.set(url, value);
                }
            }
            return value;
        }
        /**
         * 释放资源 不会导致正在使用的出错
         * @param {string} path
         */
        release(url, assetType) {
            let boundle = this.getBundle(this.getUrlByBoundleName(url));
            // if (boundle)
            // 	boundle.bundle.release(this.getUrlByBoundlePath(url), assetType) as any
            // this.loadMap.delete(url)
        }
        /**通过路径获取包名 */
        getUrlByBoundleName(url) {
            let index = url.indexOf("/");
            if (index != -1)
                url = url.substring(0, index);
            if (url == "main")
                url = "main2";
            return url;
        }
        /**通过路径获取包下面的路径 */
        getUrlByBoundlePath(url) {
            return url.substring(url.indexOf("/") + 1);
        }
        /**
         * 批量加载资源
         * @param urls
         * @param cb
         * @param onProgress 加载进度 0~1
         * @param isCache
         */
        loadDir(urls, cb, onProgress, isCache = true) {
            let l = urls.length;
            if (l == 0) {
                if (cb)
                    cb();
                return;
            }
            // 使用数组缓存 方便调试
            // let deepUrls = JS.minxi(urls)
            // this.loadDirUrls.push(deepUrls)
            // 加载计数
            let loadDir = new apeng.LoadDir(urls.length, () => {
                // Sets.delete(this.loadDirUrls, deepUrls)
                if (cb)
                    cb();
            }, (data) => {
                // Sets.delete(deepUrls, data)
                // console.log("batch load resouces count:", deepUrls.length)
            });
            let progressDir = null;
            // 全部进度整合为0~1 
            if (onProgress)
                progressDir = new apeng.ProgressDir(onProgress);
            for (let value of urls) {
                let url = value;
                if (typeof value == "object")
                    url = value.url;
                this.load(value, loadDir.subCount(url), progressDir ? progressDir.progress(url) : null, isCache);
            }
        }
        setSfData(interval, runCount) {
            this.sfRunCount = runCount;
            this.sfQueue.interval = interval;
        }
        /**
          * 设置精灵组件上的异步图片
          * 网络图片
          * @param sprite
          * @param url
          */
        setSpriteFrame(sprite, url, cb, enterLoadQueue = false) {
            let sf = this.get(url, apeng.SpriteFrame);
            if (!sf) {
                // let load = (complete?: () => void) => {
                this.loadSpriteFrame(url, (res) => {
                    if (sprite.enabledInHierarchy && res) {
                        sprite.spriteFrame = sf = this.get(url, apeng.SpriteFrame);
                        if (cb)
                            cb(sf);
                    }
                    // 节点已销毁 或未显示
                    else {
                        if (cb)
                            if (apeng.isValid(sprite) && apeng.isValid(sprite.node) && sprite)
                                cb(res);
                            else
                                cb(null);
                    }
                    this.emit(this.EventType.SPRITEFRAME_COMPLETE, url);
                    // if (complete)
                    // 	complete()
                });
                // }
                // if (enterLoadQueue) {
                // 	// 设置加载队列 防止爆发式进入
                // 	let fn = (complete: () => void) => { load(complete) }
                // 	this.sfQueue.add(fn, true)
                // 	if (!this.sfQueue.isRun)
                // 		this.sfQueue.run(this.sfRunCount)
                // 	return fn
                // }
                // else {
                // 	load()
                // 	return undefined!
                // }
            }
            sprite.spriteFrame = sf;
            if (cb)
                cb(sf);
            return undefined;
        }
        /**取消正在加载的队列 */
        cancleSpriteFrame(complete) {
            if (complete)
                this.sfQueue.remove2(complete);
        }
        /**
         * 通过uuid获取文件相对于 asset下的路径
         * 需 bundle提前加载好
         * @param uuid
         * @returns
         */
        getUuidByUrl(uuid) {
            for (let bundleName in apeng.assetManager.bundles["_map"]) {
                let bundle = apeng.assetManager.bundles.get(bundleName);
                let info = bundle.config.assetInfos.get(uuid);
                if (info && info["path"])
                    return bundleName + "/" + info.path;
            }
            return "";
        }
        getCacheAllUrls() {
            let values = [];
            apeng.assetManager.assets.forEach((v, k) => {
                values.push(this.getUuidByUrl(k));
            });
            return values;
        }
        getDefaultSpriteFrame() {
            return this.get(this.defaultSpriteFrameUrl, apeng.SpriteFrame);
        }
        loadDefaultSpriteFrame(complete) {
            this.loadSpriteFrame(this.defaultSpriteFrameUrl, complete);
        }
    };
    ResoucesModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.resouces)
    ], ResoucesModule);
    apeng.ResoucesModule = ResoucesModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />
/// <reference path="./../utils/Sets.ts" />

(function (apeng) {
    let SceneModule = class SceneModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                /**场景切换成功时 */
                CHANG_SUCCESS: "CHANG_SUCCESS",
                /**场景切换开始时 进入 change接口 */
                CHANG_START: "CHANG_START",
            };
            this.cur = null;
            this.lastUrl = "";
            this.curUrl = "";
            this.preLoadUrls = {};
            this.preLoadBundles = {};
            this.preLoads = {};
            /**真正场景正在切换中 */
            this.isChange = false;
            /**包含预加载资源的 正在切换中 */
            this.isProChange = false;
        }
        get enterCount() { return this.storage.get("enterCount", {}); }
        /**切换场景的总次数 */
        get enterCountAll() { return this.storage.get("enterCountAll", 0); }
        onInstance() {
            apeng._ui.on(apeng._ui.EventType.HAS_CLOSE_SCENE_ALL, () => {
                if (this.isProChange)
                    return false;
                return true;
            });
            // 切换场景成功后 检测一下
            this.on(this.EventType.CHANG_SUCCESS, () => apeng._timer.once(apeng._ui, apeng._ui.checkSceneOpenUI, .2));
        }
        getEnterCount(sceneUrl) { return this.enterCount[sceneUrl] || 0; }
        setEnterCount(sceneUrl, count) {
            let value = this.enterCount;
            if (value[sceneUrl] == undefined)
                value[sceneUrl] = 0;
            value[sceneUrl] += count;
            this.storage.set("enterCount", value);
            this.storage.set("enterCountAll", this.enterCountAll + 1);
        }
        /**
         * 设置加载场景时
         * 需要预先加载的资源
         * @param sceneUrl
         * @param urls
         */
        setPreLoadUrls(sceneUrl, urls) {
            this.preLoadUrls[sceneUrl] = urls;
            return this;
        }
        /**
     * 设置加载场景时
     * 需要预先加载的额外包
     * @param sceneUrl
     * @param urls
     */
        setPreLoadBundles(sceneUrl, urls) {
            this.preLoadBundles[sceneUrl] = urls;
            return this;
        }
        setPreLoad(url, cb) {
            if (!this.preLoads[url])
                this.preLoads[url] = new apeng.Queue();
            this.preLoads[url].add(cb);
            return this;
        }
        /**
         * 预加载场景
         * @param sceneUrl 场景路径
         * @param cb
         * @param progress
         * @param openLoadingUI
         */
        preLoad(sceneUrl, cb, progress, proLoadScene = true) {
            let progressDir = null;
            // 全部进度整合为0~1 
            if (progress)
                progressDir = new apeng.ProgressDir(progress);
            let path = null;
            let bundle = null;
            let loadDir = new apeng.LoadDir(2, () => {
                if (cb)
                    cb(bundle, path);
            });
            let boundCallBack = () => {
                // 预加载资源
                let preLoad = this.preLoadUrls[sceneUrl];
                if (preLoad)
                    apeng._resouces.loadDir(preLoad(), loadDir.subCount(), progressDir ? progressDir.progress("preLoad") : null, true);
                else
                    loadDir.subCount()();
                // 加载场景
                if (!proLoadScene)
                    loadDir.subCount()();
                else
                    apeng._resouces.loadBundle(sceneUrl, (_bundle, _path) => {
                        bundle = _bundle;
                        path = _path;
                        apeng.director.preloadScene(path, progressDir ? progressDir.progress("preloadScene") : null, loadDir.subCount());
                    });
            };
            // 预加载包
            if (this.preLoadBundles[sceneUrl])
                apeng._resouces.loadBundles(this.preLoadBundles[sceneUrl](), boundCallBack);
            else
                boundCallBack();
        }
        /**
         * 加载并切换场景
         * 当前场景切换 销毁所有 在重新加载
         * @param sceneUrl
         * @param cb
         * @param progress
         * @param openLoadingUI duration(加载显示几秒);url(打开加载ui，默认白屏过度)
         */
        change(sceneUrl, cb, progress, openLoadingUI = null, changeData = null) {
            this.curUrl = sceneUrl;
            this.isProChange = true;
            let startFn = () => {
                let loadCount = new apeng.LoadDir(2, () => {
                    this.isChange = false;
                    this.isProChange = false;
                    console.log("change scene complete:" + sceneUrl);
                    // 销毁window层和弹窗层
                    apeng._ui
                        .closeAll(apeng.EUILayer.Window)
                        .closeAll(apeng.EUILayer.WindowUp)
                        .closeAll(apeng.EUILayer.Panel)
                        .closeAll(apeng.EUILayer.PanelUp);
                    // 释放资源
                    let allUrls = [sceneUrl];
                    let preLoad = this.preLoadUrls[sceneUrl];
                    if (preLoad)
                        for (let _url of preLoad())
                            allUrls.push(typeof _url == "object" ? _url.url : _url);
                    apeng._resouces.releaseAllBundle(...allUrls);
                    if (openLoadingUI != null)
                        if (!openLoadingUI.url)
                            apeng._ui.Loading.screen(false);
                        else
                            apeng._ui.Loading.wait(false, undefined, undefined, openLoadingUI ? openLoadingUI.url : undefined);
                    this.cur.loadUrl = sceneUrl;
                    this.cur._changeData = changeData;
                    this.cur._onCreate();
                    if (cb)
                        cb();
                    this.emit(this.EventType.CHANG_SUCCESS, sceneUrl);
                });
                if (openLoadingUI != null)
                    if (openLoadingUI.duration && openLoadingUI.duration > 0) {
                        loadCount.count++;
                        apeng._timer.once(null, loadCount.subCount(), openLoadingUI.duration);
                    }
                let _progress = null;
                if (_waitProgress || progress) {
                    _progress = (ratio) => {
                        if (_waitProgress)
                            _waitProgress(ratio);
                        if (progress)
                            progress(ratio);
                    };
                }
                let fn = () => this.preLoad(sceneUrl, (boundle, path) => {
                    if (this.cur)
                        this.lastUrl = this.cur.loadUrl;
                    let loadSceneComplete = (scene) => {
                        this.cur = scene.getComponentInChildren("BaseScene");
                        if (!this.cur) {
                            console.error("find BaseScene error: ", sceneUrl);
                            return;
                        }
                        // 加载ui
                        if (this.cur.openUIUrl)
                            apeng._ui.load(this.cur.openUIUrl, loadCount.subCount());
                        else
                            loadCount.subCount()();
                    };
                    let dispose = () => {
                        if (this.cur) {
                            this.cur._onDispose();
                            this.cur = null;
                        }
                    };
                    if (this.lastUrl == sceneUrl) {
                        dispose();
                        loadSceneComplete(apeng.director.getScene());
                        return;
                    }
                    let loadSceneCb = () => {
                        dispose();
                        this.isChange = true;
                        apeng.director.once(apeng.Director.EVENT_BEFORE_SCENE_LAUNCH, loadSceneComplete);
                        apeng.director.loadScene(path, loadCount.subCount());
                    };
                    if (openLoadingUI && openLoadingUI.duration && openLoadingUI.duration > 0) {
                        if (!openLoadingUI.url) {
                            // 展示完成
                            if (apeng._ui.Loading.getScreenState() == apeng.ETipWhiteState.Show)
                                loadSceneCb();
                            // 等待白屏展示完成后切换
                            else
                                apeng._ui.Loading.setScreenShow(loadSceneCb);
                        }
                        else {
                            if (apeng._ui.Loading.getWaitState() == apeng.ETipWaitState.Complete)
                                loadSceneCb();
                            // 等待白屏展示完成后切换
                            else
                                apeng._ui.Loading.setWaitShow(loadSceneCb);
                        }
                    }
                    else
                        loadSceneCb();
                }, _progress);
                let queue = this.preLoads[sceneUrl];
                if (queue) {
                    queue.complete = fn;
                    queue.run();
                }
                else
                    fn();
            };
            // UIMgr.clearTip()
            this.emit(this.EventType.CHANG_START, sceneUrl);
            let _waitProgress = null;
            if (openLoadingUI != null) {
                if (!openLoadingUI.url) {
                    apeng._ui.Loading.screen(true);
                    startFn();
                }
                else {
                    let _ratio = 0;
                    _waitProgress = (ratio) => {
                        _ratio = ratio;
                    };
                    apeng._ui.Loading.wait(true, false, () => _ratio, openLoadingUI.url, openLoadingUI.duration, startFn);
                }
            }
            else
                startFn();
        }
        getCurrent() { return this.cur; }
    };
    SceneModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.scene)
    ], SceneModule);
    apeng.SceneModule = SceneModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../Main.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />
/// <reference path="./../utils/Sets.ts" />

(function (apeng) {
    let TimerModule = class TimerModule extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.handerPool = new apeng.PoolOnce(100, () => {
                return {
                    callBack: null,
                    caller: null,
                    timerCallBack: null,
                    args: null,
                };
            }, (data) => {
                data.callBack = null;
                data.caller = null;
                data.timerCallBack = null;
                data.args = null;
            });
            this.handerMap = new Map();
            this._updateInterval = {};
            this._updateAddTime = {};
            this.handerComponent = null;
            this._dt = 0;
            this.minDt = 1 / 60;
            this._dirtyMark = {};
            this._fps = 60;
        }
        get scheduler() {
            return apeng.director.getScheduler();
        }
        /**游戏统一帧率 增加控制慢镜头缩放比例 */
        get dt() {
            this._dt = this.dtDefault;
            this._dt *= this.timeScale;
            return this._dt;
        }
        /**一秒的帧率平滑 */
        get dtSecond() {
            return this.dt * this._fps;
        }
        /**不受时间缩放影响的帧率 */
        get dtDefault() {
            // let dt = director.getDeltaTime()
            // 控制最小帧率
            // if (dt < this.minDt)
            //     return this.minDt
            return apeng.game.deltaTime;
        }
        /**当前帧率 */
        get fps() {
            return this._fps;
        }
        set fps(value) {
            if (this._fps == value)
                return;
            this._fps = value;
            apeng.game.setFrameRate(this._fps);
        }
        get timeScale() {
            return 1;
        }
        onInstance() {
            let canvas = apeng.director.getScene().getComponentInChildren(apeng.Canvas);
            this.init(canvas);
        }
        /**手动传入 避免循环引用 */
        init(canvas) {
            this.handerComponent = canvas.addComponent(apeng.Component);
            this.handerComponent.lateUpdate = this.lateUpdate.bind(this);
        }
        /**所有执行完毕的帧定时器 */
        lateUpdate(dt) {
            for (let key in this._dirtyMark)
                this._dirtyMark[key] = true;
        }
        /**
         * 延迟定时器
         * @param callBack
         * @param delay
         */
        once(caller, callBack, delay = 0, args = null, cover = true) {
            if (delay < 0)
                callBack.apply(caller, args);
            else
                this.loop(caller, callBack, 0, 0, delay, args, cover);
        }
        /**
         * 延迟到下一帧执行
         * @param caller
         * @param callBack
         */
        callLater(caller, callBack, args = null, cover = true) {
            this.once(caller, callBack, 0, args, cover);
        }
        /**
         * 循环定时器
         * @param callback
         * @param interval
         * @param repeat -1时 无限循环
         * @param delay -1时立即执行
         * @param cover 覆盖上一个执行
         */
        loop(caller, callBack, interval, repeat = -1, delay = 0, args = null, cover = true) {
            if (apeng.EDITOR)
                return;
            if (repeat == -1)
                repeat = apeng.macro.REPEAT_FOREVER;
            let loop = this.handerMap.get(caller);
            if (!loop) {
                loop = [];
                this.handerMap.set(caller, loop);
            }
            if (this.has(caller, callBack))
                if (cover)
                    this.clear(caller, callBack);
            let pool = this.handerPool.get();
            pool.caller = caller;
            pool.callBack = callBack;
            pool.args = args;
            pool.timerCallBack = this.onCallBack.bind(this, pool);
            loop.push(pool);
            this.handerComponent.schedule(pool.timerCallBack, interval, repeat, delay);
            if (delay < 0)
                pool.timerCallBack();
        }
        pauseAll() {
            this.scheduler.pauseTarget(this.handerComponent);
        }
        resumeAll() {
            this.scheduler.resumeTarget(this.handerComponent);
        }
        isPauseAll() {
            return this.scheduler.isTargetPaused(this.handerComponent);
        }
        /**
         * 清除一个定时器
         * @param caller
         * @param callback
         * @returns
         */
        clear(caller, callBack) {
            if (apeng.EDITOR)
                return;
            let pool = this.get(caller, callBack);
            if (pool) {
                apeng.Sets.delete(this.handerMap.get(caller), pool);
                this.handerComponent.unschedule(pool.timerCallBack);
                this.handerPool.put(pool);
            }
        }
        /**
         * 清除目标上的所有定时器
         * @param caller
         * @returns
         */
        clearAll(caller) {
            let loop = this.handerMap.get(caller);
            if (!loop)
                return;
            apeng.Sets.forEach(loop, value => {
                this.clear(value.caller, value.callBack);
            }, true);
        }
        /**
         * 是否注册过
         * @param caller
         * @param callback
         * @returns
         */
        has(caller, callBack) {
            return !!this.get(caller, callBack);
        }
        /**
         * 注册过的值
         * @param caller
         * @param callback
         * @returns
         */
        get(caller, callBack) {
            let loop = this.handerMap.get(caller);
            if (!loop)
                return null;
            return apeng.Sets.filterValue(loop, value => value.caller == caller && value.callBack == callBack);
        }
        onCallBack(pool) {
            pool.callBack.apply(pool.caller, pool.args);
        }
        /**低帧率 */
        hasLowFps() {
            return this._fps <= 31;
        }
        setTimeScale(raito) {
        }
        /**
         * 获取标记 true 脏了
         * 会在lateUpdate将标记置为true
        */
        dirtyMark(key) {
            let dirty = this._dirtyMark[key];
            this._dirtyMark[key] = false;
            return (dirty === undefined || dirty === true) ? true : false;
        }
        deleteDirtyMark(key) {
            delete this._dirtyMark[key];
        }
        /**清除间隔执行 */
        clearUpdateInterval(id) {
            this._updateInterval[id] = null;
        }
        /**
         *
         * update里检测间隔执行
         * 误差(间隔时间)在 -1 到1之间
         * @param dt
         * @param interval 间隔多长时间 返回 true
         * @param onceValue  第一次进入返回false
         */
        hasUpdateIntervale(id, interval, onceValue) {
            if (this._updateInterval[id] == undefined)
                this._updateInterval[id] = 0;
            if (this._updateInterval[id] == 0) {
                this._updateInterval[id] += this.dt;
                return onceValue;
            }
            this._updateInterval[id] += this.dt;
            if (this._updateInterval[id] >= interval) {
                // 保留差值
                this._updateInterval[id] = this._updateInterval[id] - interval;
                return true;
            }
            return false;
        }
        /**
         * update里增加时间
         * @param id
         * @returns 增量到当前的时间
         */
        updateAddTime(id) {
            if (this._updateAddTime[id] == undefined)
                this._updateAddTime[id] = 0;
            this._updateAddTime[id] += this.dt;
            return this._updateAddTime[id];
        }
        /**清除递增时间 */
        clearUpdateAddTime(id) {
            this._updateAddTime[id] = null;
        }
    };
    TimerModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.timer)
    ], TimerModule);
    apeng.TimerModule = TimerModule;
})(apeng || (apeng = {}));
/// <reference path="./../Define.ts" />
/// <reference path="./../module/ModuleMgr.ts" />
/// <reference path="./../module/BaseModule.ts" />

(function (apeng) {
    const v3T = new apeng.Vec3();
    const v2T = new apeng.Vector2();
    const ccVec3zero = new apeng.Vec3();
    class _Loading {
        constructor() {
            this._waitComponent = null;
            this._waitVisible = false;
        }
        get screenComponent() {
            return apeng.NodeHelper.getChildByCreate(apeng._ui.getLayerParent(apeng.EUILayer.Item, apeng._ui.stageUp), "LoadingScreen", (node) => {
                let sp = node.addComponent(apeng.Sprite);
                sp.spriteFrame = apeng._resouces.getDefaultSpriteFrame();
                node.addComponent("LoadingScreen");
                apeng.NodeHelper.setSize(node, apeng.winSize());
                node.addComponent(apeng.BlockInputEvents);
                node.active = false;
            }).getComponent("LoadingScreen");
        }
        /**白屏动画 */
        screen(visible, color) {
            this.screenComponent.Sprite.color = color || apeng.Color.WHITE;
            this.screenComponent.init(visible);
        }
        getScreenState() {
            if (!this.screenComponent)
                return apeng.ETipWhiteState.Hide;
            return this.screenComponent.state;
        }
        setScreenShow(cb) {
            if (!this.screenComponent)
                return;
            this.screenComponent.showCb = cb;
        }
        /**
         * 打开等待加载ui
         * @param visible 显隐
         * @param clickClose 点击关闭自己
         * @param progress 加载进度
         * @param url 打开的路径， 默认 UIMgr.DefaultUrl.wait
         * @param autoAddDurtion 假进度加载时间
         * @returns
         */
        wait(visible, clickClose = false, progress = null, url = "", duration, resoucesLoadComplete) {
            if (!url)
                url = apeng._ui.DefaultUrl.wait;
            this._waitVisible = visible;
            if (!this._waitComponent)
                this._waitComponent = {};
            if (!this._waitVisible) {
                for (let key in this._waitComponent)
                    this._waitComponent[key].init(false);
                return;
            }
            if (!this._waitComponent[url]) {
                if (!apeng._resouces.get(url, apeng.Prefab)) {
                    apeng._ui.blockTouchEvent(true, apeng.EUILayer.TopUp);
                    console.log("resouces none, reload: ", url);
                    apeng._resouces.loadPrefab(url, () => {
                        apeng._ui.blockTouchEvent(false, apeng.EUILayer.TopUp);
                        this.wait(this._waitVisible, clickClose, progress, url, duration, resoucesLoadComplete);
                    });
                    return;
                }
                this._waitComponent[url] = apeng._ui.pool.get(url).getComponent("LoadingWait");
                this._waitComponent[url].node.active = false;
                apeng._ui.getLayerParent(apeng.EUILayer.ItemUp, apeng._ui.stageUp).addChild(this._waitComponent[url].node);
            }
            this._waitComponent[url].init(this._waitVisible, clickClose, progress, duration);
            if (resoucesLoadComplete)
                resoucesLoadComplete();
        }
        getWaitState() {
            if (!this._waitComponent)
                return apeng.ETipWaitState.Hide;
            for (let key in this._waitComponent)
                if (this._waitComponent[key].node.active)
                    return this._waitComponent[key].state;
            return apeng.ETipWaitState.Hide;
        }
        setWaitShow(cb) {
            if (!this._waitComponent)
                return;
            for (let key in this._waitComponent)
                if (this._waitComponent[key].node.active)
                    this._waitComponent[key].completeCb = cb;
        }
    }
    let UIModule = class UIModule extends apeng.BaseModuleEvent {
        constructor() {
            super(...arguments);
            this.EventType = {
                LOAD_COMPLETE: "LOAD_COMPLETE",
                OPEN_BEFORE: "OPEN_BEFORE",
                OPEN: "OPEN",
                CLOSE: "CLOSE",
                DISPOSE: "DISPOSE",
                /**关闭全部弹窗时，不包括 lockUIMgrAll=true，layerType=EUILayer.WindowUp|EUILayer.Window*/
                CLOSE_SCENE_ALL: "CLOSE_SCENE_ALL",
                /**同上 下一帧检测 */
                CLOSE_SCENE_ALL_DELAY: "CLOSE_SCENE_ALL_DELAY",
                /**有一个为 false 时 不算全部关闭弹窗 */
                HAS_CLOSE_SCENE_ALL: "HAS_CLOSE_SCENE_ALL",
            };
            this.DefaultUrl = {
                tip: "main/prefab/systemUI/Tip",
                tipSystemFont: "main/prefab/systemUI/Tip",
                tipClick: "main/prefab/systemUI/TipClick",
                tipClickSystemFont: "main/prefab/systemUI/TipTitleClick",
                tipTitleClick: "main/prefab/systemUI/TipTitleClick",
                tipTitleClickSystemFont: "main/prefab/systemUI/TipTitleClick",
                wait: "main/prefab/systemUI/LoadingWait",
                moveUp: "main/prefab/systemUI/MoveUpItem",
                flyItem: "main/prefab/systemUI/FlyEffectItem",
                fly: "main/prefab/systemUI/FlyEffect",
            };
            /**延迟预加载音效 */
            this.delayProAudio = .6;
            this.Loading = new _Loading();
            this.pool = new apeng.Pool(1000, (url) => apeng.instantiate(apeng._resouces.get(url)), (data) => {
                apeng.TweenHelper.stop(data);
                data.removeFromParent();
            }, (data) => data.destroy());
            /**ui池 */
            this.modules = new apeng.Maps();
            this.UICamera = null;
            this.ScreenshotCamera = null;
            /**舞台 */
            this.stage = null;
            /**舞台上层 */
            this.stageUp = null;
            this.waits = [];
            this.openTotal = 0;
            this.preLoadUrls = {};
            this.preLoads = {};
        }
        onBeforeInstance() {
            let canvas = apeng.director.getScene().getComponentInChildren(apeng.Canvas);
            this.setStage(canvas.node);
        }
        /**
         * 屏蔽所有触摸事件
         * @param visible
         * @param layer
         * @param stage 可选stageUp 默认 stage
         */
        blockTouchEvent(visible, layer = apeng.EUILayer.Top, stage) {
            apeng.NodeHelper.getChildByCreate(this.getLayerParent(layer, stage), "blockTouchEvent", (node) => {
                node.addComponent(apeng.BlockInputEvents);
                apeng.NodeHelper.setSize(node, apeng.winSize());
            }).active = visible;
        }
        blockTouchEventVisible(layer = apeng.EUILayer.Top, stage) {
            return apeng.NodeHelper.getChildByCreate(this.getLayerParent(layer, stage), "blockTouchEvent", (node) => {
                node.addComponent(apeng.BlockInputEvents);
                apeng.NodeHelper.setSize(node, apeng.winSize());
                node.active = false;
            }).active;
        }
        /**
         * 获取ui数据
         * @param url
         * @returns
         */
        getModule(url) {
            let value = this.modules.get(url);
            if (!value) {
                value = {
                    ui: null,
                    state: apeng.EUIState.None,
                    openCount: 0,
                    openTime: -1,
                    closeCb: null,
                    url: url,
                    loaded: false,
                    disposeByRelease: true,
                    openTotal: 0
                };
                this.modules.set(url, value);
            }
            return value;
        }
        /**
         * 系统提示
         * @param str
         */
        tip(str, clickClose = false, closecb, systemFont = false) {
            if (clickClose) {
                let url = systemFont ? this.DefaultUrl.tipClickSystemFont : this.DefaultUrl.tipClick;
                apeng._resouces.loadPrefab(url, () => {
                    let item = this.pool.get(url).getComponent("TipClick");
                    this.getLayerParent(apeng.EUILayer.Item, this.stageUp).addChild(item.node);
                    item.init(str, closecb);
                });
            }
            else {
                let url = systemFont ? this.DefaultUrl.tipSystemFont : this.DefaultUrl.tip;
                apeng._resouces.loadPrefab(url, () => {
                    let item = this.pool.get(url).getComponent("Tip");
                    this.getLayerParent(apeng.EUILayer.Item, this.stageUp).addChild(item.node);
                    item.init(str, closecb);
                });
            }
        }
        /**
              * 飞行动画
              * @param start
              * @param end
              * @param iconUrl
              * @param itemCount 默认 10～15个，生成的个数  可传入固定个数，也可[2,10]随机指定个数
              * @param cb
              */
        flyTip(start, end, iconUrl, itemCount, cb) {
            let fly = this.DefaultUrl.fly, flyItem = this.DefaultUrl.flyItem;
            start = apeng.Vector2.pool.get().set(start);
            if (apeng._resouces.get(flyItem, apeng.Prefab)) {
                let item = apeng._ui.pool.get(fly).getComponent("FlyEffect");
                apeng._ui.getLayerParent(apeng.EUILayer.Item).addChild(item.node);
                item.init(start, end, iconUrl, flyItem, itemCount, cb);
                apeng.Vector2.pool.put(start);
            }
            else
                apeng._resouces.loadDir([
                    { url: fly, type: apeng.Prefab },
                    { url: flyItem, type: apeng.Prefab }
                ], () => {
                    this.flyTip(start, end, iconUrl, itemCount, cb);
                });
        }
        /**向上飞的动画 */
        moveUp(startWorldPosition, text, iconUrl, complete, scale = 1) {
            apeng._resouces.loadPrefab(this.DefaultUrl.moveUp, () => {
                let item = this.pool.get(this.DefaultUrl.moveUp).getComponent("MoveUpItem");
                this.getLayerParent(apeng.EUILayer.Item, this.stageUp).addChild(item.node);
                item.setScaleNum(scale, false);
                item.init(startWorldPosition, text, iconUrl, () => {
                    this.pool.put(item.node);
                    if (complete)
                        complete();
                });
            });
        }
        /**
         * 系统提示
         * @param title 标题 如无 则不显示标题栏
         * @param strs 从上往下排列的字符
         * @param closeCb
         */
        tipTitle(datas, title, closeCb, showDot = true, autoClose = false, downTip = "", systemFont = false) {
            let url = systemFont ? this.DefaultUrl.tipTitleClickSystemFont : this.DefaultUrl.tipTitleClick;
            apeng._resouces.loadPrefab(url, () => {
                let item = this.pool.get(url).getComponent("TipTitleClick");
                this.getLayerParent(apeng.EUILayer.Item, this.stageUp).addChild(item.node);
                item.init(datas, title, closeCb, showDot, autoClose, downTip);
            });
        }
        /**清除所有提示 */
        clearTip() {
            let parent = this.getLayerParent(apeng.EUILayer.Item, this.stageUp);
            apeng.Sets.forEach(parent.children, (child) => {
                let tip = child.getComponent("Tip");
                if (!tip)
                    tip = child.getComponent("Tip");
                if (tip && tip.isVisible)
                    this.pool.put(child);
            }, true);
        }
        /**
         * 调起系统弹窗
         * @param content 文字内容
         * @param btn 点击按钮
         * @param rightBtn 如有 则为两个按钮 为右边的按钮
         */
        dialogue(str, btn, rightBtn) {
            let url = "main/prefab/systemUI/Dialogue";
            apeng._resouces.loadPrefab(url, () => {
                let item = this.pool.get(url).getComponent("Dialogue");
                this.getLayerParent(apeng.EUILayer.Item, this.stageUp).addChild(item.node);
                item.init(str, btn, rightBtn);
            });
        }
        /**获取处于原点下的UI节点 */
        getZeroWorldPointNode() {
            return apeng.NodeHelper.getChildByCreate(this.stage.parent, "ZeroWorldPointNode", (node) => {
                let trans = node.getComponent(apeng.UITransform);
                trans.setContentSize(new apeng.Size(0, 0));
                trans.setAnchorPoint(0, 0);
            }, undefined, undefined, (node) => {
                apeng.NodeHelper.setPosition(node, ccVec3zero, true);
            });
        }
        /**生成线 */
        showLine(startWorld, endWorld, color = apeng.Color.RED, width = 10) {
            let node = this._line;
            node.getComponent(apeng.Sprite).color = color;
            node.active = true;
            let trans = node.getComponent(apeng.UITransform);
            trans.width = width;
            trans.height = apeng.Vector2.distance(startWorld, endWorld);
            apeng.NodeHelper.setPositionXY(node, startWorld, true);
            let rotate = apeng.Vector2.angle360(startWorld, endWorld, -90);
            apeng.NodeHelper.setRotateZ(node, rotate, false);
            return node;
        }
        get _line() {
            return apeng.NodeHelper.getChildByCreate(this.stage.parent, "-line", (node) => {
                let trans = node.getComponent(apeng.UITransform);
                trans.setAnchorPoint(0.5, 1);
                let sp = node.addComponent(apeng.Sprite);
                sp.spriteFrame = apeng._resouces.getDefaultSpriteFrame();
            });
        }
        hideLine() {
            let node = this._line;
            node.active = false;
        }
        createSpriteSplashItem(parent, color = new apeng.Color(255, 255, 255, 255), size = new apeng.Size(10, 10)) {
            let node = new apeng.Node("SpriteSplashItem");
            node.layer = parent.layer;
            let trans = node.addComponent(apeng.UITransform);
            let sp = node.addComponent(apeng.Sprite);
            sp.color = color;
            sp.spriteFrame = apeng._resouces.getDefaultSpriteFrame();
            trans.setContentSize(size);
            trans.setAnchorPoint(0.5, 0.5);
            parent.addChild(node);
            return node;
        }
        createByRectangle(rectangle) {
            let node = this.createSpriteSplashItem(this.stageUp, new apeng.Color(255, 255, 255, 100), new apeng.Size(rectangle.width, rectangle.height));
            node.setWorldPosition(new apeng.Vec3(rectangle.center.x, rectangle.center.y));
        }
        preOpen(url, openData) {
            this.open(url, openData, () => {
                apeng._timer.once(this, () => this.close(url), .1);
            }, null, false, false);
        }
        /**
         * 打开一个ui
         * @param url ui预制体相对路径
         * @param openData 传入数据到module
         * @param openCb 真正打开回调 onCreate后
         * @param closeCb 监听ui关闭时回调 onClose后
         * @param tipWait 打开ui加载进度界面`true`
         * @returns
         */
        open(url, openData, openCb, closeCb, tipWait = true, show = true) {
            let module = this.getModule(url);
            if (!module) {
                console.error("module none: ", url);
                return;
            }
            module.closeCb = closeCb;
            let open = () => {
                if (this.preLoads[url])
                    this.preLoads[url](openData, () => this.onOpened(url, openData, openCb, show));
                else
                    this.onOpened(url, openData, openCb, show);
            };
            if (module.ui && apeng.isValid(module.ui, true) && apeng._resouces.get(module.url, apeng.Prefab)) {
                open();
                return;
            }
            if (module.state == apeng.EUIState.Load) {
                console.log("ui loading: ", url);
                return;
            }
            module.state = apeng.EUIState.Load;
            let progress = null;
            if (tipWait) {
                let _ratio = 0;
                progress = (ratio) => {
                    _ratio = ratio;
                };
                this.Loading.wait(true, false, () => _ratio);
            }
            this.load(url, () => {
                if (tipWait)
                    this.Loading.wait(false);
                if (module.state == apeng.EUIState.None) {
                    console.log("ui none, destoryed: ", url);
                    return;
                }
                this.emit(this.EventType.LOAD_COMPLETE, url);
                // 创建节点
                let ui = this.pool.get(url).getComponent("BaseUI");
                ui.url = url;
                module.ui = ui;
                ui.node.active = false;
                this.getLayerParent(ui.layerType, ui.stageUp ? this.stageUp : this.stage).addChild(ui.node);
                // 避免加载完关闭的
                if (module.state != apeng.EUIState.LoadClose)
                    module.state = apeng.EUIState.Close;
                open();
            }, openData, progress);
        }
        /**
         * 关闭ui
         * active = false
         * @param url addModule名
         * @returns
         */
        close(url) {
            let module = this.getModule(url);
            if (!module) {
                console.error("module none: ", url);
                return;
            }
            switch (module.state) {
                // 在等待队列中 显示出来
                case apeng.EUIState.None:
                    console.log("ui close, find none: ", url);
                    break;
                // 如果正在显示 则关闭ui 并校验等待队列
                case apeng.EUIState.Open:
                    module.state = apeng.EUIState.Close;
                    this.setActive(url, false, true);
                    this.emitOpenByCloseCb(url, module.closeCb);
                    this.emit(this.EventType.CLOSE, url);
                    // 派发等待队列的UI
                    this.openWaitUI(url);
                    this.checkSceneOpenUI();
                    this.checkAd();
                    break;
                // 如果正在加载中的ui 则不让它显示 有可能出现调用了显示ui 还没加载完 就关闭状态
                case apeng.EUIState.Load:
                    console.log("ui close, load no complete: ", url);
                    module.state = apeng.EUIState.LoadClose;
                    break;
                // 如果在等待中 则从等待队列中移除
                case apeng.EUIState.Wait:
                    console.log("ui close, wait remove: ", url);
                    module.state = apeng.EUIState.Close;
                    break;
                case apeng.EUIState.Close:
                    console.log("ui close, state close, no repeat: ", url);
                    break;
            }
        }
        checkAd() {
            apeng._timer.once(this, this.onDelayCheckAd, .6);
        }
        /**
         * 播放粒子特效
         * @param url
         * @param pos 屏幕中心点
         * @param layer
         */
        playParticle(url, centerOffset, layer = apeng.EUILayer.Top) {
            apeng._resouces.loadPrefab(url, () => {
                let comp = this.pool.get(url).getComponent("ParticleSystem2DCC");
                apeng.NodeHelper.setPositionXY(comp.node, centerOffset, false);
                this.getLayerParent(layer).addChild(comp.node);
                comp.play(() => {
                    this.pool.put(comp.node);
                });
            });
        }
        onDelayCheckAd() {
            let ad = this.getTop(ui => ui.bottomAdType != apeng.EBottomAdType.Jump);
            if (ad)
                apeng._platform.bannerOrNativeTemp(this.getModule(ad).ui.bottomAdType);
            let block = this.getTop(ui => ui.blockOnceAdType != apeng.EBlockOnceAdType.Jump);
            if (block)
                apeng._platform.blockOnce(this.getModule(block).ui.blockOnceAdType);
        }
        /**获取当前展示最上层的ui */
        getTop(add) {
            // 找到现在最上层的ui
            // 通过节点树查找
            let showUIs = [];
            this.modules.forEach((v, k) => {
                if (v.ui) {
                    if (!add || add(v.ui))
                        if (v.state == apeng.EUIState.Open)
                            showUIs.push(k);
                }
            });
            // 根据节点层级排序
            apeng.Sets.sortMax(showUIs, v => {
                let modul = this.getModule(v);
                let node = modul.ui.node;
                let curIndex = node.getSiblingIndex();
                let layerIndex = node.parent.getSiblingIndex() * 100;
                let stageIndex = node.parent.parent.getSiblingIndex() * 1000;
                return curIndex + layerIndex + stageIndex;
            });
            return showUIs[0];
        }
        /**场景上是否还有其他ui */
        checkSceneOpenUI() {
            if (!this.hasSceneOpenUI())
                this.emit(this.EventType.CLOSE_SCENE_ALL);
            if (this.hasEventName(this.EventType.CLOSE_SCENE_ALL_DELAY))
                apeng._timer.callLater(this, this.onDelayHasOpenUIEvent);
        }
        onDelayHasOpenUIEvent() {
            if (!this.hasSceneOpenUI())
                this.emit(this.EventType.CLOSE_SCENE_ALL_DELAY);
        }
        /**查看 场景上还有其他弹窗 */
        hasSceneOpenUI() {
            // 能成功的事件
            for (let _value of this.emit(this.EventType.HAS_CLOSE_SCENE_ALL))
                if (!_value)
                    return true;
            return this.modules.filterValue(v => {
                if (v.state == apeng.EUIState.Load)
                    return true;
                if (v.state == apeng.EUIState.Open) {
                    if (!(v.ui.layerType == apeng.EUILayer.Window
                        || v.ui.layerType == apeng.EUILayer.WindowUp
                        || v.ui.layerType == apeng.EUILayer.WindowUpAfter
                        || v.ui.lockUIMgrAll))
                        return true;
                }
                return false;
            });
        }
        /**
       * 转换世界坐标到ui节点下得坐标
       * @param camera
       * @param worldPosition
       * @param parent
       * @returns
       */
        cameraConverToUINode(worldPosition, parent) {
            this.UICamera.convertToUINode(worldPosition, parent, v3T);
            return v3T;
        }
        /**
         * 打开在等待队列中的ui
         */
        openWaitUI(url) {
            if (this.hasUp(url))
                return;
            // 找到最前的ui
            let wait = this.waits.shift();
            if (wait) {
                console.log("ui close, emit wait: ", wait.url);
                wait.state = apeng.EUIState.Open;
                this.setActive(wait.url, true, true);
            }
        }
        /**
         * 设置ui的显隐 并派发事件
         * @param url
         * @param isOpen
         * @param isCb
         */
        setActive(url, isOpen, isCb) {
            // 避免重复回调
            let module = this.getModule(url);
            let active = module.ui.node.active;
            if (isOpen) {
                // 保证新打开的永远在当前层 最上
                module.ui.node.setSiblingIndex(module.ui.node.parent.children.length - 1);
                module.ui.node.active = true;
                if (!module.loaded) {
                    module.loaded = true;
                    module.ui._onCreate();
                }
                if (!active && isCb) {
                    module.ui._onOpen();
                }
            }
            else {
                if (active && isCb && module.ui.onBeforeClose)
                    module.ui.onBeforeClose();
                module.ui.node.active = false;
                if (active && isCb)
                    module.ui._onClose();
            }
        }
        /**
         * 关闭指定的ui
         */
        closeAll(layer, exclude, checkLock = true) {
            console.log("close all layer-" + apeng.EUILayer[layer]);
            this.modules.forEach((module, url) => {
                if (!module.ui)
                    return;
                if (layer != module.ui.layerType)
                    return;
                if (checkLock)
                    if (module.ui.lockUIMgrAll)
                        return;
                if (exclude)
                    if (exclude.indexOf(url) != -1)
                        return;
                switch (module.state) {
                    case apeng.EUIState.Open:
                        module.state = apeng.EUIState.Close;
                        break;
                    case apeng.EUIState.Load:
                        module.state = apeng.EUIState.LoadClose;
                        return;
                    case apeng.EUIState.Wait:
                        module.state = apeng.EUIState.Close;
                        break;
                    case apeng.EUIState.None:
                        return;
                }
                this.setActive(url, false, true);
                this.emitOpenByCloseCb(url, module.closeCb);
            });
            return this;
        }
        /**
         * 销毁一个ui
         * @param url
         */
        dispose(url) {
            let module = this.getModule(url);
            if (!module) {
                console.error("module none: ", url);
                return;
            }
            if (!module.ui)
                return;
            this.setActive(url, false, true);
            module.ui._onDispose();
            module.ui.node.destroy();
            module.ui = null;
            module.state = apeng.EUIState.None;
            module.loaded = false;
            if (module.disposeByRelease)
                apeng._resouces.release(module.url, apeng.Prefab);
            this.emitOpenByCloseCb(url, module.closeCb);
            this.emit(this.EventType.DISPOSE, url);
            this.openWaitUI(url);
        }
        /**
         * 销毁指定ui
         */
        disposeAll(layer) {
            console.log("dispose all layer-" + apeng.EUILayer[layer]);
            this.modules.forEach((module, url) => {
                if (!module.ui)
                    return;
                if (layer != module.ui.layerType)
                    return;
                if (module.ui.lockUIMgrAll)
                    return;
                switch (module.state) {
                    case apeng.EUIState.Open:
                        module.state = apeng.EUIState.Close;
                        break;
                    case apeng.EUIState.Load:
                        module.state = apeng.EUIState.LoadClose;
                        return;
                    case apeng.EUIState.Wait:
                        module.state = apeng.EUIState.Close;
                        break;
                    case apeng.EUIState.None:
                        return;
                }
                this.dispose(url);
            });
            return this;
        }
        emitOpenByCloseCb(url, cb) {
            // 派发openUI时 监听关闭的回调
            let module = this.getModule(url);
            module.closeCb = null;
            if (cb)
                cb(module.ui._closeData);
        }
        /**获取UI父节点 */
        getLayerParent(layer, stage = null) {
            if (!stage)
                stage = this.stage;
            return apeng.NodeHelper.insertChild(stage, layer);
        }
        setStage(canvasNode) {
            apeng.director.addPersistRootNode(canvasNode);
            apeng.NodeHelper.UICamera = this.UICamera = canvasNode.getChildByName("UICamera").getComponent(apeng.Camera);
            this.ScreenshotCamera = canvasNode.getChildByName("ScreenshotCamera").getComponent(apeng.Camera);
            this.ScreenshotCamera.node.active = false;
            this.ScreenshotCamera.visibility = apeng.Layers.Enum.screenshot;
            let _winSize = apeng.winSize();
            let rt = new apeng.RenderTexture();
            rt.initialize({ width: _winSize.width, height: _winSize.height });
            this.ScreenshotCamera.targetTexture = rt;
            // 苹果机 微信小游戏 超过2048 导致屏幕缩小
            // setTimeout(() => {
            // 	this.ScreenshotCamera.node.active = true
            // }, 2000)
            // // 安卓端被放大了
            // if (sys.isNative)
            // 	UIMgr.ScreenshotCamera.rect = new Rect(0, 0, 1.00, 1.00)
            this.stage = apeng.NodeHelper.getChildByCreate(canvasNode, "stage", (node) => {
                apeng.NodeHelper.setSize(node, _winSize);
            });
            this.stageUp = apeng.NodeHelper.getChildByCreate(canvasNode, "stageUp", (node) => {
                apeng.NodeHelper.setSize(node, _winSize);
            });
        }
        /**
         * 加载一个ui
         * @param url
         * @param cb
         */
        load(url, cb, openData, progress) {
            if (apeng._resouces.get(url, apeng.Prefab)) {
                if (progress)
                    progress(1);
                if (cb)
                    cb();
                return;
            }
            // 预加载资源
            let urls = this.preLoadUrls[url] ? this.preLoadUrls[url](openData) : [];
            if (urls.length > 1) {
                urls.push({ url, type: apeng.Prefab });
                apeng._resouces.loadDir(urls, cb, progress);
            }
            else {
                apeng._resouces.loadPrefab(url, cb, progress);
            }
        }
        /**
         * 销毁ui时 释放资源
         * @param url
         * @param release 默认true
         */
        setDisposeByRelease(url, release = true) {
            this.getModule(url).disposeByRelease = release;
            apeng._resouces.addRootBundle(apeng._resouces.getUrlByBoundleName(url));
        }
        /**
      * 设置加载UI时
      * 需要预先加载的资源
      * @param url
      * @param urls
      */
        setPreLoadUrls(url, urls) {
            this.preLoadUrls[url] = urls;
            return this;
        }
        /**
    * 设置加载UI时
    * 需要预先加载的资源
    * @param url
    * @param urls
    */
        setPreLoad(url, complete) {
            this.preLoads[url] = complete;
            return this;
        }
        /**获取启动游戏开始 打开的次数 */
        getOpenCount(url) {
            let module = this.getModule(url);
            if (!module)
                return 0;
            return module.openCount;
        }
        clearOpenDayCount() {
            let keys = this.storage.getPrefixKeys("open-day-");
            for (let key of keys)
                this.storage.delete(key);
        }
        /**获取当天打开的次数 */
        getToDayOpenCount(url) {
            return this.storage.get("open-day-" + url, 0);
        }
        /**获取打开页面到当前的持续时间 秒*/
        getOpenByDuation(url) {
            let module = this.getModule(url);
            if (!module)
                return 0;
            return apeng.Times.second() - module.openTime;
        }
        /**属于up层 */
        hasUp(url) {
            let module = this.getModule(url);
            if (!module)
                return false;
            if (!module.ui)
                return false;
            return this.hasLayerUp(module);
        }
        hasLayerUp(module) {
            return apeng.EUILayer[module.ui.layerType].indexOf("Up") != -1;
        }
        /**注册打开事件 */
        onceOpen(uiUrl, cb, delay = 0) {
            let fn = (url) => {
                if (url == uiUrl) {
                    apeng._timer.once(this, () => {
                        cb(this.getModule(uiUrl).ui);
                    }, delay);
                    return true;
                }
                return false;
            };
            if (this.getModule(uiUrl).ui)
                fn(uiUrl);
            else
                this.once(this.EventType.OPEN, fn);
        }
        onOpened(url, openData, openCb, show = true) {
            this.openTotal++;
            let module = this.getModule(url);
            module.openCount++;
            module.openTime = apeng.Times.second();
            this.storage.set("open-day-" + url, this.getToDayOpenCount(url) + 1);
            module.openTotal = this.openTotal;
            switch (module.state) {
                // 在等待队列中 显示出来
                case apeng.EUIState.Wait:
                    console.log("ui open, waiting again open: ", url);
                    module.state = apeng.EUIState.Close;
                    this.onOpened(url, openData, openCb, show);
                    break;
                // 正在显示中 回调一次
                case apeng.EUIState.Open:
                    console.log("ui open, state open, no repeat: ", url);
                    module.ui._openData = openData;
                    module.ui.__openShow = show;
                    module.ui.updateOpenShow();
                    module.ui.node.setSiblingIndex(module.ui.node.parent.children.length - 1);
                    module.ui._onOpen();
                    if (openCb)
                        openCb();
                    break;
                // 正隐藏的 正常显示 会顶掉正在显示的同级ui 等close时打开
                case apeng.EUIState.Close:
                    // 顶掉 高层级ui
                    if (!this.hasUp(url)) {
                        this.waits.length = 0;
                        this.modules.values(v => {
                            if (v.state == apeng.EUIState.Wait
                                || (v.state == apeng.EUIState.Open
                                    && !v.ui.lockUIMgrAll
                                    && module.ui.layerType < v.ui.layerType
                                    && v.url != url
                                    && !this.hasLayerUp(v))) {
                                console.log("ui open, add wait: ", v.url);
                                v.state = apeng.EUIState.Wait;
                                this.setActive(v.url, false, true);
                                return false;
                            }
                            return true;
                        }, this.waits);
                        apeng.Sets.sortMax(this.waits, a => a.openTotal);
                    }
                    console.log("ui open, open success:", url);
                    // 显示ui
                    module.state = apeng.EUIState.Open;
                    module.ui._openData = openData;
                    module.ui.__openShow = show;
                    module.ui.updateOpenShow();
                    this.emit(this.EventType.OPEN_BEFORE, url);
                    this.setActive(url, true, true);
                    if (openCb)
                        openCb();
                    this.emit(this.EventType.OPEN, url);
                    this.checkAd();
                    break;
                case apeng.EUIState.None:
                    console.log("ui open, none:", url);
                    break;
                case apeng.EUIState.Load:
                    console.log("ui open, state loading, please wait load complete call: ", url);
                    break;
                case apeng.EUIState.LoadClose:
                    module.state = apeng.EUIState.Close;
                    console.log("ui open, state loading close:", url);
                    break;
            }
        }
    };
    UIModule = __decorate([
        apeng.moduleMgr.add(apeng.EModuleType.ui)
    ], UIModule);
    apeng.UIModule = UIModule;
})(apeng || (apeng = {}));

(function (apeng) {
    apeng.CGuideDefine = {
        fingerUrl: "guide/prefab/Finger",
    };
})(apeng || (apeng = {}));

(function (apeng) {
    /**广告展示的类型 */
    let EBottomAdType;
    (function (EBottomAdType) {
        /**跳过检测 */
        EBottomAdType[EBottomAdType["Jump"] = 0] = "Jump";
        /**什么都不显示 */
        EBottomAdType[EBottomAdType["None"] = 1] = "None";
        /**显示Banner */
        EBottomAdType[EBottomAdType["Banner"] = 2] = "Banner";
        /**显示原生 */
        EBottomAdType[EBottomAdType["Native"] = 3] = "Native";
    })(EBottomAdType = apeng.EBottomAdType || (apeng.EBottomAdType = {}));
    let EBlockOnceAdType;
    (function (EBlockOnceAdType) {
        /**跳过检测 */
        EBlockOnceAdType[EBlockOnceAdType["Jump"] = 0] = "Jump";
        /**什么都不显示 */
        EBlockOnceAdType[EBlockOnceAdType["None"] = 1] = "None";
        /**显示 */
        EBlockOnceAdType[EBlockOnceAdType["Show"] = 2] = "Show";
    })(EBlockOnceAdType = apeng.EBlockOnceAdType || (apeng.EBlockOnceAdType = {}));
    /**ui对应的banner模式 */
    let EAdState;
    (function (EAdState) {
        /**不进行任何操作 */
        EAdState[EAdState["None"] = 0] = "None";
        /**显示banner */
        EAdState[EAdState["Show"] = 1] = "Show";
        /**将显示的banner隐藏 */
        EAdState[EAdState["Hide"] = 2] = "Hide";
    })(EAdState = apeng.EAdState || (apeng.EAdState = {}));
    let TShare;
    (function (TShare) {
        TShare.ParamDefault = {
            title: "",
            imageUrl: "",
            query: "",
            desc: " ",
        };
    })(TShare = apeng.TShare || (apeng.TShare = {}));
    let ERewardVideoState;
    (function (ERewardVideoState) {
        /**观看视频完成 */
        ERewardVideoState[ERewardVideoState["Finish"] = 0] = "Finish";
        /**中途关闭 */
        ERewardVideoState[ERewardVideoState["Close"] = 1] = "Close";
        /**拉起失败，播放失败等 */
        ERewardVideoState[ERewardVideoState["Error"] = 2] = "Error";
    })(ERewardVideoState = apeng.ERewardVideoState || (apeng.ERewardVideoState = {}));
    //--分享的场景(只属于android)
    let WxShareScene;
    (function (WxShareScene) {
        /**聊天界面 */
        WxShareScene[WxShareScene["share_session"] = 0] = "share_session";
        /**朋友圈 */
        WxShareScene[WxShareScene["share_timeline"] = 1] = "share_timeline";
        /**收藏 */
        WxShareScene[WxShareScene["share_favorite"] = 2] = "share_favorite";
    })(WxShareScene = apeng.WxShareScene || (apeng.WxShareScene = {}));
    let WxShareType;
    (function (WxShareType) {
        /**纯文本 */
        WxShareType[WxShareType["type_text"] = 0] = "type_text";
        /**纯图片 */
        WxShareType[WxShareType["type_image"] = 1] = "type_image";
        /**视频----暂时用不到 */
        WxShareType[WxShareType["type_video"] = 2] = "type_video";
        /**音乐----暂时用不到 */
        WxShareType[WxShareType["type_music"] = 3] = "type_music";
        /**网址 */
        WxShareType[WxShareType["type_webPage"] = 4] = "type_webPage";
        /**小游戏----暂时用不到*/
        WxShareType[WxShareType["type_miniProgram"] = 5] = "type_miniProgram";
    })(WxShareType = apeng.WxShareType || (apeng.WxShareType = {}));
    let ENativeSend;
    (function (ENativeSend) {
        ENativeSend["language"] = "language";
        ENativeSend["umInit"] = "umInit";
        ENativeSend["umReport"] = "umReport";
        ENativeSend["platform"] = "platform";
        ENativeSend["rewardedVideoCreate"] = "rewardedVideoCreate";
        ENativeSend["rewardedVideoShow"] = "rewardedVideoShow";
        ENativeSend["interstitialCreate"] = "interstitialCreate";
        ENativeSend["interstitialLoad"] = "interstitialLoad";
        ENativeSend["interstitialShow"] = "interstitialShow";
        ENativeSend["bannerCreate"] = "bannerCreate";
        ENativeSend["bannerHide"] = "bannerHide";
        ENativeSend["BannerShow"] = "BannerShow";
        ENativeSend["hideLauncher"] = "hideLauncher";
        /**wyd add */
        ENativeSend["wxgetcode"] = "wxgetcode";
        ENativeSend["wxshare"] = "wxshare";
        ENativeSend["fbshare"] = "fbshare";
        ENativeSend["facebookLogin"] = "facebookLogin";
        ENativeSend["downloadsaveimg"] = "downloadsaveimg";
        ENativeSend["openVibrator"] = "openVibrator";
        ENativeSend["hideVibrator"] = "hideVibrator";
        ENativeSend["taptapLogin"] = "taptapLogin";
        ENativeSend["googleLogin"] = "googleLogin";
        ENativeSend["taptapAntiAddiction"] = "taptapAntiAddiction";
        ENativeSend["privacyConfirm"] = "privacyConfirm";
        //--展示广告
        ENativeSend["OpenMediationShowRewardAd"] = "OpenMediationShowRewardAd";
        ENativeSend["reportEventCustom"] = "reportEventCustom";
        ENativeSend["reportUserProperty"] = "reportUserProperty";
        ENativeSend["getSystemInfo"] = "getSystemInfo";
    })(ENativeSend = apeng.ENativeSend || (apeng.ENativeSend = {}));
    let ENativeReceive;
    (function (ENativeReceive) {
        ENativeReceive["rewardVideoError"] = "rewardVideoError";
        ENativeReceive["rewardVideoLoaded"] = "rewardVideoLoaded";
        ENativeReceive["rewardVideoShowed"] = "rewardVideoShowed";
        ENativeReceive["rewardVideoClose"] = "rewardVideoClose";
        ENativeReceive["interstitialError"] = "interstitialError";
        ENativeReceive["interstitialLoaded"] = "interstitialLoaded";
        ENativeReceive["interstitialShow"] = "interstitialShow";
        ENativeReceive["interstitialClose"] = "interstitialClose";
        ENativeReceive["bannerError"] = "bannerError";
        ENativeReceive["bannerLoaded"] = "bannerLoaded";
        ENativeReceive["bannerShow"] = "bannerShow";
        ENativeReceive["bannerHide"] = "bannerHide";
        ENativeReceive["ReceSystemInfo"] = "ReceSystemInfo";
        ENativeReceive["login_success"] = "login_success";
        ENativeReceive["login_fail"] = "login_fail";
        ENativeReceive["wxShareReturn"] = "wxShareReturn";
        ENativeReceive["downLoadSaveImgResult"] = "downLoadSaveImgResult";
        ENativeReceive["AntiAddictionResult"] = "AntiAddictionResult";
        ENativeReceive["privacyConfirmComplete"] = "privacyConfirmComplete";
        //--广告展示结果
        ENativeReceive["OpenMediation_RewardAd_Result"] = "OpenMediation_RewardAd_Result";
    })(ENativeReceive = apeng.ENativeReceive || (apeng.ENativeReceive = {}));
})(apeng || (apeng = {}));

(function (apeng) {
    let ETipWhiteState;
    (function (ETipWhiteState) {
        ETipWhiteState[ETipWhiteState["Hide"] = 0] = "Hide";
        ETipWhiteState[ETipWhiteState["Show"] = 1] = "Show";
        ETipWhiteState[ETipWhiteState["Showing"] = 2] = "Showing";
        ETipWhiteState[ETipWhiteState["Hideing"] = 3] = "Hideing";
    })(ETipWhiteState = apeng.ETipWhiteState || (apeng.ETipWhiteState = {}));
    let ETipWaitState;
    (function (ETipWaitState) {
        ETipWaitState[ETipWaitState["Hide"] = 0] = "Hide";
        ETipWaitState[ETipWaitState["Complete"] = 1] = "Complete";
        ETipWaitState[ETipWaitState["Loading"] = 2] = "Loading";
    })(ETipWaitState = apeng.ETipWaitState || (apeng.ETipWaitState = {}));
    /**ui当前状态 */
    let EUIState;
    (function (EUIState) {
        /**无效状态 */
        EUIState[EUIState["None"] = 0] = "None";
        /**正在加载中 */
        EUIState[EUIState["Load"] = 1] = "Load";
        /**显示中 */
        EUIState[EUIState["Open"] = 2] = "Open";
        /**加载过后 隐藏中 */
        EUIState[EUIState["Close"] = 3] = "Close";
        /**被顶掉 等调用CloseUI时显示 等待中*/
        EUIState[EUIState["Wait"] = 4] = "Wait";
        /**还没加载完 调用了关闭 */
        EUIState[EUIState["LoadClose"] = 5] = "LoadClose";
    })(EUIState = apeng.EUIState || (apeng.EUIState = {}));
    /**ui层级 up层不具备顶掉功能 */
    let EUILayer;
    (function (EUILayer) {
        /**主界面 */
        EUILayer[EUILayer["Window"] = 0] = "Window";
        /**主界面上层 之前*/
        EUILayer[EUILayer["WindowUpAfter"] = 1] = "WindowUpAfter";
        /**主界面上层 */
        EUILayer[EUILayer["WindowUp"] = 2] = "WindowUp";
        /**弹窗层 */
        EUILayer[EUILayer["Panel"] = 3] = "Panel";
        EUILayer[EUILayer["PanelUp"] = 4] = "PanelUp";
        /**公告层 */
        EUILayer[EUILayer["Notice"] = 5] = "Notice";
        EUILayer[EUILayer["NoticeUp"] = 6] = "NoticeUp";
        /**提示 道具ui等 加载ui等 */
        EUILayer[EUILayer["Item"] = 7] = "Item";
        EUILayer[EUILayer["ItemUp"] = 8] = "ItemUp";
        /**引导最上层 */
        EUILayer[EUILayer["Guide"] = 9] = "Guide";
        EUILayer[EUILayer["GuideUp"] = 10] = "GuideUp";
        /**最上层 */
        EUILayer[EUILayer["Top"] = 11] = "Top";
        EUILayer[EUILayer["TopUp"] = 12] = "TopUp";
    })(EUILayer = apeng.EUILayer || (apeng.EUILayer = {}));
    apeng.ccenum(EUILayer);
})(apeng || (apeng = {}));

(function (apeng) {
    apeng.StorageLogic = new class {
        /**
         * 已离线了多少分钟
         */
        offlineByMinute(offlineTime) {
            let sub = this.offlineBySecond(offlineTime);
            if (sub == 0)
                return 0;
            return Math.floor(sub / 60);
        }
        /**
         * 已离线了多少小时
         */
        offlineByHour(offlineTime) {
            let sub = this.offlineBySecond(offlineTime);
            if (sub == 0)
                return 0;
            return Math.floor(sub / 60 / 60);
        }
        /**
         * 已登录了多少天
         */
        onlineByDay(onlineTime) {
            if (onlineTime <= 0)
                return 0;
            return Math.ceil(onlineTime / 60 / 60 / 24);
        }
        /**
             * 已离线了多少秒
             */
        offlineBySecond(offlineTime) {
            if (offlineTime <= 0)
                return 0;
            let now = apeng.Times.second();
            return now - offlineTime;
        }
        /**
         * 已离线了多少天
         */
        offlineByDay(offlineTime) {
            let hour = this.offlineByHour(offlineTime);
            if (hour == 0)
                return 0;
            return Math.floor(hour / 24);
        }
        /**是今天注册的玩家 */
        dayNewUser(registTime) {
            let cur = apeng.Times.getToNowDay(0);
            let regist = apeng.Times.getToNowDay(registTime);
            return cur == regist;
        }
        /**猫失踪回来还有多长时间， <= 0(回归) */
        catMissBackTime(allDuration, startTime, helpCount, helpDuration) {
            let help = helpCount * helpDuration;
            let sub = startTime + allDuration - help - apeng.Times.second();
            return sub;
        }
        /**通过缓存key 拿到枚举类型 */
        getKeyByModuleType(key) {
            let index = key.indexOf("-");
            let num = Number(key.substring(0, index));
            return num;
        }
    };
})(apeng || (apeng = {}));

(function (apeng) {
    let BannerPlatformLogic = class BannerPlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.size = { width: 0, height: 0 };
            this.isShow = false;
            this.isSimulate = false;
            this.ad = null;
            this.ad2 = null;
            this.errHide = false;
            this.curIndex = 0;
        }
        get worldTopY() { return this.size.height * (apeng.winSize().width / apeng._platform.systemInfo.screenWidth); }
        onCreate() {
            this.resetSize();
            // 自动刷新只有微信有效
            // 其他平台手动销毁创建刷新
            if (apeng._platform.config.banner.idUpdate) {
                // this.preCreate()
                let interval = apeng._platform.config.banner.refreshInterval;
                apeng._timer.loop(this, () => {
                    if (this.errHide)
                        return;
                    if (this.isShow) {
                        if (!this.ad)
                            return;
                        console.log("自动刷新banner", this.curIndex);
                        let ad = null;
                        let hideAd = null;
                        if (this.curIndex == 0) {
                            this.curIndex = 1;
                            if (this.ad2)
                                this.ad2.destroy();
                            this.ad2 = this.create(apeng._platform.config.banner.idUpdate);
                            ad = this.ad2;
                            hideAd = this.ad;
                        }
                        else {
                            this.curIndex = 0;
                            this.ad.destroy();
                            this.ad = this.create(apeng._platform.config.banner.id);
                            ad = this.ad;
                            hideAd = this.ad2;
                        }
                        if (ad) {
                            apeng._timer.once(this, () => {
                                if (this.isShow) {
                                    ad.show()
                                        .then(() => {
                                        this.isShow = true;
                                        console.log("自动刷新banner成功");
                                        // hideAd.hide()
                                    })
                                        .catch((err) => {
                                        // this.isShow = false
                                        console.log("自动刷新banner失败", err);
                                    });
                                }
                            }, .5);
                        }
                    }
                }, interval, -1, interval);
            }
        }
        resetSize() {
            let ratio = apeng._platform.config.banner.sizeRatio;
            this.size.width = apeng._platform.systemInfo.screenWidth * ratio;
            // qq banner高度小
            if (apeng._platform.type == apeng.EPlatformType.qq) {
                this.size.height = this.size.width * .24;
            }
            else {
                this.size.height = this.size.width * .3;
            }
        }
        create(id) {
            if (!apeng._platform.isIOS)
                this.resetSize();
            let bannerAd = null;
            if (this.isSimulate) {
                bannerAd = apeng.WebPlatform.IBannerCreate(id, null);
            }
            else {
                if (!id)
                    bannerAd = apeng.BasePlatform.IBannerCreate(id, null);
                else
                    bannerAd = apeng._platform.instance.IBannerCreate(id, {
                        left: (apeng._platform.systemInfo.screenWidth - this.size.width) / 2,
                        top: apeng._platform.systemInfo.screenHeight - this.size.height,
                        width: this.size.width,
                        height: this.size.height,
                    });
            }
            if (apeng._platform.type == apeng.EPlatformType.oppo)
                bannerAd.isLoading = true;
            bannerAd.onLoad(() => {
                bannerAd.isLoading = true;
                console.warn("banner ad load");
                if (apeng._platform.type != apeng.EPlatformType.oppo)
                    if (bannerAd.isLoadingByShow)
                        bannerAd.show();
            });
            bannerAd.onError((res) => {
                console.log("banner load error: ", typeof res === "object" && JSON.stringify(res));
                if (!this.errHide) {
                    if (res && res.errCode) {
                        if (res.errCode == 1004 || res.errCode == 1008) {
                            this.errHide = true;
                            // 手动调用
                            apeng._platform.bannerOrNativeTemp(apeng._platform._bannerOrNativeTempType);
                        }
                    }
                }
            });
            bannerAd.onResize((value) => {
                this.size.width = value.width;
                this.size.height = value.height;
                if (bannerAd.style && bannerAd.style.top) {
                    bannerAd.style.top = apeng._platform.systemInfo.screenHeight - this.size.height;
                }
                // 监听大小 重置banner位置
            });
            console.log("create banner ad complete", id);
            return bannerAd;
        }
        hide(complete) {
            let ad = this.getAd();
            if (!ad)
                return;
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            if (this.isShow) {
                this.isShow = false;
                ad.isLoadingByShow = false;
                let promise = ad.hide();
                if (promise)
                    promise.then(() => {
                        if (complete)
                            complete();
                    });
                console.log("banner ad hide");
            }
        }
        show(complete) {
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            let ad = this.getAd();
            if (!this.ad2)
                if (!ad)
                    ad = this.preCreate();
            if (ad) {
                if (!this.isShow) {
                    this.isShow = true;
                    if (ad.isLoading) {
                        ad.show()
                            .then(() => {
                            this.isShow = true;
                            if (complete)
                                complete();
                        })
                            .catch(() => {
                            this.isShow = false;
                        });
                        console.log("banner ad show");
                    }
                    else {
                        ad.isLoadingByShow = true;
                        console.log("banner ad show loading wait");
                    }
                }
            }
        }
        getAd() {
            // 维护使用状态
            if (this.ad2) {
                if (this.curIndex == 0)
                    return this.ad;
                else
                    return this.ad2;
            }
            return this.ad;
        }
        preCreate() {
            // 立即创建的不能马上调用显示。qq显示不出来
            this.ad = this.create(apeng._platform.config.banner.id);
            return this.ad;
        }
    };
    BannerPlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.banner)
    ], BannerPlatformLogic);
    apeng.BannerPlatformLogic = BannerPlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let BlockOncePlatformLogic = class BlockOncePlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            /**距离右上角胶囊多少 */
            this.topSpace = 10;
            this.isShow = false;
            this.ad = null;
            this.ad2 = null;
            this.curIndex = 0;
        }
        onCreate() {
            apeng._timer.once(this, () => {
                this.preCreate();
                if (apeng._platform.config.blockOnce.idUpdate) {
                    let interval = apeng._platform.config.blockOnce.refreshInterval;
                    apeng._timer.loop(this, () => {
                        if (this.isShow) {
                            if (!this.ad)
                                return;
                            console.log("自动刷新积木广告", this.curIndex);
                            let ad = null;
                            let hideAd = null;
                            if (this.curIndex == 0) {
                                this.curIndex = 1;
                                if (this.ad2)
                                    this.ad2.destroy();
                                this.ad2 = this.create(apeng._platform.config.blockOnce.idUpdate);
                                ad = this.ad2;
                                hideAd = this.ad;
                            }
                            else {
                                this.curIndex = 0;
                                this.ad.destroy();
                                this.ad = this.create(apeng._platform.config.blockOnce.id);
                                ad = this.ad;
                                hideAd = this.ad2;
                            }
                            if (ad) {
                                apeng._timer.once(this, () => {
                                    if (this.isShow) {
                                        ad.show()
                                            .then(() => {
                                            this.isShow = true;
                                            console.log("自动刷新积木广告成功");
                                            hideAd.hide();
                                        })
                                            .catch((err) => {
                                            // this.isShow = false
                                            console.log("自动刷新积木广告失败", err);
                                        });
                                    }
                                }, .5);
                            }
                        }
                    }, interval, -1, interval);
                }
            }, 1.5);
        }
        create(id) {
            let ad = null;
            if (!id)
                ad = apeng.BasePlatform.IBlockOnceCreate(id);
            else
                ad = apeng._platform.instance.IBlockOnceCreate(id);
            ad.onLoad(() => {
                ad.isLoading = true;
                console.log("BlockOnce ad load");
                if (ad.isLoadingByShow)
                    ad.show();
            });
            ad.onError((res) => {
                console.log("BlockOnce load error: ", typeof res === "object" && JSON.stringify(res));
            });
            console.log("create BlockOnce ad complete", id);
            return ad;
        }
        hide(complete) {
            let ad = this.getAd();
            if (!ad)
                return;
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            if (this.isShow) {
                this.isShow = false;
                ad.isLoadingByShow = false;
                let promise = ad.hide();
                if (promise)
                    promise.then(() => {
                        if (complete)
                            complete();
                    });
                console.log("BlockOnce ad hide");
            }
        }
        show(complete) {
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            let ad = this.getAd();
            if (!this.ad2)
                if (!ad)
                    ad = this.preCreate();
            if (ad) {
                if (!this.isShow) {
                    this.isShow = true;
                    if (ad.isLoading) {
                        ad.show()
                            .then(() => {
                            this.isShow = true;
                            if (complete)
                                complete();
                        })
                            .catch(() => {
                            this.isShow = false;
                        });
                        console.log("BlockOnce ad show");
                    }
                    else {
                        ad.isLoadingByShow = true;
                        console.log("BlockOnce ad show loading wait");
                    }
                }
            }
        }
        getAd() {
            // 维护使用状态
            if (this.ad2) {
                if (this.curIndex == 0)
                    return this.ad;
                else
                    return this.ad2;
            }
            return this.ad;
        }
        preCreate() {
            // 立即创建的不能马上调用显示。qq显示不出来
            if (!this.ad)
                this.ad = this.create(apeng._platform.config.blockOnce.id);
            return this.ad;
        }
    };
    BlockOncePlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.blockOnce)
    ], BlockOncePlatformLogic);
    apeng.BlockOncePlatformLogic = BlockOncePlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let InterstitialPlatformLogic = class InterstitialPlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.isSimulate = false;
            this.lastShowTime = null;
            this.callBack = null;
            this.idByIndex = 0;
            this.ads = [];
        }
        onCreate() {
            // this.pre()
        }
        create(id) {
            let interstitialAd = null;
            if (this.isSimulate)
                interstitialAd = apeng.WebPlatform.IInterstitialCreate(id);
            else {
                if (!id) {
                    interstitialAd = apeng.BasePlatform.IInterstitialCreate(id);
                }
                else
                    interstitialAd = apeng._platform.instance.IInterstitialCreate(id);
            }
            console.log("create interstitial: " + id);
            if (interstitialAd.onLoad)
                interstitialAd.onLoad(() => {
                    console.log("interstitial load");
                });
            if (interstitialAd.onError)
                interstitialAd.onError((res) => {
                    console.log("banner load error: ", typeof res === "object" && JSON.stringify(res));
                    if (this.callBack)
                        this.callBack();
                    this.callBack = null;
                });
            if (interstitialAd.onClose)
                interstitialAd.onClose((res) => {
                    console.log("interstitial close: ", res);
                    if (this.callBack)
                        this.callBack();
                    this.callBack = null;
                });
            return interstitialAd;
        }
        getAd(addIndex) {
            // 循环使用id
            let ids = apeng._platform.config.interstitial.id;
            let index = this.idByIndex % ids.length;
            if (addIndex)
                this.idByIndex++;
            let ad = this.ads[index];
            if (!ad) {
                ad = this.create(ids[index]);
                this.ads[index] = ad;
            }
            return ad;
        }
        pre() {
            this.getAd(false);
        }
        show(closeCb) {
            let curTime = apeng.Times.second();
            if (this.lastShowTime == null)
                this.lastShowTime = apeng._platform.initTime;
            let sub = curTime - this.lastShowTime;
            if (sub >= apeng._platform.config.interstitial.coolingTime) {
                this.lastShowTime = curTime;
                this.callBack = closeCb;
                if (!this.getAd(false) || !apeng._platform.hasOpenAd() || !apeng._platform.isNetWork) {
                    if (this.callBack)
                        this.callBack();
                    this.callBack = null;
                    return;
                }
                let interstitialAd = this.getAd(true);
                if (interstitialAd.load)
                    interstitialAd.load()
                        .then(() => {
                        interstitialAd.show();
                    })
                        .catch(() => {
                        apeng._timer.once(null, () => {
                            this.getAd(true).show();
                        }, 1);
                    });
                else {
                    interstitialAd.show();
                }
            }
            else {
                console.log("interstitial cooling: ", apeng._platform.config.interstitial.coolingTime - sub);
            }
        }
    };
    InterstitialPlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.interstitial)
    ], InterstitialPlatformLogic);
    apeng.InterstitialPlatformLogic = InterstitialPlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let NativeTempPlatformLogic = class NativeTempPlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.ad = null;
            this.adRoot = null;
            this.adOffsetY = null;
            this.adRootOffsetY = -200;
            this.isSimulate = false;
            this.isShow = false;
            this.isShowRoot = false;
        }
        onCreate() {
            // 预加载原生
            if (apeng._platform.type == apeng.EPlatformType.oppo) {
                apeng._timer.once(this, () => {
                    this.pre();
                }, .2);
            }
        }
        // 常驻显示的原生
        showRoot() {
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            if (!this.adRoot)
                this.preRoot();
            if (this.adRoot)
                if (!this.isShowRoot) {
                    this.isShowRoot = true;
                    if (this.adRoot.isLoading) {
                        this.adRoot.show()
                            .then(() => {
                            this.isShowRoot = true;
                        })
                            .catch(() => {
                            this.isShowRoot = false;
                        });
                        console.log("nativeTemp adRoot show");
                    }
                    else {
                        this.adRoot.isLoadingByShow = true;
                        console.log("nativeTemp adRoot show loading wait");
                    }
                }
        }
        hideRoot(complete) {
            if (!this.adRoot)
                return;
            if (!apeng._platform.hasOpenAd())
                return;
            if (this.isShowRoot) {
                this.isShowRoot = false;
                this.adRoot.isLoadingByShow = false;
                let promise = this.adRoot.hide();
                if (promise)
                    promise.then(() => {
                        if (complete)
                            complete();
                        console.log("nativeTemp ad hide");
                    });
            }
        }
        create(id, centerOffset) {
            // 官方文档尺寸
            let w = 375;
            let h = 106;
            let systemInfo = apeng._platform.systemInfo;
            let nativeAd = null;
            if (this.isSimulate) {
                nativeAd = apeng.WebPlatform.INativeTempCreate("", 1);
            }
            else {
                if (!id)
                    nativeAd = apeng.BasePlatform.INativeTempCreate("", 1);
                else
                    // 默认底部居中
                    nativeAd = apeng._platform.instance.INativeTempCreate(id, apeng._platform.config.nativeTemp.refreshInterval, centerOffset);
            }
            if (apeng._platform.type == apeng.EPlatformType.oppo)
                nativeAd.isLoading = true;
            nativeAd.onLoad(() => {
                nativeAd.isLoading = true;
                console.warn("nativeTemp ad load");
                if (apeng._platform.type != apeng.EPlatformType.oppo)
                    if (nativeAd.isLoadingByShow)
                        nativeAd.show();
            });
            nativeAd.onError((err) => {
                console.warn("nativeTemp error: ", err);
            });
            console.log("create nativeTemp complete: ", nativeAd, id);
            return nativeAd;
        }
        hide(complete) {
            if (!this.ad)
                return;
            if (!apeng._platform.hasOpenAd())
                return;
            if (this.isShow) {
                this.isShow = false;
                this.ad.isLoadingByShow = false;
                let promise = this.ad.hide();
                if (promise)
                    promise.then(() => {
                        if (complete)
                            complete();
                        console.log("nativeTemp ad hide");
                    });
            }
        }
        pre() {
            this.ad = this.create(apeng._platform.config.nativeTemp.id, this.adOffsetY);
        }
        preRoot() {
            this.adRoot = this.create(apeng._platform.config.nativeTemp.idRoot, this.adRootOffsetY);
        }
        show(complete) {
            if (!apeng._platform.hasOpenAd())
                return;
            if (!apeng._platform.isNetWork)
                return;
            if (!this.ad)
                this.pre();
            if (this.ad)
                if (!this.isShow) {
                    this.isShow = true;
                    if (this.ad.isLoading) {
                        this.ad.show()
                            .then(() => {
                            this.isShow = true;
                            if (complete)
                                complete();
                        })
                            .catch(() => {
                            this.isShow = false;
                        });
                        console.log("nativeTemp ad show");
                    }
                    else {
                        this.ad.isLoadingByShow = true;
                        console.log("nativeTemp ad show loading wait");
                    }
                }
        }
    };
    NativeTempPlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.nativeTemp)
    ], NativeTempPlatformLogic);
    apeng.NativeTempPlatformLogic = NativeTempPlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let RecordPlatformLogic = class RecordPlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.isSimulate = false;
            this.viodeTime = -1;
            this.recordering = false;
            this.active = false;
            this.stoping = false;
            this.videoPath = "";
            this.getvideo = false;
            this._isEvent = false;
            this.record = null;
        }
        onCreate() {
            this.record = this.isSimulate ? apeng.WebPlatform.IRecordMgr() : apeng._platform.instance.IRecordMgr();
        }
        stop() {
            console.log("stop", this.active);
            if (this.recordering == false)
                return;
            console.log('结束录制');
            this.recordering = false;
            this.stoping = true;
            this.record.stop();
        }
        getSharePath() {
            return this.videoPath;
        }
        start(duration = 280) {
            if (!this._isEvent) {
                this._isEvent = true;
                this.record.onStart((res) => {
                    console.log("onStart", res);
                    this.videoPath = "";
                });
                this.record.onStop((res) => {
                    var that = this;
                    this.videoPath = res.videoPath;
                    console.log(" this.videoPath", this.videoPath);
                    this.getvideo = false;
                    //如果录制了精彩时刻，则视频不做其他剪切
                    console.log('onStop', this.viodeTime, res.videoPath);
                    if (this.viodeTime > 0) {
                        this.record.clipVideo({
                            path: res.videoPath,
                            timeRange: [3, 0],
                            success(r) {
                                that.videoPath = r.videoPath;
                                console.log('videoPath', that.videoPath);
                                if (that.getvideo == true) {
                                    // UIHelp.showTip('视频制作完成！');
                                    console.log(r.videoPath);
                                }
                            },
                            complete() {
                                that.stoping = false;
                                if (that.recordering) {
                                    console.log("结束完成，刷新录制");
                                    that.start();
                                }
                            }
                        });
                    }
                    else {
                        this.record.clipVideo({
                            path: res.videoPath,
                            timeRange: [120, 0],
                            success(r) {
                                that.videoPath = r.videoPath;
                                console.log('videoPath', that.videoPath);
                                if (that.getvideo == true) {
                                    console.log(r.videoPath);
                                }
                            },
                            complete() {
                                that.stoping = false;
                                if (that.recordering) {
                                    console.log("结束完成，刷新录制");
                                    that.start();
                                }
                            },
                            fail(e) {
                                console.error("recorder fail", e);
                            }
                        });
                    }
                });
                this.record.onError((res) => {
                    console.log("onError", res);
                });
            }
            this.recordering = true;
            if (this.stoping) {
                console.log('录制开始被打断，正在剪切视频');
                return;
            }
            console.log('录制开始');
            this.viodeTime = 0;
            this.record.start({
                duration,
            });
        }
        pause() {
            this.record.pause();
        }
        resume() {
            this.record.resume();
        }
    };
    RecordPlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.record)
    ], RecordPlatformLogic);
    apeng.RecordPlatformLogic = RecordPlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let RewardedVideoPlatformLogic = class RewardedVideoPlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.isSimulate = false;
            this.ad = null;
            this.adOnce = null;
            this.callBack = null;
            this.reportName = "";
            this.showTime = -1;
            this.pause = false;
            this._lastShowByCloseTime = -1;
            this.reprotAddress = "";
        }
        onCreate() {
            apeng._main.on(apeng._main.EventType.NEW_DAY, () => {
                this.storage.delete("idOnceToDay");
            });
        }
        create(id) {
            let ad = null;
            if (this.isSimulate) {
                ad = apeng.WebPlatform.IRewardedVideoCreate(id);
            }
            else {
                if (!id)
                    ad = apeng.BasePlatform.IRewardedVideoCreate(id);
                else
                    ad = apeng._platform.instance.IRewardedVideoCreate(id);
            }
            console.log("create rewardedVideo componnt: " + id);
            ad.onLoad((res) => {
                console.log("rewardedVideo load complete: ", res);
            });
            ad.onError((res) => {
                console.log("rewardedVideo load error: ", res, typeof res == "object" || JSON.stringify(res));
                this.error();
                this.report(3, "错误码" + (res ? (res["errCode"] || -1) : -1));
            });
            ad.onClose((res) => {
                this._lastShowByCloseTime = apeng.Times.second();
                if (this.callBack) {
                    // 成功需要达到固定时间 防止破解版
                    if (!apeng._platform.openWebSimulationUI)
                        if (!ad.isSimulate && apeng.Times.second() - this.showTime < 2.9)
                            res.isEnded = false;
                    if (res.isEnded) {
                        this.callBack(apeng.ERewardVideoState.Finish);
                        this.report(1);
                    }
                    else {
                        this.callBack(apeng.ERewardVideoState.Close);
                        this.report(2);
                    }
                }
                apeng._timer.once(this, this.clearShowData, .1);
            });
            return ad;
        }
        getLastShowByCloseTime() {
            return this._lastShowByCloseTime;
        }
        /**视频正在加载中 */
        isLoaded() {
            return !!this.callBack;
        }
        /**
         * 精简调起接口，其他状态时自动弹出提示
         * @param report 视频打点
         * @param cb 看完时回调
         */
        showByFinish(report, cb, failCb) {
            // if (this.isLoaded()) {
            // 	_ui.tip(_language.get(30001))
            // 	if (failCb)
            // 		failCb()
            // }
            // else
            this.show(report, (state) => {
                switch (state) {
                    case apeng.ERewardVideoState.Finish:
                        if (cb)
                            cb();
                        break;
                    case apeng.ERewardVideoState.Close:
                        apeng._ui.tip(apeng._language.get(30002));
                        if (failCb)
                            failCb();
                        break;
                    case apeng.ERewardVideoState.Error:
                        apeng._ui.tip(apeng._language.get(30003));
                        if (failCb)
                            failCb();
                        break;
                }
            });
        }
        report(type, str) {
            let scene = "", value = "";
            if (this.reprotAddress)
                if (this.reprotAddress.indexOf(",") != -1) {
                    let arr = this.reprotAddress.split(",");
                    scene = arr[0];
                    value = arr[1];
                }
                else
                    scene = this.reprotAddress;
            if (str)
                value += ("-" + str);
            apeng._platform.instance.reportEvent("viode", {
                scene,
                type,
                value,
            });
        }
        error() {
            if (this.callBack) {
                this.callBack(apeng.ERewardVideoState.Error);
                this.clearShowData();
            }
        }
        getAd() {
            let ad = this.ad;
            // 每天第一次
            if (this.adOnce)
                if (this.storage.get("idOnceToDay", "false") == "false") {
                    this.storage.set("idOnceToDay", "true");
                    ad = this.adOnce;
                    console.log("每日第一次使用广告id", apeng._platform.config.rewardedVideo.idOnce);
                }
            return ad;
        }
        preCreate() {
            if (this.ad)
                return this.ad;
            this.ad = this.create(apeng._platform.config.rewardedVideo.id);
            let idOnce = apeng._platform.config.rewardedVideo.idOnce;
            if (idOnce)
                this.adOnce = this.create(idOnce);
            return this.ad;
        }
        /**
         * 拉起激励视频广告
         * @param report 视频汇报点， ,号分割value字段
         * @param cb
         * @returns
         */
        show(report, cb) {
            this.reprotAddress = report;
            this.report(0);
            if (apeng._platform.config.rewardedVideo.isSuccess) {
                if (cb)
                    cb(apeng.ERewardVideoState.Finish);
                return;
            }
            // 限制次数
            if (apeng._platform.getDayAd("showRewardedVideo").count >= apeng._platform.config.rewardedVideo.showMaxCount
                || !apeng._platform.isNetWork) {
                if (cb)
                    cb(apeng.ERewardVideoState.Error);
                return;
            }
            apeng._platform.addDayAdCount("showRewardedVideo");
            this.showTime = apeng.Times.second();
            let ad = this.getAd();
            if (!ad)
                ad = this.preCreate();
            this.callBack = cb;
            this.reportName = report;
            this.pause = false;
            let fn = () => {
                // 关闭背景音乐 小游戏可能存在播放视频时 还在播放背景音乐
                if (!this.pause) {
                    apeng._audio.pauseAll();
                    apeng._platform._record_.pause();
                    this.pause = true;
                }
                if (ad.show)
                    ad.show();
            };
            let promise = ad.load();
            if (promise)
                promise
                    .then(fn);
            else
                fn();
        }
        clearShowData() {
            this.callBack = null;
            this.reportName = "";
            if (this.pause) {
                this.pause = false;
                apeng._audio.resumeAll();
                apeng._platform._record_.resume();
            }
        }
    };
    RewardedVideoPlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.rewardedVideo)
    ], RewardedVideoPlatformLogic);
    apeng.RewardedVideoPlatformLogic = RewardedVideoPlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let SharePlatformLogic = class SharePlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.isSimulate = false;
            this.share = null;
        }
        onCreate() {
            this.share = this.isSimulate ? apeng.WebPlatform.IShare() : apeng._platform.instance.IShare();
        }
        getData() {
            if (!apeng._platform.config.share)
                return apeng.TShare.ParamDefault;
            let list = apeng._platform.config.share.list;
            if (Array.isArray(list)) {
                if (list.length == 0)
                    return apeng.TShare.ParamDefault;
                return apeng.Sets.random(list);
            }
            return {
                title: apeng.Sets.random(list.title),
                imageUrl: apeng.Sets.random(list.imgUrl)
            };
        }
        onShareAppMessage(param) {
            // 查找是分包的图片
            let path = "";
            if (apeng._platform.config.share) {
                let list = apeng._platform.config.share.list;
                if (Array.isArray(list)) {
                    for (let v of list) {
                        path = this.getImgUrlByPath(v.imageUrl);
                        if (path)
                            break;
                    }
                }
                else {
                    for (let v of list.imgUrl) {
                        path = this.getImgUrlByPath(v);
                        if (path)
                            break;
                    }
                }
            }
            this.share.onShareAppMessage(path, param);
        }
        getImgUrlByPath(url) {
            let path = "";
            if (!url)
                return path;
            let pac = "subpackages";
            if (url.indexOf(pac) == -1)
                return path;
            let index = url.indexOf("/");
            if (index != -1) {
                let end = url.indexOf("/", index + 1);
                if (end != -1) {
                    path = url.substring(index + 1, end);
                }
            }
            return path;
        }
        show(value, cb) {
            if (!value)
                value = this.getData();
            this.share.show(value, cb);
        }
        /**
         * 朋友圈
         */
        circleFriends(value, cb, query) {
            if (!value)
                value = this.getData();
            if (query)
                value.query = "query=" + query;
            if (!this.share.circleFriends) {
                if (cb)
                    cb(false);
                return;
            }
            this.share.circleFriends(value, cb);
        }
    };
    SharePlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.share)
    ], SharePlatformLogic);
    apeng.SharePlatformLogic = SharePlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    let VibratePlatformLogic = class VibratePlatformLogic extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            this.vibrate = null;
        }
        get isOpen() { return this.storage.get("VibratePlatformLogic.setVibrate", "true") == "true"; }
        onCreate() {
            this.vibrate = apeng._platform.instance.IVibrate();
        }
        /**开启振动 */
        setOpen(open) {
            this.storage.set("VibratePlatformLogic.setVibrate", open ? "true" : "false");
        }
        /**短振动 */
        short() {
            if (!this.isOpen)
                return;
            this.vibrate.short();
        }
        /**长振动 */
        long() {
            if (!this.isOpen)
                return;
            this.vibrate.long();
        }
    };
    VibratePlatformLogic = __decorate([
        apeng.platformLogicMgr.add(apeng.EPlatformLogicType.vibrate)
    ], VibratePlatformLogic);
    apeng.VibratePlatformLogic = VibratePlatformLogic;
})(apeng || (apeng = {}));

(function (apeng) {
    class BasePlatform extends apeng.BaseModule {
        constructor() {
            super(...arguments);
            /**平台接口名 */
            this.root = null;
            this.shareAppMessageCallBack = null;
        }
        static IRecordMgr() {
            return {
                clipVideo: (obj) => {
                    if (obj) {
                        if (obj.success)
                            obj.success({ videoPath: "test" });
                        if (obj.complete)
                            obj.complete({ videoPath: "test" });
                    }
                },
                start: (value) => { },
                resume: () => { },
                pause: () => { },
                stop: () => { },
                onStart: (cb) => { },
                onPause: (cb) => { },
                onResume: (cb) => { },
                onStop: (cb) => { },
                onError: (cb) => { },
            };
        }
        static IOpenDataContext() {
            return {
                set: (value) => { },
                startRender: (param) => { },
                updateRender: (index) => { },
            };
        }
        static IInterstitialCreate(id) {
            return {
                onLoad: (cb) => { },
                onError: (cb) => { },
                onClose: (cb) => { },
                load: () => new Promise(res => res(null)),
                show: () => new Promise(res => res(null)),
                destroy: () => { },
            };
        }
        static INativeTempCreate(id, interval, centerOffset = 0) {
            return {
                isShow: () => true,
                show: () => new Promise(res => res(null)),
                hide: () => new Promise(res => res(null)),
                onLoad: (cb) => { },
                onError: (cb) => { },
                onHide: (cb) => { },
                onClose: (cb) => { },
                destroy: () => { },
            };
        }
        static IBannerCreate(id, style) {
            return {
                destroy: () => { },
                show: () => new Promise(res => res(null)),
                hide: () => new Promise(res => res(null)),
                onLoad: (cb) => { },
                onError: (cb) => { },
                onHide: (cb) => { },
                onResize: (cb) => { },
                style: {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                }
            };
        }
        static IBlockOnceCreate(id) {
            return {
                destroy: () => { },
                show: () => new Promise(res => res(null)),
                hide: () => new Promise(res => res(null)),
                onLoad: (cb) => { },
                onError: (cb) => { },
                onHide: (cb) => { },
                onResize: (cb) => { },
                style: {
                    left: 0,
                    top: 0,
                }
            };
        }
        reportEvent(key, obj) {
        }
        /**
       * 登陆接口 获取 js-code ，5分钟后失效
       * 用作获取 openid
       * @param {(code: string) => void} cb
       */
        static login(cb) {
            apeng._timer.callLater(this, () => {
                if (cb)
                    cb("success");
            });
        }
        static IRewardedVideoCreate(id) {
            let event = new apeng.EventDispatcher();
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb);
                },
                onError: (cb) => {
                    event.on("onError", cb);
                },
                onClose: (cb) => {
                    event.on("onClose", cb);
                },
                load: () => new Promise(res => {
                    res(null);
                    event.emit("onLoad");
                }),
                show: () => new Promise(res => {
                    res(null);
                    event.emit("onClose", { isEnded: true });
                }),
            };
        }
        static IShare() {
            return {
                onShareAppMessage: () => {
                },
                show: (value, cb, query) => {
                    if (cb)
                        cb(true);
                },
                circleFriends: (value, cb, query) => {
                    if (cb)
                        cb(true);
                }
            };
        }
        static getSystemInfoSync() {
            let out = {};
            out.brand = apeng.sys.platform;
            out.model = apeng.sys.os;
            out.screenWidth = apeng.winSize().width;
            out.screenHeight = apeng.winSize().height;
            out.version = apeng.sys.osVersion;
            out.SDKVersion = apeng.sys.osMainVersion + "";
            out.pixelRatio = screen.pixelDepth || screen;
            return out;
        }
        static getLaunchOptionsSync() {
            let out = {};
            return out;
        }
        static IVibrate() {
            return {
                short: () => { },
                long: () => { },
            };
        }
        static getUserInfo(cb) {
            apeng._timer.callLater(this, () => {
                cb({
                    name: "",
                    avatarUrl: "",
                    age: -1,
                    city: ""
                });
            });
        }
        login(cb) { BasePlatform.login(cb); }
        IRewardedVideoCreate(id) { return BasePlatform.IRewardedVideoCreate(id); }
        IRecordMgr() { return BasePlatform.IRecordMgr(); }
        INativeTempCreate(id, interval, centerOffset = 0) { return BasePlatform.INativeTempCreate(id, interval, centerOffset); }
        IBannerCreate(id, style) { return BasePlatform.IBannerCreate(id, style); }
        IInterstitialCreate(id) { return BasePlatform.IInterstitialCreate(id); }
        IShare() { return BasePlatform.IShare(); }
        IVibrate() { return BasePlatform.IVibrate(); }
        IBlockOnceCreate(id) { return BasePlatform.IBlockOnceCreate(id); }
        reStart() {
            apeng.game.restart();
        }
        getSystemInfoSync() { return BasePlatform.getSystemInfoSync(); }
        getUserInfo(cb) { BasePlatform.getUserInfo(cb); }
        getLaunchOptionsSync() { return BasePlatform.getLaunchOptionsSync(); }
        payShow(count, cb) {
            cb("success");
        }
        /**
         * 保存成图片
         * @param width
         * @param height
         * @param buffer
         * @param cb
         * @param saveLocal 保存到本地相册，默认 false
         */
        saveImg(width, height, buffer, cb, saveLocal) {
            if (cb)
                cb("");
        }
        getSaveImgName() { return "app-" + apeng.Times.toLocaleString(undefined, true, "-"); }
        // 隐私协议 点击同意
        privacyConfirm(complete) {
            complete();
        }
        IOpenDataContext() {
            return BasePlatform.IOpenDataContext();
        }
        onShow(cb) {
            apeng.game.on(apeng.Game.EVENT_SHOW, cb);
        }
        onHide(cb) {
            apeng.game.on(apeng.Game.EVENT_HIDE, cb);
        }
        killGame() {
            apeng.game.end();
        }
        /**获取设备唯一标识码 */
        getSystemId(cb) {
            let cacheCode = localStorage.getItem("brower_systemid_test");
            if (!cacheCode) {
                cacheCode = (Math.random() + Date.now()).toString(32);
                localStorage.setItem("brower_systemid_test", cacheCode);
            }
            return cb && cb(cacheCode);
        }
        getSetting(cb) {
            cb(null);
        }
    }
    apeng.BasePlatform = BasePlatform;
})(apeng || (apeng = {}));
/// <reference path="./BasePlatform.ts" />

(function (apeng) {
    class BaseMingamePlatform extends apeng.BasePlatform {
        constructor() {
            super(...arguments);
            this.root = window["qq"];
        }
        IRecordMgr() {
            if (apeng._platform.isIDE)
                return apeng.BasePlatform.IRecordMgr();
            if (!this.root.getGameRecorderManager)
                return apeng.BasePlatform.IRecordMgr();
            return this.root.getGameRecorderManager();
        }
        IRewardedVideoCreate(id) {
            return this.root.createRewardedVideoAd({ adUnitId: id });
        }
        IInterstitialCreate(id) {
            if (!this.root.createInterstitialAd)
                return apeng.BasePlatform.IInterstitialCreate(id);
            return this.root.createInterstitialAd({ adUnitId: id });
        }
        IBannerCreate(id, style) {
            return this.root.createBannerAd({
                adUnitId: id,
                style,
                adIntervals: apeng._platform.config.banner.refreshInterval,
            });
        }
        IVibrate() {
            return {
                short: () => {
                    this.root.vibrateShort({
                        type: "heavy"
                    });
                },
                long: () => {
                },
            };
        }
        reportEvent(key, obj) {
            if (!this.root.reportEvent)
                return;
            this.root.reportEvent(key, obj);
        }
        getLaunchOptionsSync() {
            return this.root.getLaunchOptionsSync();
        }
        loadShareImg(path, complete, delay = -1) {
            // 主动加载分包
            if (!this.isLoadShareCache()) {
                this.storage.get("shareImgLoad", "true");
                this.root.loadSubpackage({
                    name: path,
                    complete
                });
            }
            else
                complete();
        }
        isLoadShareCache() {
            if (this.storage.get("shareImgLoad", "false") == "false")
                return false;
            return true;
        }
        getSystemInfoSync() {
            let value = this.root.getSystemInfoSync();
            let out = {};
            out.brand = value.brand;
            out.model = value.model;
            out.screenWidth = value.screenWidth;
            out.screenHeight = value.screenHeight;
            out.version = value.COREVersion;
            out.SDKVersion = value.platformVersionCode;
            out.pixelRatio = value.pixelRatio;
            out.navbarPosition = value.navbarPosition;
            return out;
        }
        login(cb) {
            this.root.login({
                success: (res) => {
                    if (cb)
                        cb(res.code);
                },
                fail: () => {
                    if (cb)
                        cb("");
                }
            });
        }
        onShow(cb) {
            this.root.onShow(cb);
        }
        onHide(cb) {
            this.root.onHide(cb);
        }
        reStart() {
            this.root.restartMiniProgram();
        }
        killGame() {
            this.root.exitMiniProgram();
        }
    }
    apeng.BaseMingamePlatform = BaseMingamePlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let A360Platform = class A360Platform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["MINIGAMEAD"];
            this.testId = false;
        }
        IRewardedVideoCreate(id) {
            let _root = window["REWARD_VIDEO_AD"];
            if (!_root || !_root.createRewardedVideoAd)
                return apeng.BasePlatform.IRewardedVideoCreate(id);
            if (this.testId)
                id = "nIg2BB";
            let ad = _root.createRewardedVideoAd({
                adUnitId: id,
            });
            return ad;
        }
        IBlockOnceCreate(id) {
            if (!this.root || !this.root.renderShopWindow)
                return apeng.BasePlatform.IBlockOnceCreate(id);
            if (this.testId)
                id = "sL9Jkr";
            let event = new apeng.EventDispatcher();
            let show = () => new Promise((res, rej) => {
                this.root.renderShopWindow({
                    showid: id,
                    adDomId: "frontAdBoxOnce",
                    width: "300",
                    height: "300",
                    onSuccess: res,
                    onFail: (err) => {
                        rej(err);
                        event.emit("onError", err);
                    }
                });
            });
            apeng._timer.once(this, show, .2);
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb);
                },
                onError: (cb) => {
                    event.on("onError", cb);
                },
                onHide: (cb) => {
                    event.on("onHide", cb);
                },
                onResize: (cb) => {
                    event.on("onResize", cb);
                },
                show,
                hide: () => {
                    // 无关闭
                    return null;
                },
                destroy: () => {
                },
            };
        }
        IInterstitialCreate(id) {
            if (!this.root || !this.root.renderShopWindow)
                return apeng.BasePlatform.IInterstitialCreate(id);
            if (this.testId)
                id = "sL9Jkr";
            let event = new apeng.EventDispatcher();
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb);
                },
                onError: (cb) => {
                    event.on("onError", cb);
                },
                onClose: (cb) => {
                    event.on("onClose", cb);
                },
                load: () => new Promise(res => {
                    apeng._timer.callLater(this, () => {
                        res(null);
                        event.emit("onLoad");
                    });
                }),
                show: () => new Promise((res, rej) => {
                    this.root.renderShopWindow({
                        showid: id,
                        adDomId: "frontAdBox",
                        width: "380",
                        height: "380",
                        onSuccess: res,
                        onFail: (err) => {
                            rej(err);
                            event.emit("onError", err);
                        }
                    });
                }),
                destroy: () => {
                },
            };
        }
        IBannerCreate(id, style) {
            if (!this.root || !this.root.renderInfoFlow)
                return apeng.BasePlatform.IBannerCreate(id, style);
            if (this.testId)
                id = "0GcxwV";
            let event = new apeng.EventDispatcher();
            let allWidth = 300;
            let allHeight = 300;
            let doc = window.document;
            if (doc && doc.body) {
                if (doc.clientWidth)
                    allWidth = doc.body.clientWidth;
                if (doc.clientHeight)
                    allHeight = doc.body.clientHeight;
            }
            let show = () => new Promise((res, rej) => {
                this.root.renderInfoFlow({
                    showid: id,
                    adDomId: "feedAdBoxBottom",
                    width: allWidth + "",
                    onSuccess: res,
                    onFail: (err) => {
                        rej(err);
                        event.emit("onError", err);
                    }
                });
                console.log("显示banner广告------------");
            });
            apeng._timer.once(this, show, .2);
            return {
                destroy: () => {
                },
                show,
                hide: () => {
                    // 无关闭
                    return null;
                },
                onLoad: (cb) => {
                    event.on("onLoad", cb);
                },
                onError: (cb) => {
                    event.on("onError", cb);
                },
                onHide: (cb) => {
                    event.on("onHide", cb);
                },
                onResize: (cb) => {
                    event.on("onResize", cb);
                },
            };
        }
    };
    A360Platform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.a360)
    ], A360Platform);
    apeng.A360Platform = A360Platform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />
/// <reference path="./BasePlatform.ts" />

(function (apeng) {
    class BaseAndroidPlatform extends apeng.BasePlatform {
        static IVibrate() {
            return {
                short: () => {
                    apeng._platform.sendToNative(apeng.ENativeSend.openVibrator);
                    apeng._timer.once(null, () => {
                        apeng._platform.sendToNative(apeng.ENativeSend.hideVibrator);
                    }, 15 / 1000);
                },
                long: () => {
                    apeng._platform.sendToNative(apeng.ENativeSend.openVibrator);
                    apeng._timer.once(null, () => {
                        apeng._platform.sendToNative(apeng.ENativeSend.hideVibrator);
                    }, 30 / 1000);
                },
            };
        }
        // 隐私协议 点击同意
        static privacyConfirm(complete) {
            apeng._platform.once(apeng.ENativeReceive.privacyConfirmComplete, complete);
            apeng._platform.sendToNative(apeng.ENativeSend.privacyConfirm);
        }
        static saveImg(width, height, buffer, cb, saveLocal) {
            let ablePath = apeng.native.fileUtils.getWritablePath();
            // let fileName = saveLocal ? (this.getSaveImgName() + ".png") : "renderTexture.png"
            let fileName = "renderTexture.png";
            let fillPath = ablePath + fileName;
            //--删除该文件，存在即删除
            // if (!saveLocal)
            apeng.native.fileUtils.removeFile(fillPath);
            apeng.native.saveImageData(buffer, width, height, fillPath)
                .then(() => {
                if (saveLocal) {
                    apeng._platform.once(apeng.ENativeReceive.downLoadSaveImgResult, (res) => {
                        cb(fillPath);
                    }, null);
                    apeng._platform.sendToNative(apeng.ENativeSend.downloadsaveimg, fillPath);
                }
                else {
                    return cb(fillPath);
                }
            }).catch(() => {
                return cb("");
            });
        }
        IVibrate() { return BaseAndroidPlatform.IVibrate(); }
        privacyConfirm(complete) { BaseAndroidPlatform.privacyConfirm(complete); }
        saveImg(width, height, buffer, cb, saveLocal) {
            BaseAndroidPlatform.saveImg(width, height, buffer, cb, saveLocal);
        }
        IRewardedVideoCreate(id) {
            let event = new apeng.EventDispatcher();
            apeng._platform.sendToNative(apeng.ENativeSend.rewardedVideoCreate, id);
            apeng._platform.on(apeng.ENativeReceive.rewardVideoError, (res) => {
                event.emit("onError", res);
            }, null);
            apeng._platform.on(apeng.ENativeReceive.rewardVideoLoaded, (res) => {
                event.emit("onLoad", res);
            }, null);
            let showRes = null;
            apeng._platform.on(apeng.ENativeReceive.rewardVideoShowed, (res) => {
                if (showRes) {
                    showRes(null);
                    showRes = null;
                }
            }, null);
            apeng._platform.on(apeng.ENativeReceive.rewardVideoClose, (res) => {
                event.emit("onClose", { isEnded: res == "true" });
            }, null);
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onClose: (cb) => {
                    event.on("onClose", cb, null);
                },
                load: () => new Promise(res => {
                    res(null);
                }),
                show: () => new Promise(res => {
                    showRes = res;
                    apeng._platform.sendToNative(apeng.ENativeSend.rewardedVideoShow, id);
                }),
            };
        }
        IInterstitialCreate(id) {
            let event = new apeng.EventDispatcher();
            apeng._platform.sendToNative(apeng.ENativeSend.interstitialCreate, id);
            apeng._platform.on(apeng.ENativeReceive.interstitialError, (res) => {
                event.emit("onError", res);
            }, null);
            let loadRes = null;
            apeng._platform.on(apeng.ENativeReceive.interstitialLoaded, (res) => {
                if (loadRes) {
                    loadRes(null);
                    loadRes = null;
                }
                event.emit("onLoad", res);
            }, null);
            let showRes = null;
            apeng._platform.on(apeng.ENativeReceive.interstitialShow, (res) => {
                if (showRes) {
                    showRes(null);
                    showRes = null;
                }
            }, null);
            apeng._platform.on(apeng.ENativeReceive.interstitialClose, (res) => {
                event.emit("onClose", res);
            }, null);
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onClose: (cb) => {
                    event.on("onClose", cb, null);
                },
                load: () => new Promise(res => {
                    loadRes = res;
                    apeng._platform.sendToNative(apeng.ENativeSend.interstitialLoad, id);
                }),
                show: () => new Promise(res => {
                    showRes = res;
                    apeng._platform.sendToNative(apeng.ENativeSend.interstitialShow, id);
                }),
                destroy: () => { },
            };
        }
        IBannerCreate(id, style) {
            let event = new apeng.EventDispatcher();
            apeng._platform.sendToNative(apeng.ENativeSend.bannerCreate, id);
            apeng._platform.on(apeng.ENativeReceive.bannerError, (res) => {
                event.emit("onError", res);
            }, null);
            apeng._platform.on(apeng.ENativeReceive.bannerLoaded, (res) => {
                event.emit("onLoad", res);
            }, null);
            let showRes = null;
            apeng._platform.on(apeng.ENativeReceive.bannerShow, (res) => {
                if (showRes) {
                    showRes(null);
                    showRes = null;
                }
            }, null);
            let hideRes = null;
            apeng._platform.on(apeng.ENativeReceive.bannerHide, (res) => {
                if (hideRes) {
                    hideRes(null);
                    hideRes = null;
                }
                event.emit("onHide", res);
            }, null);
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onHide: (cb) => {
                    event.on("onHide", cb, null);
                },
                onResize: (cb) => { },
                hide: () => new Promise(res => {
                    hideRes = res;
                    apeng._platform.sendToNative(apeng.ENativeSend.bannerHide, id);
                }),
                show: () => new Promise(res => {
                    showRes = res;
                    apeng._platform.sendToNative(apeng.ENativeSend.BannerShow, id);
                }),
                destroy: () => { },
            };
        }
        IShare() { return apeng.AndroidWxAndroidShare(); }
        loginWx(cb) {
            apeng._platform.once(apeng.ENativeReceive.login_success, (data) => {
                if (data)
                    cb(data);
                else
                    cb({ result: 2, code: "" });
            });
            apeng._platform.sendToNative(apeng.ENativeSend.wxgetcode);
        }
        loginTaptap(cb) {
            apeng._platform.once(apeng.ENativeReceive.login_success, (data) => {
                if (data)
                    cb(data);
                else
                    cb({ result: 2 });
            });
            apeng._platform.sendToNative(apeng.ENativeSend.taptapLogin);
        }
        taptapAntiAddiction(cb) {
            apeng._platform.once(apeng.ENativeReceive.AntiAddictionResult, (data) => {
                //500玩家登录后判断当前玩家可以进行游戏
                //1000退出账号
                //1030未成年玩家当前无法进行游戏
                //1050未成年玩家进行游戏有时间限制
                //9002--实名过程中点击了关闭实名窗
                cb(data);
            }, this);
            apeng._platform.sendToNative(apeng.ENativeSend.taptapAntiAddiction);
        }
        payShow(count, cb) {
            cb("success");
        }
    }
    apeng.BaseAndroidPlatform = BaseAndroidPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let KsPlatform = class KsPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["wx"];
        }
    };
    KsPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.ks)
    ], KsPlatform);
    apeng.KsPlatform = KsPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let KsWaiPlatform = class KsWaiPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["wx"];
        }
    };
    KsWaiPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.overseas_kwai)
    ], KsWaiPlatform);
    apeng.KsWaiPlatform = KsWaiPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let OppoPlatform = class OppoPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["qg"];
        }
        INativeTempCreate(id, interval, centerOffset = 0) {
            if (apeng._platform.systemInfo.SDKVersion < 1094)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            if (!this.root.createCustomAd)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            let data = {
                adUnitId: id,
            };
            if (centerOffset !== null || centerOffset !== undefined) {
                let h = apeng._platform.systemInfo.screenHeight;
                let offsetY = centerOffset * (h / apeng.winSize().height);
                data.style = {
                    top: h / 2 + offsetY
                };
            }
            return this.root.createCustomAd(data);
        }
        IBannerCreate(id, style) {
            return this.root.createBannerAd({
                adUnitId: id,
                style: {},
            });
        }
        IShare() {
            return {
                onShareAppMessage: () => {
                },
                show: (value, cb, query) => {
                    this.root.share({
                        success: () => {
                            if (cb)
                                cb(true);
                        },
                        fail: () => {
                            if (cb)
                                cb(false);
                        }
                    });
                }
            };
        }
    };
    OppoPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.oppo)
    ], OppoPlatform);
    apeng.OppoPlatform = OppoPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let OverseasAndroidXgamePlatform = class OverseasAndroidXgamePlatform extends apeng.BaseAndroidPlatform {
    };
    OverseasAndroidXgamePlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.overseas_android_xgame)
    ], OverseasAndroidXgamePlatform);
    apeng.OverseasAndroidXgamePlatform = OverseasAndroidXgamePlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let QQPlatform = class QQPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["qq"];
        }
        IBlockOnceCreate(id) {
            let size = { width: 0, height: 0 };
            let systemInfo = apeng._platform.systemInfo;
            let ad = this.root.createBlockAd({
                adUnitId: id,
                style: {
                    left: systemInfo.screenWidth - 200,
                    top: 200,
                },
                size: 1,
                orientation: "landscape",
            });
            ad.onResize((value) => {
                size.width = value.width;
                size.height = value.height;
                if (ad.style && ad.style.top) {
                    let sys = systemInfo;
                    if (sys.navbarPosition) {
                        let ratio = sys.pixelRatio || 1;
                        ad.style.top = (sys.navbarPosition.marginTop + sys.navbarPosition.navbarHeight) / ratio + apeng._platform._blockOnce_.topSpace;
                        ad.style.left = systemInfo.screenWidth - (sys.navbarPosition.marginRight + sys.navbarPosition.navbarWidth) / ratio;
                    }
                    else {
                        ad.style.top = 80;
                        ad.style.left = systemInfo.screenWidth - 90;
                    }
                }
                // 监听大小 重置banner位置
            });
            return ad;
        }
        IShare() {
            let isOnHide = false;
            let loadDir = new apeng.LoadDir(2, null);
            let completeCallBack = new apeng.CompleteCallBack();
            let isSuccess = true;
            return {
                onShareAppMessage: (path, param) => {
                    this.root.onShareAppMessage(param || (() => apeng._platform._share_.getData()));
                    this.root.showShareMenu({
                        showShareItems: ['qq', 'qzone', 'wechatFriends', 'wechatMoment'],
                        withShareTicket: true,
                        success(res) {
                            console.log("click topRight share: ", res);
                        }
                    });
                    // 偷偷加载分包。避免点击右上角时无图片
                    if (path) {
                        apeng._timer.once(this, () => {
                            this.loadShareImg(path, () => { });
                        }, this.isLoadShareCache() ? -1 : 3);
                    }
                },
                show: (value, cb, query) => {
                    completeCallBack.set(cb);
                    isSuccess = true;
                    loadDir.count = 2;
                    loadDir.onFinish = () => {
                        completeCallBack.run(isSuccess);
                    };
                    let _onShow = () => {
                        this.root.offShow(_onShow);
                        loadDir.subCount()();
                    };
                    this.root.onShow(_onShow);
                    isOnHide = false;
                    let _onHide = () => {
                        isOnHide = true;
                        this.root.offHide(_onHide);
                    };
                    this.root.onHide(_onHide);
                    let obj = {
                        title: value.title,
                        success: () => {
                            // 未开通权限
                            if (!isOnHide) {
                                isSuccess = true;
                                apeng._timer.once(this, loadDir.subCount(), .2);
                            }
                            else {
                                isSuccess = true;
                                apeng._timer.callLater(this, loadDir.subCount());
                                console.log("分享成功--");
                            }
                        },
                        fail: () => {
                            isSuccess = false;
                            console.log("分享失败--");
                            apeng._timer.callLater(this, loadDir.subCount());
                        }
                    };
                    if (value.query)
                        obj.query = "query=" + value.query;
                    let complete = () => {
                        this.root.shareAppMessage(obj);
                    };
                    if (value.imageUrl) {
                        obj.imageUrl = value.imageUrl;
                        let path = apeng._platform._share_.getImgUrlByPath(value.imageUrl);
                        if (path) {
                            obj.path = path;
                            this.loadShareImg(path, complete);
                        }
                        else
                            complete();
                    }
                    else
                        complete();
                }
            };
        }
    };
    QQPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.qq)
    ], QQPlatform);
    apeng.QQPlatform = QQPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let TTPlatform = class TTPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["tt"];
            this._loginSuccess = false;
            /**
             * 侧边栏功能
             */
            this.sidebar = {
                /**功能可用 */
                isEnable: false,
                /**可领取奖励 */
                isReward: false,
                EventType: {
                    /**打开奖励弹窗 */
                    REWARD_CHANGE: "REWARD_CHANGE",
                },
                init: (complete) => {
                    if (!this.root.checkScene)
                        complete();
                    else
                        this.root.checkScene({
                            scene: "sidebar",
                            success: (res) => {
                                console.log("check scene success: ", res.isExist);
                                //成功回调逻辑
                                // if (res.isExist) {
                                this.sidebar.isEnable = true;
                                let fn = (obj) => {
                                    this.sidebar.isReward = false;
                                    if (obj && obj.scene == "021036") {
                                        if (this.sidebar.checkReward()) {
                                            this.sidebar.isReward = true;
                                            apeng._platform.emit(this.sidebar.EventType.REWARD_CHANGE);
                                        }
                                    }
                                };
                                this.onShow(fn);
                                // 第一次刷新
                                fn(this.getLaunchOptionsSync());
                                // }
                            },
                            fail: (res) => {
                                console.log("check scene fail:", res);
                            },
                            complete
                        });
                },
                /**能领取奖励 */
                checkReward: () => {
                    let now = apeng.Times.day();
                    let cur = apeng._platform.storage.get("sidebarReward", -1);
                    if (cur == -1 || cur != now)
                        return true;
                    else
                        return false;
                },
                /**领取奖励 */
                reward: () => {
                    let now = apeng.Times.day();
                    apeng._platform.storage.set("sidebarReward", now);
                    this.sidebar.isReward = false;
                },
                /**跳转侧边栏 */
                to: () => {
                    //@ts-ignore 抖音开发者工具强制要求
                    tt.navigateToScene({
                        scene: "sidebar",
                        success: (res) => {
                            console.log("navigate to scene success");
                            // 跳转成功回调逻辑
                        },
                        fail: (res) => {
                            console.log("navigate to scene fail: ", res);
                            // 跳转失败回调逻辑
                        },
                    });
                },
            };
        }
        onInstance() {
            apeng.platformMgr.on(apeng.platformMgr.EventType.START_UP, (complete) => {
                this.sidebar.init(complete);
            });
        }
        IShare() {
            return {
                onShareAppMessage: () => {
                    // this.root.onShareAppMessage(() => {
                    // 	return PlatformMgr.Share.getData()
                    // })
                    // this.root.showShareMenu({
                    // 	withShareTicket: false,
                    // 	success(res: any) {
                    // 		console.log("click topRight share: ", res)
                    // 	}
                    // })
                },
                show: (value, cb, query) => {
                    this.shareAppMessage(["对子消消消", "麻将消消", "挪麻将", "解压游戏"], cb, {
                        title: value.title,
                    });
                }
            };
        }
        shareAppMessage(videoTopics = ["倒水冲冲冲", "水排序", "颜色排序", "第二关怎么过", "倒水排序"], callback, message) {
            let Record = apeng._platform._record_;
            let channel = message && message.channel ? message.channel : "video";
            if (Record.recordering == true && channel == "video") {
                apeng._ui.tip("分享出错了，再来一局吧！");
                if (callback)
                    callback(false);
                return;
            }
            console.log("开始分享", Record.videoPath);
            if (message && message.videoPath != '' && message.videoPath != undefined && message.videoPath != null) {
                Record.videoPath = message.videoPath;
            }
            if (Record.videoPath == '') {
                if (callback)
                    callback(false);
                Record.getvideo = true;
                return;
            }
            let extra = {
                videoPath: Record.videoPath,
                videoTopics,
                withVideoId: true,
            };
            console.log("extra", extra);
            let query = ""; //通过这个来判断分享图片的效果
            if (message && message.query) {
                for (let key in message.query) {
                    query += '&' + key + '=' + message.query[key];
                }
            }
            console.log('分享参数 query', query);
            this.root.shareAppMessage({
                channel: channel,
                extra: extra,
                query: query,
                success(res) {
                    console.log("分享视频成功", res);
                    if (callback)
                        callback(true);
                },
                fail(e) {
                    if (e.errMsg == "shareAppMessage:cancel" || e.errMsg == "shareAppMessage:fail cancel" || e.errMsg == "shareAppMessage:fail internal error Share error") {
                        console.log("分享视频失败", e);
                        if (message && message.channel == 'invite') {
                            // oops.tip.showTip("求助失败")
                        }
                        else {
                            apeng._ui.tip("分享视频失败");
                        }
                    }
                    else {
                        console.log("分享视频失败", e);
                        apeng._ui.tip("录屏时间少于 3 秒，无法分享");
                    }
                    if (callback)
                        callback(false);
                },
            });
        }
        reportEvent(key, obj) {
            if (!this.root.reportAnalytics)
                return;
            this.root.reportAnalytics(key, obj);
        }
        login(cb) {
            this.root.login({
                force: false,
                success: (res) => {
                    this._loginSuccess = true;
                    if (cb)
                        cb(res.code);
                },
                fail: () => {
                    if (cb)
                        cb("");
                }
            });
        }
        setImRankData(value) {
            if (this.root.setImRankData) {
                this._rankLogin((result) => {
                    if (result) {
                        this.root.setImRankData({
                            dataType: 0,
                            value: value.toString(),
                            priority: 0,
                            extra: "extra",
                            success(res) {
                                console.log(`setImRankData success res: ${JSON.stringify(res)}`);
                            },
                            fail(res) {
                                console.log(`setImRankData fail res: ${res.errMsg}`);
                            },
                        });
                    }
                    else {
                        // UIMgr.tip("加入排行失败")
                        console.log(`setImRankData fail `);
                    }
                });
            }
        }
        _rankLogin(cb) {
            if (this._loginSuccess)
                cb("true");
            else {
                this.login(cb);
            }
        }
        getImRankList(suffix = "次") {
            if (this.root.getImRankList) {
                this._rankLogin((result) => {
                    if (result) {
                        this.root.getImRankList({
                            relationType: "default",
                            dataType: 0,
                            rankType: "day",
                            suffix,
                            rankTitle: "每日排行榜",
                            success(res) {
                                console.log(`getImRankData success res: ${res}`);
                            },
                            fail(res) {
                                console.log(`getImRankData fail res: ${res.errMsg}`);
                            },
                        });
                    }
                    else {
                        apeng._ui.tip("登陆成功后才可以查看排行");
                        console.log(`setImRankData fail `);
                    }
                });
            }
            else {
                apeng._ui.tip("当前版本不支持");
                console.log("当前版本不支持");
            }
        }
    };
    TTPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.tt)
    ], TTPlatform);
    apeng.TTPlatform = TTPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let VivoPlatform = class VivoPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["qg"];
        }
        INativeTempCreate(id, interval, centerOffset = 0) {
            if (apeng._platform.systemInfo.SDKVersion <= 1095)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            if (!this.root.createCustomAd)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            let data = {
                adUnitId: id,
            };
            if (centerOffset !== null || centerOffset !== undefined) {
                let h = apeng._platform.systemInfo.screenHeight;
                let offsetY = centerOffset * (h / apeng.winSize().height);
                data.style = {
                    top: h / 2 + offsetY
                };
            }
            return this.root.createCustomAd(data);
        }
        IBannerCreate(id, style) {
            return this.root.createBannerAd({
                posId: id,
                style: {},
            });
        }
        IShare() {
            return {
                onShareAppMessage: () => {
                },
                show: (value, cb, query) => {
                    this.root.share({
                        success: () => {
                            if (cb)
                                cb(true);
                        },
                        fail: () => {
                            if (cb)
                                cb(false);
                        }
                    });
                }
            };
        }
    };
    VivoPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.vivo)
    ], VivoPlatform);
    apeng.VivoPlatform = VivoPlatform;
})(apeng || (apeng = {}));

(function (apeng) {
    var WebPlatform_1;
    const prefabPrefix = "platform/prefab/";
    let WebPlatform = WebPlatform_1 = class WebPlatform extends apeng.BasePlatform {
        static setSize(node, width, height) {
            let transform = apeng.NodeHelper.getUITransform(node);
            if (width != null && height != null) {
                transform.setContentSize(width, height);
                return;
            }
            if (width && typeof width == "object")
                transform.setContentSize(width);
            else {
                if (width != null)
                    transform.width = width;
                if (height != null)
                    transform.height = height;
            }
        }
        static getChildrenByComponent(node, comp) {
            for (let value of node.children) {
                let res = value.getComponent(comp);
                if (res)
                    return res;
            }
            return null;
        }
        static getNodeParent() {
            return apeng._ui.getLayerParent(apeng.EUILayer.Top, apeng._ui.stageUp);
        }
        static getPrefabByNode(url) {
            return apeng.instantiate(apeng._resouces.get(url, apeng.Prefab));
        }
        static IRewardedVideoCreate(id) {
            if (!apeng._platform.openWebSimulationUI)
                return apeng.BasePlatform.IRewardedVideoCreate(id);
            let testFail = false;
            let event = new apeng.EventDispatcher();
            let ad = null;
            return {
                isSimulate: true,
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onClose: (cb) => {
                    event.on("onClose", cb, null);
                },
                load: () => new Promise(res => {
                    if (!testFail) {
                        apeng._resouces.load(prefabPrefix + "RewardedVideoTemp", () => {
                            if (!ad) {
                                ad = this.getPrefabByNode(prefabPrefix + "RewardedVideoTemp")
                                    .getComponent("RewardedVideoTemp");
                                ad.node.active = false;
                                this.getNodeParent().addChild(ad.node);
                                ad.onCloseCallBack = (isEnd) => {
                                    ad.node.active = false;
                                    event.emit("onClose", { isEnded: isEnd });
                                    apeng.game.emit(apeng.Game.EVENT_SHOW);
                                };
                            }
                            apeng._timer.once(this, () => {
                                event.emit("onLoad");
                                res(null);
                            }, .2);
                        });
                    }
                    else
                        apeng._timer.once(this, () => {
                            event.emit("onError", { errCode: 1004, msg: "测试失败" });
                        }, 1);
                }),
                show: () => new Promise(res => {
                    if (!testFail) {
                        ad.node.active = true;
                        apeng._timer.once(this, () => {
                            apeng.game.emit(apeng.Game.EVENT_HIDE);
                            res(null);
                        }, .2);
                    }
                    else
                        apeng._timer.once(this, () => {
                            event.emit("onError", { errCode: 1004, msg: "测试失败2222" });
                        }, 1);
                }),
            };
        }
        static IRecordMgr() {
            if (!apeng._platform.openWebSimulationUI)
                return apeng.BasePlatform.IRecordMgr();
            return apeng.BasePlatform.IRecordMgr();
            let record = null;
            let event = new apeng.EventDispatcher();
            return {
                clipVideo: (obj) => {
                    if (obj) {
                        if (obj.success)
                            obj.success({ videoPath: "test" });
                        if (obj.complete)
                            obj.complete({ videoPath: "test" });
                    }
                },
                start: (value) => {
                    let cb = () => {
                        record.node.active = true;
                        record.startRecord(value.duration || 300);
                        record.onStartRecord(() => {
                            event.emit("onStart");
                        });
                        record.onStopRecord(() => {
                            console.log("录屏完成:");
                            event.emit("onStop", { videoPath: "" });
                        });
                    };
                    if (record)
                        cb();
                    else
                        apeng._resouces.load(prefabPrefix + "RecordTemp", () => {
                            record = this.getPrefabByNode(prefabPrefix + "RecordTemp")
                                .getComponent("RecordTemp");
                            record.node.active = false;
                            this.getNodeParent().addChild(record.node);
                            cb();
                        });
                },
                resume: () => { if (record)
                    record.resumeRecord(); },
                pause: () => { if (record)
                    record.pauseRecord(); },
                stop: () => {
                    if (record) {
                        record.node.active = false;
                        record.stopRecord();
                    }
                },
                onStart: (cb) => {
                    event.on("onStart", cb, null);
                },
                onPause: (cb) => {
                    event.on("onPause", cb, null);
                },
                onResume: (cb) => {
                    event.on("onResume", cb, null);
                },
                onStop: (cb) => {
                    event.on("onStop", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
            };
        }
        static IInterstitialCreate(id) {
            if (!apeng._platform.openWebSimulationUI)
                return apeng.BasePlatform.IInterstitialCreate(id);
            let event = new apeng.EventDispatcher();
            let ad = null;
            return {
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onClose: (cb) => {
                    event.on("onClose", cb, null);
                },
                load: () => new Promise((res => {
                    apeng._resouces.load(prefabPrefix + "InterstitialTemp", () => {
                        if (!ad) {
                            ad = this.getPrefabByNode(prefabPrefix + "InterstitialTemp");
                            ad.active = false;
                            this.getNodeParent().addChild(ad);
                            this.setSize(ad, apeng.winSize());
                            this.getChildrenByComponent(ad, "ButtonCC").eventHandler.addEvent({
                                callBack: () => {
                                    ad.active = false;
                                    event.emit("onClose");
                                }
                            });
                        }
                        apeng._timer.once(this, () => {
                            event.emit("onLoad");
                            res(null);
                        }, .2);
                    });
                })),
                show: () => new Promise((res => {
                    ad.active = true;
                    res(null);
                })),
                destroy: () => { },
            };
        }
        static INativeTempCreate(id, interval) {
            if (!apeng._platform.openWebSimulationUI)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            let win = apeng.winSize();
            let event = new apeng.EventDispatcher();
            let ad = null;
            return {
                isShow: () => ad && ad.active,
                hide: () => new Promise(res => {
                    apeng._timer.once(this, () => {
                        if (ad)
                            ad.active = false;
                        event.emit("onHide");
                        res(null);
                    }, .2);
                }),
                show: () => new Promise(res => {
                    apeng._resouces.load(prefabPrefix + "CustomAdTemp", () => {
                        if (!ad) {
                            ad = this.getPrefabByNode(prefabPrefix + "CustomAdTemp");
                            ad.active = false;
                            this.getNodeParent().addChild(ad);
                            let w = win.width * apeng._platform.config.banner.sizeRatio;
                            this.setSize(ad, w, w * .3);
                            let top = apeng.NodeHelper.getUITransform(ad).height / 2;
                            let worldPosition = ad.worldPosition;
                            ad.setWorldPosition({ x: worldPosition.x, y: top, z: worldPosition.z });
                            apeng._timer.once(this, () => {
                                event.emit("onLoad");
                            }, .2);
                        }
                        apeng._timer.once(this, () => {
                            ad.active = true;
                            res(null);
                        }, .2);
                    });
                }),
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onHide: (cb) => {
                    event.on("onHide", cb, null);
                },
                onClose: (cb) => {
                    event.on("onClose", cb, null);
                },
                destroy: () => { },
            };
        }
        static IBannerCreate(id, style) {
            if (!apeng._platform.openWebSimulationUI)
                return apeng.BasePlatform.IBannerCreate(id, style);
            let win = apeng.winSize();
            let event = new apeng.EventDispatcher();
            let ad = null;
            return {
                destroy: () => { },
                show: () => new Promise(res => {
                    apeng._resouces.load(prefabPrefix + "BannerTemp", () => {
                        if (!ad) {
                            ad = this.getPrefabByNode(prefabPrefix + "BannerTemp");
                            ad.active = false;
                            this.getNodeParent().addChild(ad);
                            let w = win.width * apeng._platform.config.banner.sizeRatio;
                            this.setSize(ad, w, w * .4);
                            let top = apeng.NodeHelper.getUITransform(ad).height / 2;
                            let worldPosition = ad.worldPosition;
                            ad.setWorldPosition({ x: worldPosition.x, y: top, z: worldPosition.z });
                            apeng._timer.once(this, () => {
                                event.emit("onLoad");
                                event.emit("onResize", {
                                    width: w,
                                    height: w * .4
                                });
                            }, .2);
                        }
                        apeng._timer.once(this, () => {
                            ad.active = true;
                            res(null);
                        }, .2);
                    });
                }),
                hide: () => new Promise(res => {
                    apeng._timer.once(this, () => {
                        if (ad)
                            ad.active = false;
                        event.emit("onHide");
                        res(null);
                    }, .2);
                }),
                onLoad: (cb) => {
                    event.on("onLoad", cb, null);
                },
                onError: (cb) => {
                    event.on("onError", cb, null);
                },
                onHide: (cb) => {
                    event.on("onHide", cb, null);
                },
                onResize: (cb) => {
                    event.on("onResize", cb, null);
                },
            };
        }
        IRewardedVideoCreate(id) { return WebPlatform_1.IRewardedVideoCreate(id); }
        IRecordMgr() { return WebPlatform_1.IRecordMgr(); }
        IInterstitialCreate(id) { return WebPlatform_1.IInterstitialCreate(id); }
        INativeTempCreate(id, interval) { return WebPlatform_1.INativeTempCreate(id, interval); }
        IBannerCreate(id, style) { return WebPlatform_1.IBannerCreate(id, style); }
        static IShare() {
            let _cb = null;
            let node = null;
            return {
                onShareAppMessage: () => {
                },
                show: (value, cb, query) => {
                    if (!apeng._platform.openWebSimulationUI) {
                        if (cb)
                            cb(true);
                        return;
                    }
                    _cb = cb;
                    apeng._resouces.load(prefabPrefix + "ShareTemp", () => {
                        if (!node) {
                            node = WebPlatform_1.getPrefabByNode(prefabPrefix + "ShareTemp");
                            node.active = false;
                            WebPlatform_1.getNodeParent().addChild(node);
                            WebPlatform_1.setSize(node, apeng.winSize());
                            node.getComponentInChildren("ButtonCC").eventHandler.addEvent({
                                callBack: () => {
                                    node.active = false;
                                    if (_cb)
                                        _cb(true);
                                }
                            });
                        }
                        node.active = true;
                    });
                },
                circleFriends: (value, cb, query) => {
                    cb && cb(true);
                },
            };
        }
        IShare() { return WebPlatform_1.IShare(); }
        reStart() {
            if (apeng.sys.isBrowser)
                location.reload();
            else
                apeng.game.restart();
        }
        saveImg(width, height, buffer, cb, saveLocal) {
            let fileName = this.getSaveImgName();
            CanvasImageWeb.getInstance().saveAsPNG(CanvasImageWeb.updateCanvas(width, height, buffer), width, height, fileName);
            cb(fileName);
        }
    };
    WebPlatform = WebPlatform_1 = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.web)
    ], WebPlatform);
    apeng.WebPlatform = WebPlatform;
    class CanvasImageWeb {
        static updateCanvas(width, height, _buffer) {
            if (!this._canvas) {
                this._canvas = document.createElement('canvas');
                this._canvas.width = width;
                this._canvas.height = height;
            }
            else {
                this._canvas.getContext('2d').clearRect(0, 0, this._canvas.width, this._canvas.height);
            }
            let ctx = this._canvas.getContext('2d');
            let rowBytes = width * 4;
            for (let row = 0; row < height; row++) {
                let sRow = height - 1 - row;
                let imageData = ctx.createImageData(width, 1);
                let start = sRow * width * 4;
                for (let i = 0; i < rowBytes; i++) {
                    imageData.data[i] = _buffer[start + i];
                }
                ctx.putImageData(imageData, 0, row);
            }
            return this._canvas;
        }
        static getInstance() {
            var $support = function () {
                var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                return {
                    canvas: !!ctx,
                    imageData: !!ctx.getImageData,
                    dataURL: !!canvas.toDataURL,
                    btoa: !!window.btoa
                };
            }();
            var downloadMime = 'image/octet-stream';
            function scaleCanvas(canvas, width, height) {
                var w = canvas.width, h = canvas.height;
                if (width == undefined) {
                    width = w;
                }
                if (height == undefined) {
                    height = h;
                }
                var retCanvas = document.createElement('canvas');
                var retCtx = retCanvas.getContext('2d');
                retCanvas.width = width;
                retCanvas.height = height;
                retCtx.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);
                return retCanvas;
            }
            function getDataURL(canvas, type, width, height) {
                canvas = scaleCanvas(canvas, width, height);
                return canvas.toDataURL(type);
            }
            function saveFile(strData, type, fileName) {
                // document.location.href = strData;
                fileDownload(strData, type, fileName);
            }
            function genImage(strData) {
                var img = document.createElement('img');
                img.src = strData;
                return img;
            }
            function fixType(type) {
                type = type.toLowerCase().replace(/jpg/i, 'jpeg');
                var r = type.match(/png|jpeg|bmp|gif/)[0];
                return 'image/' + r;
            }
            function encodeData(data) {
                if (!window.btoa) {
                    throw 'btoa undefined';
                }
                var str = '';
                if (typeof data == 'string') {
                    str = data;
                }
                else {
                    for (var i = 0; i < data.length; i++) {
                        str += String.fromCharCode(data[i]);
                    }
                }
                return btoa(str);
            }
            function getImageData(canvas) {
                var w = canvas.width, h = canvas.height;
                return canvas.getContext('2d').getImageData(0, 0, w, h);
            }
            function makeURI(strData, type) {
                return 'data:' + type + ';base64,' + strData;
            }
            /**
             * create bitmap image
             * 按照规则生成图片响应头和响应体
             */
            var genBitmapImage = function (oData) {
                //
                // BITMAPFILEHEADER: http://msdn.microsoft.com/en-us/library/windows/desktop/dd183374(v=vs.85).aspx
                // BITMAPINFOHEADER: http://msdn.microsoft.com/en-us/library/dd183376.aspx
                //
                var biWidth = oData.width;
                var biHeight = oData.height;
                var biSizeImage = biWidth * biHeight * 3;
                var bfSize = biSizeImage + 54; // total header size = 54 bytes
                //
                //  typedef struct tagBITMAPFILEHEADER {
                //  	WORD bfType;
                //  	DWORD bfSize;
                //  	WORD bfReserved1;
                //  	WORD bfReserved2;
                //  	DWORD bfOffBits;
                //  } BITMAPFILEHEADER;
                //
                var BITMAPFILEHEADER = [
                    // WORD bfType -- The file type signature; must be "BM"
                    0x42, 0x4D,
                    // DWORD bfSize -- The size, in bytes, of the bitmap file
                    bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,
                    // WORD bfReserved1 -- Reserved; must be zero
                    0, 0,
                    // WORD bfReserved2 -- Reserved; must be zero
                    0, 0,
                    // DWORD bfOffBits -- The offset, in bytes, from the beginning of the BITMAPFILEHEADER structure to the bitmap bits.
                    54, 0, 0, 0
                ];
                //
                //  typedef struct tagBITMAPINFOHEADER {
                //  	DWORD biSize;
                //  	LONG  biWidth;
                //  	LONG  biHeight;
                //  	WORD  biPlanes;
                //  	WORD  biBitCount;
                //  	DWORD biCompression;
                //  	DWORD biSizeImage;
                //  	LONG  biXPelsPerMeter;
                //  	LONG  biYPelsPerMeter;
                //  	DWORD biClrUsed;
                //  	DWORD biClrImportant;
                //  } BITMAPINFOHEADER, *PBITMAPINFOHEADER;
                //
                var BITMAPINFOHEADER = [
                    // DWORD biSize -- The number of bytes required by the structure
                    40, 0, 0, 0,
                    // LONG biWidth -- The width of the bitmap, in pixels
                    biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,
                    // LONG biHeight -- The height of the bitmap, in pixels
                    biHeight & 0xff, biHeight >> 8 & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,
                    // WORD biPlanes -- The number of planes for the target device. This value must be set to 1
                    1, 0,
                    // WORD biBitCount -- The number of bits-per-pixel, 24 bits-per-pixel -- the bitmap
                    // has a maximum of 2^24 colors (16777216, Truecolor)
                    24, 0,
                    // DWORD biCompression -- The type of compression, BI_RGB (code 0) -- uncompressed
                    0, 0, 0, 0,
                    // DWORD biSizeImage -- The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps
                    biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,
                    // LONG biXPelsPerMeter, unused
                    0, 0, 0, 0,
                    // LONG biYPelsPerMeter, unused
                    0, 0, 0, 0,
                    // DWORD biClrUsed, the number of color indexes of palette, unused
                    0, 0, 0, 0,
                    // DWORD biClrImportant, unused
                    0, 0, 0, 0
                ];
                var iPadding = (4 - ((biWidth * 3) % 4)) % 4;
                var aImgData = oData.data;
                var strPixelData = '';
                var biWidth4 = biWidth << 2;
                var y = biHeight;
                var fromCharCode = String.fromCharCode;
                do {
                    var iOffsetY = biWidth4 * (y - 1);
                    var strPixelRow = '';
                    for (var x = 0; x < biWidth; x++) {
                        var iOffsetX = x << 2;
                        strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) +
                            fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) +
                            fromCharCode(aImgData[iOffsetY + iOffsetX]);
                    }
                    for (var c = 0; c < iPadding; c++) {
                        strPixelRow += String.fromCharCode(0);
                    }
                    strPixelData += strPixelRow;
                } while (--y);
                var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);
                return strEncoded;
            };
            /**
             * saveAsImage
             * @param canvasElement
             * @param {String} image type
             * @param {Number} [optional] png width
             * @param {Number} [optional] png height
             */
            var saveAsImage = function (canvas, width, height, type, fileName) {
                /**
                 * canvas.toBlob 的第三个参数。当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。
                 * 如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。
                 * 此处暂时默认设置为 1
                 */
                var quality = 1.0;
                if ($support.canvas && $support.dataURL) {
                    if (typeof canvas == "string") {
                        canvas = document.getElementById(canvas);
                    }
                    if (type == undefined) {
                        type = 'png';
                    }
                    type = fixType(type);
                    if (/bmp/.test(type)) {
                        var data = getImageData(scaleCanvas(canvas, width, height));
                        var strData = genBitmapImage(data);
                        saveFile(makeURI(strData, downloadMime), type.replace("image/", ""), fileName);
                    }
                    else {
                        canvas = scaleCanvas(canvas, width, height);
                        // 如果
                        canvas.toBlob(function (blob) {
                            var url = URL.createObjectURL(blob);
                            saveFile(url, type.replace("image/", ""), fileName);
                        }, type, quality);
                    }
                }
            };
            var convertToImage = function (canvas, width, height, type) {
                if ($support.canvas && $support.dataURL) {
                    if (typeof canvas == "string") {
                        canvas = document.getElementById(canvas);
                    }
                    if (type == undefined) {
                        type = 'png';
                    }
                    type = fixType(type);
                    if (/bmp/.test(type)) {
                        var data = getImageData(scaleCanvas(canvas, width, height));
                        var strData = genBitmapImage(data);
                        return genImage(makeURI(strData, 'image/bmp'));
                    }
                    else {
                        var strData = getDataURL(canvas, type, width, height);
                        return genImage(strData);
                    }
                }
            };
            var fileDownload = function (downloadUrl, type, fileName) {
                let aLink = document.createElement('a');
                aLink.style.display = 'none';
                aLink.href = downloadUrl;
                aLink.download = fileName + "." + type;
                // 触发点击-然后移除
                document.body.appendChild(aLink);
                aLink.click();
                document.body.removeChild(aLink);
            };
            return {
                saveAsImage: saveAsImage,
                saveAsPNG: function (canvas, width, height, fileName) {
                    return saveAsImage(canvas, width, height, 'png', fileName);
                },
                saveAsJPEG: function (canvas, width, height) {
                    return saveAsImage(canvas, width, height, 'jpeg', 'defaultjpg');
                },
                saveAsGIF: function (canvas, width, height) {
                    return saveAsImage(canvas, width, height, 'gif', 'defaultgif');
                },
                saveAsBMP: function (canvas, width, height) {
                    return saveAsImage(canvas, width, height, 'bmp', 'defaultbmp');
                },
                convertToImage: convertToImage,
                convertToPNG: function (canvas, width, height) {
                    return convertToImage(canvas, width, height, 'png');
                },
                convertToJPEG: function (canvas, width, height) {
                    return convertToImage(canvas, width, height, 'jpeg');
                },
                convertToGIF: function (canvas, width, height) {
                    return convertToImage(canvas, width, height, 'gif');
                },
                convertToBMP: function (canvas, width, height) {
                    return convertToImage(canvas, width, height, 'bmp');
                }
            };
        }
    }
    CanvasImageWeb._canvas = null;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let WxPlatform = class WxPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["wx"];
            this._userInfoBtn = null;
            this.isBtnShow = false;
        }
        INativeTempCreate(id, interval) {
            if (!this.root.createCustomAd)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            let w = 375;
            let h = 106;
            let systemInfo = apeng._platform.systemInfo;
            return this.root.createCustomAd({
                adUnitId: id,
                style: {
                    left: Math.max(0, (systemInfo.screenWidth - w) / 2),
                    top: systemInfo.screenHeight - h,
                },
                adIntervals: interval
            });
        }
        IBlockOnceCreate(id) {
            let w = 375 / 5;
            let h = 106;
            let systemInfo = apeng._platform.systemInfo;
            let obj = this.root.getMenuButtonBoundingClientRect();
            let ad = this.root.createCustomAd({
                adUnitId: id,
                style: {
                    left: obj.left,
                    top: obj.top + obj.height + apeng._platform._blockOnce_.topSpace
                },
                adIntervals: apeng._platform.config.blockOnce.refreshInterval
            });
            return ad;
        }
        IShare() {
            let shareTime = null;
            let isOnShow = false;
            return {
                onShareAppMessage: (path, param) => {
                    this.root.onShareAppMessage(param || (() => apeng._platform._share_.getData()));
                    this.root.showShareMenu({
                        menus: ["shareAppMessage", "shareTimeline"],
                        withShareTicket: true,
                        success(res) {
                            console.log("click topRight share: ", res);
                        }
                    });
                    // 偷偷加载分包。避免点击右上角时无图片
                    if (path) {
                        apeng._timer.once(this, () => {
                            this.loadShareImg(path, () => { });
                        }, this.isLoadShareCache() ? -1 : 3);
                    }
                },
                show: (value, cb, query) => {
                    shareTime = apeng.Times.second();
                    this.shareAppMessageCallBack = cb;
                    if (!isOnShow) {
                        isOnShow = true;
                        let _onShow = () => {
                            this.root.offShow(_onShow);
                            if (!shareTime)
                                return;
                            if (!this.shareAppMessageCallBack)
                                return;
                            if (apeng.Times.second() - shareTime > apeng._platform.config.share.callTime)
                                this.shareAppMessageCallBack(true);
                            else
                                this.shareAppMessageCallBack(false);
                            shareTime = null;
                            isOnShow = false;
                            this.shareAppMessageCallBack = null;
                        };
                        this.root.onShow(_onShow);
                    }
                    let obj = {
                        title: value.title,
                    };
                    if (value.query)
                        obj.query = "query=" + value.query;
                    let complete = () => {
                        this.root.shareAppMessage(obj);
                    };
                    if (value.imageUrl) {
                        obj.imageUrl = value.imageUrl;
                        let path = apeng._platform._share_.getImgUrlByPath(value.imageUrl);
                        if (path) {
                            obj.path = path;
                            this.loadShareImg(path, complete);
                        }
                        else
                            complete();
                    }
                    else
                        complete();
                },
                circleFriends: (value, cb, query) => {
                    cb && cb(true);
                },
            };
        }
        IOpenDataContext() {
            let _openDataContext = this.root.getOpenDataContext();
            return {
                set: (value) => {
                    this.root.setUserCloudStorage({
                        KVDataList: [{
                                key: "ranking",
                                value: JSON.stringify(value)
                            }]
                    });
                },
                startRender: (param) => {
                    _openDataContext.postMessage({
                        event: 'startRender',
                        param
                    });
                },
                updateRender: (index) => {
                    _openDataContext.postMessage({
                        event: 'updateRender',
                        index
                    });
                },
            };
        }
        getSetting(cb) {
            this.root.getSetting({
                success: (res) => {
                    cb(res);
                },
                fail: () => {
                    cb(null);
                }
            });
        }
        authorizeWxFriendInteraction(cb) {
            apeng._platform.getSetting((settingData) => {
                if (settingData) {
                    if (!settingData.authSetting['scope.WxFriendInteraction']) {
                        this.root.authorize({
                            scope: 'scope.WxFriendInteraction',
                            success: (res) => {
                                settingData.authSetting['scope.WxFriendInteraction'] = true;
                                console.log("开放域授权成功", res);
                                cb("authSuccess");
                            },
                            fail: (res) => {
                                console.log("开放域授权失败", res);
                                cb("authFail");
                            }
                        });
                    }
                    else
                        cb("none");
                }
                else
                    cb("none");
            });
        }
        authorizeWxFriendInteractionSync() {
            let settingData = apeng._platform._settingData;
            if (settingData)
                if (!settingData.authSetting['scope.WxFriendInteraction'])
                    return false;
                else
                    return true;
            else
                return true;
        }
        getUserInfo(cb) {
            apeng._platform.getSetting((settingData) => {
                if (settingData && settingData.authSetting['scope.userInfo']) {
                    this.root.getUserInfo({
                        success: (res) => {
                            console.log(res.userInfo);
                            cb(this._getUserInfo(res.userInfo));
                        },
                        fail: () => {
                            cb(null);
                        }
                    });
                }
                else
                    cb(null);
            });
        }
        showUserInfoBtn(node, cb) {
            var _a;
            let rect = (_a = node.getComponent(apeng.UITransform)) === null || _a === void 0 ? void 0 : _a.getBoundingBoxToWorld();
            let device = apeng.winSize().width / apeng._platform.systemInfo.screenWidth;
            rect.x /= device;
            rect.y = (apeng.winSize().height - rect.y - rect.height) / device;
            rect.width = rect.width / device;
            rect.height = rect.height / device;
            if (!this._userInfoBtn) {
                this._userInfoBtn = this.root.createUserInfoButton({
                    type: 'image',
                    style: {
                        left: rect.x,
                        top: rect.y,
                        width: rect.width,
                        height: rect.height,
                    }
                });
                this._userInfoBtn.onTap((res) => {
                    // 用户同意授权后回调，通过回调可获取用户头像昵称信息
                    console.log(res);
                    let value = this._getUserInfo(res.userInfo);
                    if (value) {
                        this.hideUserInfoBtn();
                        cb(value);
                    }
                });
            }
            else {
                if (!this.isBtnShow) {
                    this._userInfoBtn.show();
                    this._userInfoBtn.style.left = rect.x;
                    this._userInfoBtn.style.top = rect.y;
                    this._userInfoBtn.style.width = rect.width;
                    this._userInfoBtn.style.height = rect.height;
                }
            }
            this.isBtnShow = true;
        }
        hideUserInfoBtn() {
            if (this._userInfoBtn) {
                if (this.isBtnShow)
                    this._userInfoBtn.hide();
                this.isBtnShow = false;
            }
        }
        _getUserInfo(value) {
            if (!value)
                return null;
            return {
                name: value.nickName,
                city: value.city,
                avatarUrl: value.avatarUrl,
                age: 1,
            };
        }
    };
    WxPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.wx)
    ], WxPlatform);
    apeng.WxPlatform = WxPlatform;
})(apeng || (apeng = {}));
/// <reference path="./BaseMingamePlatform.ts" />

(function (apeng) {
    let XiaoMiPlatform = class XiaoMiPlatform extends apeng.BaseMingamePlatform {
        constructor() {
            super(...arguments);
            this.root = window["qg"];
        }
        INativeTempCreate(id, interval) {
            if (!this.root.createCustomAd)
                return apeng.BasePlatform.INativeTempCreate(id, interval);
            return this.root.createCustomAd({
                adUnitId: id,
            });
        }
        IBannerCreate(id, style) {
            return this.root.createBannerAd({
                adUnitId: id,
                style: {},
            });
        }
    };
    XiaoMiPlatform = __decorate([
        apeng.platformMgr.add(apeng.EPlatformType.xiaomi)
    ], XiaoMiPlatform);
    apeng.XiaoMiPlatform = XiaoMiPlatform;
})(apeng || (apeng = {}));

(function (apeng) {
    function AndroidFBShare() {
        function checkShareResult(errCode, startTime) {
            let result = true;
            if (Number(errCode) == 1) {
                result = false;
            }
            return result;
        }
        /**
         * 分享图片路径
         */
        function show(value, cb, query) {
            if (!apeng.sys.isNative)
                return;
            onShareAppMessage(cb);
            onShareApp(value, apeng.WxShareScene.share_session, apeng.WxShareType.type_image);
        }
        /**
         * 分享图片网址
         */
        function circleFriends(value, cb, query) {
            if (!apeng.sys.isNative)
                return;
            onShareAppMessage(cb);
            onShareApp(value, apeng.WxShareScene.share_timeline, apeng.WxShareType.type_webPage);
        }
        function onShareAppMessage(cb) {
            let shareTime = apeng.Times.second();
            apeng._platform.once(apeng.ENativeReceive.wxShareReturn, (errCode) => {
                cb && cb(checkShareResult(errCode, shareTime));
            });
        }
        function onShareApp(value, shareTo, shareType) {
            let shareInfo = {
                // shareUrl: "https://www.baidu.com/",
                shareUrl: value.query,
                // imageUrl: "http://webreview.cdwwlkj.com/cat/1.0.0/assets/bento/native/1a/1addeb545.png",
                imageUrl: value.imageUrl,
                // shareTo: shareTo,
                shareType: shareType,
            };
            apeng._platform.sendToNative(apeng.ENativeSend.fbshare, JSON.stringify(shareInfo));
        }
        return {
            show: function (value, cb, query) {
                return show(value, cb, query);
            },
            circleFriends: function (value, cb, query) {
                return circleFriends(value, cb, query);
            },
            onShareAppMessage: function (cb) {
                return onShareAppMessage(cb);
            }
        };
    }
    apeng.AndroidFBShare = AndroidFBShare;
})(apeng || (apeng = {}));

(function (apeng) {
    function AndroidWxAndroidShare() {
        function checkShareResult(errCode, startTime) {
            let result = false;
            if (Number(errCode) == 1) {
                result = false;
            }
            else {
                if (apeng.Times.second() - startTime < apeng._platform.config.share.callTime)
                    result = false;
                else if (apeng.Times.second() - startTime > 30)
                    result = false;
                else
                    result = true;
            }
            return result;
        }
        /**
         * 好友列表
         */
        function show(value, cb, query) {
            if (!apeng.sys.isNative)
                return;
            onShareAppMessage(cb);
            onShareApp(value, apeng.WxShareScene.share_session, apeng.WxShareType.type_image);
        }
        /**
         * 朋友圈
         */
        function circleFriends(value, cb, query) {
            if (!apeng.sys.isNative)
                return;
            onShareAppMessage(cb);
            onShareApp(value, apeng.WxShareScene.share_timeline, apeng.WxShareType.type_image);
        }
        function onShareAppMessage(cb) {
            let shareTime = apeng.Times.second();
            apeng._platform.once(apeng.ENativeReceive.wxShareReturn, (errCode) => {
                cb && cb(checkShareResult(errCode, shareTime));
            });
        }
        function onShareApp(value, shareTo, shareType) {
            let shareInfo = {
                // shareUrl: "https://www.baidu.com/",
                shareUrl: value.query,
                // imageUrl: "http://webreview.cdwwlkj.com/cat/1.0.0/assets/bento/native/1a/1addeb545.png",
                imageUrl: value.imageUrl,
                shareTo: shareTo,
                shareType: shareType,
                title: value.title,
                desc: value.desc,
            };
            apeng._platform.sendToNative(apeng.ENativeSend.wxshare, JSON.stringify(shareInfo));
        }
        return {
            show: function (value, cb, query) {
                return show(value, cb, query);
            },
            circleFriends: function (value, cb, query) {
                return circleFriends(value, cb, query);
            },
            onShareAppMessage: function (cb) {
                return onShareAppMessage(cb);
            }
        };
    }
    apeng.AndroidWxAndroidShare = AndroidWxAndroidShare;
})(apeng || (apeng = {}));

(function (apeng) {
    let BaseScene = class BaseScene extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.CLOSE_ON_CC = true;
            this.backupDescribe = "场景基类(勿使用cocos生命周期)";
            this.openUIUrl = "";
            this.loadUrl = "";
            /**由mgr传入进来 */
            this._changeData = null;
            this._isOnCreate = false;
            this._onCreateByUpdateCb = null;
            this.isUpdate = false;
        }
        get enterCount() {
            return apeng._scene.getEnterCount(this.loadUrl);
        }
        get isPause() { return !this.isUpdate; }
        _onCreate() {
            apeng._scene.setEnterCount(this.loadUrl, 1);
            // 使update在 onCreate后执行
            if (this.onUpdate && this.onUpdate != this._onCreateByUpdate) {
                this._onCreateByUpdateCb = this.onUpdate;
                this.onUpdate = this._onCreateByUpdate;
            }
            this._onLoad();
            this._onEnable();
            if (this.openUIUrl)
                apeng._ui.open(this.openUIUrl, null, null, null, false);
            if (this.onCreate)
                this.onCreate();
            this._isOnCreate = true;
            this.isUpdate = true;
        }
        _onCreateByUpdate() {
            if (this._isOnCreate)
                this._onCreateByUpdateCb();
        }
        _onDispose() {
            this.isUpdate = false;
            this._isOnCreate = false;
            if (this.openUIUrl)
                apeng._ui.dispose(this.openUIUrl);
            this._onDisable();
            if (this.onDispose)
                this.onDispose();
            this.onDestroy();
        }
        pause() {
            this.isUpdate = false;
            if (this.onPause)
                this.onPause();
        }
        run(...args) {
            if (this.onRun)
                this.onRun(...args);
        }
        resume() {
            this.isUpdate = true;
            if (this.onResume)
                this.onResume();
        }
        preLoadScene(cb) {
            apeng._scene.preLoad(this.loadUrl, cb, null, false);
        }
    };
    __decorate([
        apeng.property({
            displayName: "显示ui 路径"
        })
    ], BaseScene.prototype, "openUIUrl", void 0);
    BaseScene = __decorate([
        apeng.ccclass("BaseScene"),
        apeng.menuScene("scene/BaseScene")
    ], BaseScene);
    apeng.BaseScene = BaseScene;
})(apeng || (apeng = {}));

(function (apeng) {
    let si;
    (function (si) {
        function _eGet(type) {
            return function (data) {
                return data[type];
            };
        }
        si._eGet = _eGet;
        function DateNow() {
            return Date.now();
        }
        si.DateNow = DateNow;
        si.ErrorCodeMap = {
            2000: "用户id解析错误",
            2001: "游戏id解析错误",
            2002: "携带参数错误",
            2003: "游戏对应appid或secret未配置",
            2004: "获取openid错误",
            2005: "服务器错误",
        };
        let EPlatformType;
        (function (EPlatformType) {
            EPlatformType[EPlatformType["web"] = 99] = "web";
            EPlatformType[EPlatformType["wx"] = 1] = "wx";
            EPlatformType[EPlatformType["qq"] = 2] = "qq";
            EPlatformType[EPlatformType["tt"] = 3] = "tt";
            EPlatformType[EPlatformType["vivo"] = 4] = "vivo";
            EPlatformType[EPlatformType["oppo"] = 5] = "oppo";
            /**华为 */
            EPlatformType[EPlatformType["hbs"] = 7] = "hbs";
            EPlatformType[EPlatformType["xiaomi"] = 8] = "xiaomi";
            /**海外xgame */
            EPlatformType[EPlatformType["overseas_android_xgame"] = 10] = "overseas_android_xgame";
            EPlatformType[EPlatformType["a360"] = 11] = "a360";
            /**快手海外 */
            EPlatformType[EPlatformType["overseas_kwai"] = 12] = "overseas_kwai";
            /**微游h5 */
            EPlatformType[EPlatformType["overseas_weiyou"] = 13] = "overseas_weiyou";
            /**国内快手 */
            EPlatformType[EPlatformType["ks"] = 14] = "ks";
            EPlatformType[EPlatformType["ios"] = 15] = "ios";
        })(EPlatformType = si.EPlatformType || (si.EPlatformType = {}));
        class SCSendDataBase {
        }
        si.SCSendDataBase = SCSendDataBase;
        class ApiSCSendBase {
            constructor() {
                /**时间戳 */
                this.timeTemp = DateNow();
            }
            static error(code, msg) {
                let v = new ApiSCSendBase();
                v.errorCode = code;
                if (msg !== undefined)
                    v.data = msg;
                return v;
            }
            static data(data) {
                let v = new ApiSCSendBase();
                v.data = data;
                return v;
            }
            static serializeData(data, source) {
                for (let key in data)
                    if (source[key])
                        data[key] = source[key];
                return this.data(data);
            }
        }
        si.ApiSCSendBase = ApiSCSendBase;
        class ParamBase {
        }
        si.ParamBase = ParamBase;
        class ParamData extends ParamBase {
            constructor(data) {
                super();
                this.data = data;
            }
        }
        si.ParamData = ParamData;
        class ParamGame extends ParamBase {
        }
        si.ParamGame = ParamGame;
        class ParamKeyCount extends ParamGame {
            constructor(
            /**配置config时的key */
            key, 
            /**数值 */
            count) {
                super();
                this.key = key;
                this.count = count;
            }
        }
        si.ParamKeyCount = ParamKeyCount;
        class ParamGameData extends ParamGame {
            constructor(data) {
                super();
                this.data = data;
            }
        }
        si.ParamGameData = ParamGameData;
        let User;
        (function (User) {
            class CSLogin extends ParamGame {
                constructor(
                /**获取到的jscode 服务器获取openid */
                jscode, 
                /**appid */
                appid, 
                /**直接使用此值创建用户 */
                openid, 
                /**平台 */
                platform) {
                    super();
                    this.jscode = jscode;
                    this.appid = appid;
                    this.openid = openid;
                    this.platform = platform;
                }
            }
            User.CSLogin = CSLogin;
            class CSInfo extends ParamGame {
                constructor(
                /**昵称 */
                name, 
                /**头像 */
                img_url) {
                    super();
                    this.name = name;
                    this.img_url = img_url;
                }
            }
            User.CSInfo = CSInfo;
            class SCLogin extends SCSendDataBase {
                constructor() {
                    super(...arguments);
                    /**昵称 */
                    this.name = "";
                    /**头像 */
                    this.img_url = "";
                    /**当前的uid */
                    this.uid = -1;
                    /**用户id */
                    this.user_id = "";
                }
            }
            User.SCLogin = SCLogin;
        })(User = si.User || (si.User = {}));
        let Rank;
        (function (Rank) {
            let ESCList;
            (function (ESCList) {
                /**数值 */
                ESCList[ESCList["count"] = 0] = "count";
                /**排名 */
                ESCList[ESCList["index"] = 1] = "index";
                /**名字 */
                ESCList[ESCList["name"] = 2] = "name";
                /**头像地址 */
                ESCList[ESCList["img_url"] = 3] = "img_url";
            })(ESCList = Rank.ESCList || (Rank.ESCList = {}));
            Rank.eGet = {
                "name": _eGet(ESCList.name),
                "count": _eGet(ESCList.count),
                "index": _eGet(ESCList.index),
                "img_url": _eGet(ESCList.img_url),
            };
            class SCData extends SCSendDataBase {
            }
            Rank.SCData = SCData;
            let ESCProvince;
            (function (ESCProvince) {
                /**配置表index索引 */
                ESCProvince[ESCProvince["index"] = 0] = "index";
                /**数值 */
                ESCProvince[ESCProvince["count"] = 1] = "count";
            })(ESCProvince = Rank.ESCProvince || (Rank.ESCProvince = {}));
            Rank.eGetProvince = {
                "index": _eGet(ESCProvince.index),
                "count": _eGet(ESCProvince.count),
            };
        })(Rank = si.Rank || (si.Rank = {}));
        let Custom;
        (function (Custom) {
            let ESCList;
            (function (ESCList) {
                /**实体id */
                ESCList[ESCList["id"] = 0] = "id";
                /**编号id */
                ESCList[ESCList["id_num"] = 1] = "id_num";
                /**玩的次数 */
                ESCList[ESCList["play_count"] = 2] = "play_count";
                /**通过次数 */
                ESCList[ESCList["play_success_count"] = 3] = "play_success_count";
                /**点赞次数 */
                ESCList[ESCList["like_count"] = 4] = "like_count";
                /**关卡数据 */
                ESCList[ESCList["data"] = 5] = "data";
                /**名字 */
                ESCList[ESCList["name"] = 6] = "name";
                /**头像地址 */
                ESCList[ESCList["img_url"] = 7] = "img_url";
                /**上传时间 */
                ESCList[ESCList["create_time"] = 8] = "create_time";
            })(ESCList = Custom.ESCList || (Custom.ESCList = {}));
            Custom.eGet = {
                "id": _eGet(ESCList.id),
                "id_num": _eGet(ESCList.id_num),
                "play_count": _eGet(ESCList.play_count),
                "play_success_count": _eGet(ESCList.play_success_count),
                "like_count": _eGet(ESCList.like_count),
                "data": _eGet(ESCList.data),
                "name": _eGet(ESCList.name),
                "img_url": _eGet(ESCList.img_url),
                "create_time": _eGet(ESCList.create_time),
            };
            class SCListAll extends SCSendDataBase {
            }
            Custom.SCListAll = SCListAll;
        })(Custom = si.Custom || (si.Custom = {}));
    })(si = apeng.si || (apeng.si = {}));
})(apeng || (apeng = {}));
/// <reference path="./../../component/BaseComponent.ts" />
/// <reference path="./../../component/AnimtorCC.ts" />

(function (apeng) {
    const _colorT = new apeng.Color(0, 0, 0, 255);
    let BaseUI = class BaseUI extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.CLOSE_ON_CC = true;
            this.backupDescribe = "UI组件(勿使用cocos生命周期)";
            /** 所在舞台下的层级 拥有先后顺序  ui所属层级*/
            this.layerType = apeng.EUILayer.Window;
            /**默认展示在界面最底部的广告，设计时留出位置 */
            this.bottomAdType = apeng.EBottomAdType.Jump;
            /**右上角积木广告 */
            this.blockOnceAdType = apeng.EBlockOnceAdType.Jump;
            this.isEventBlock = true;
            this.clickCloseUI = false;
            this.lockUIMgrAll = false;
            this.disposeByRelease = true;
            this.stageUp = false;
            this.delayNodes = [];
            this.autoPlayAnim = null;
            this._maskOpacityUI = 0;
            /**open时 预加载音效 */
            this.openByAudioUrls = null;
            /**真正加载的音效 */
            this.audioUrls = null;
            /**打开ui时的url */
            this.url = "";
            /**打开ui时 传入的数据 */
            this._openData = null;
            /**关闭ui时 给UImgr关闭回调 传入的数据 */
            this._closeData = null;
            /**只是预加载ui 位置移到屏幕以外 */
            this.__openShow = null;
            this._isOnCreate = false;
            this._onCreateByUpdateCb = null;
            this.onClickCloseUI2 = this.onClickCloseUI;
        }
        set maskOpacityUI(value) {
            this._maskOpacityUI = value;
            let node = this.getMaskOpacityUI();
            if (apeng.EDITOR) {
                let grap = node.getComponent(apeng.Graphics);
                grap.fillColor = _colorT.clone().set(0, 0, 0, this._maskOpacityUI * 255);
                grap.clear();
                let size = apeng.winSize();
                grap.rect(-size.width / 2, -size.height / 2, size.width, size.height);
                grap.fill();
            }
        }
        get maskOpacityUI() { return this._maskOpacityUI; }
        onLoad() {
            super.onLoad();
            if (apeng.EDITOR) {
                let falg = apeng.CCObject.Flags.IsPositionLocked
                    | apeng.CCObject.Flags.IsRotationLocked
                    | apeng.CCObject.Flags.IsScaleLocked
                    | apeng.CCObject.Flags.IsSizeLocked
                    | apeng.CCObject.Flags.IsAnchorLocked;
                this._objFlags = falg;
                this.node.setPosition(0, 0);
                this.setSize(apeng.winSize());
                this.maskOpacityUI = this._maskOpacityUI;
                if (this.onEditorByOnLoad)
                    this.onEditorByOnLoad();
            }
        }
        _onCreate() {
            // 使update在 onCreate后执行
            if (this.onUpdate && this.onUpdate != this._onCreateByUpdate) {
                this._onCreateByUpdateCb = this.onUpdate;
                this.onUpdate = this._onCreateByUpdate;
            }
            this._onLoad();
            if (this.isEventBlock) {
                let block = this.getComponent(apeng.BlockInputEvents);
                if (!block)
                    this.addComponent(apeng.BlockInputEvents);
            }
            this.setSize(apeng.winSize());
            this.getMaskOpacityUI();
            if (this.clickCloseUI)
                apeng.EventHandlerCC.onClick(this.node, this.onClickCloseUI, this);
            if (this.onCreate)
                this.onCreate();
        }
        _onCreateByUpdate() {
            if (this._isOnCreate)
                this._onCreateByUpdateCb();
        }
        updateOpenShow() {
            this.node.setPosition(this.__openShow ? 0 : -10000, 0);
        }
        _onOpen() {
            this.updateOpenShow();
            // 注册事件
            this._onEnable();
            let delay = 2;
            //  vivo平台没有延迟
            if (apeng._platform.type == apeng.EPlatformType.vivo
                || apeng._platform.type == apeng.EPlatformType.oppo
                || apeng._platform.type == apeng.EPlatformType.tt)
                delay = 0;
            if (delay != 0) {
                for (let node of this.delayNodes)
                    if (node)
                        node.active = false;
                this.scheduleOnce(() => {
                    for (let node of this.delayNodes)
                        if (node)
                            node.active = true;
                }, delay);
            }
            if (this.autoPlayAnim)
                this.autoPlayAnim.playDefault();
            if (this.openByAudioUrls) {
                this.audioUrls = typeof this.openByAudioUrls == "function" ? this.openByAudioUrls() : this.openByAudioUrls;
                if (this.audioUrls && this.audioUrls.length > 0)
                    this.scheduleOnceCover(this.onDelayLoadAudios, apeng._ui.delayProAudio);
            }
            if (this.onOpen)
                this.onOpen();
            this._isOnCreate = true;
        }
        onDelayLoadAudios() {
            for (let url of this.audioUrls)
                apeng._audio.load(url);
        }
        _onClose() {
            this._isOnCreate = false;
            this._onDisable();
            if (this.onClose)
                this.onClose();
        }
        _onDispose() {
            if (this.onDispose)
                this.onDispose();
            this.onDestroy();
        }
        onClickCloseUI(e, param = "") {
            if (this.onCloseUIClickBefore)
                this.onCloseUIClickBefore();
            this.closeUI(param == "destroy");
        }
        closeUI(destroy = false) {
            if (destroy)
                apeng._ui.dispose(this.url);
            else
                apeng._ui.close(this.url);
        }
        getMaskOpacityUI() {
            return this.getChildByCreate("MaskOpacityUI", (node) => {
                if (apeng.EDITOR)
                    node.addComponent(apeng.Graphics);
                else {
                    let sp = node.addComponent(apeng.Sprite);
                    sp.spriteFrame = apeng._resouces.getDefaultSpriteFrame();
                    sp.color = _colorT.clone().set(0, 0, 0, this._maskOpacityUI * 255);
                    node.addComponent("SpriteEnableFadeInCC");
                }
                apeng.NodeHelper.getUITransform(node).setContentSize(apeng.winSize());
            }, 0);
        }
        /**当前进入次数 */
        getOpenCount() {
            return apeng._ui.getModule(this.url).openCount;
        }
    };
    __decorate([
        apeng.property({
            displayName: "屏蔽下层事件"
        })
    ], BaseUI.prototype, "isEventBlock", void 0);
    __decorate([
        apeng.property({
            displayName: "点击关闭UI"
        })
    ], BaseUI.prototype, "clickCloseUI", void 0);
    __decorate([
        apeng.property({
            range: [0, 1, 0.1],
            slide: true,
            displayName: "透明蒙层"
        })
    ], BaseUI.prototype, "maskOpacityUI", null);
    __decorate([
        apeng.property({
            tooltip: "锁住当前ui 不让UImgr进行批量操作 屏蔽SceneMgr管理ui",
            displayName: "屏蔽批量操作"
        })
    ], BaseUI.prototype, "lockUIMgrAll", void 0);
    __decorate([
        apeng.property({
            tooltip: "销毁时，释放当前预制体资源",
            displayName: "释放资源"
        })
    ], BaseUI.prototype, "disposeByRelease", void 0);
    __decorate([
        apeng.property({
            tooltip: "默认在舞台层，添加到默认舞台的上层",
            displayName: "舞台上层"
        })
    ], BaseUI.prototype, "stageUp", void 0);
    __decorate([
        apeng.property({
            type: [apeng.Node],
            displayName: "延迟显示节点"
        })
    ], BaseUI.prototype, "delayNodes", void 0);
    __decorate([
        apeng.property({
            type: apeng.AnimtorCC,
            displayName: "显示时播放动画"
        })
    ], BaseUI.prototype, "autoPlayAnim", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], BaseUI.prototype, "_maskOpacityUI", void 0);
    BaseUI = __decorate([
        apeng.ccclass("BaseUI"),
        apeng.executeInEditMode,
        apeng.menuUI("BaseUI")
    ], BaseUI);
    apeng.BaseUI = BaseUI;
})(apeng || (apeng = {}));

(function (apeng) {
    const BtnColorMap = {
        red: new apeng.Color(243, 52, 52),
        black: new apeng.Color(0, 0, 0),
        darkBlue: new apeng.Color(96, 109, 142),
    };
    let Dialogue = class Dialogue extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cLabelContent = null;
            this.cLabelLeft = null;
            this.cLabelRight = null;
            this.cLabelCenter = null;
            this.btn = null;
            this.rightBtn = null;
            this.onClickLeft = this.onClickCenter;
        }
        onLoad() {
            super.onLoad();
            this.setSize(apeng.winSize());
        }
        init(content, btn, rightBtn) {
            this.btn = btn;
            this.rightBtn = rightBtn;
            if (this.rightBtn)
                this.ControllerCC.index = 0;
            else
                this.ControllerCC.index = 1;
            this.cLabelContent.string = content;
            if (this.ControllerCC.index == 0) {
                this.setBtnData(this.cLabelLeft, this.btn);
                this.setBtnData(this.cLabelRight, this.rightBtn);
            }
            else
                this.setBtnData(this.cLabelCenter, this.btn);
        }
        setBtnData(label, value) {
            label.string = value.text;
            if (value.color)
                label.color = BtnColorMap[value.color];
            else
                label.color = BtnColorMap["black"];
        }
        onClick() {
            apeng._ui.pool.put(this.node);
        }
        onClickRight() {
            apeng._ui.pool.put(this.node);
            if (this.rightBtn.onClick)
                this.rightBtn.onClick();
        }
        onClickCenter() {
            apeng._ui.pool.put(this.node);
            if (this.btn.onClick)
                this.btn.onClick();
        }
    };
    Dialogue = __decorate([
        apeng.ccclass("Dialogue"),
        apeng.menuUI("Dialogue")
    ], Dialogue);
    apeng.Dialogue = Dialogue;
})(apeng || (apeng = {}));

(function (apeng) {
    let FlyEffect = class FlyEffect extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cAItems = null;
            this.loadDir = new apeng.LoadDir(1, null);
        }
        init(start, end, iconUrl, itemUrl, itemCount, cb) {
            this.setPositionXY(start, true);
            let count = 0;
            if (itemCount) {
                if (typeof itemCount == "number")
                    count = itemCount;
                else
                    count = apeng.Maths.minToMax(itemCount[0], itemCount[1]);
            }
            else
                count = apeng.Maths.minToMax(10, 15);
            this.loadDir.count = count;
            this.loadDir.onFinish = () => {
                if (cb)
                    cb();
                apeng._ui.pool.put(this.node);
            };
            for (let i = 0; i < count; i++) {
                let item = apeng._ui.pool.get(itemUrl).getComponent("FlyEffectItem");
                this.cAItems.addChild(item.node);
                item.init(iconUrl, end, this.loadDir.subCount(), count);
            }
        }
    };
    FlyEffect = __decorate([
        apeng.ccclass("FlyEffect"),
        apeng.menuUI("FlyEffect")
    ], FlyEffect);
    apeng.FlyEffect = FlyEffect;
})(apeng || (apeng = {}));

(function (apeng) {
    const v3TScale = new apeng.Vec3(.6, .6, 0);
    let FlyEffectItem = class FlyEffectItem extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cb = null;
            this.count = null;
            this.v3T2 = new apeng.Vec3(.6, .6, 0);
        }
        init(iconUrl, end, cb, count) {
            apeng.Vector2.set(this.v3T2, end);
            this.SpriteLoaderCC.setSpriteFrameUrl(iconUrl, true);
            this.setPosition(apeng.Vector3.ZERO, false);
            this.setScaleNum(.1, false);
            this.cb = cb;
            this.count = count;
            apeng.TweenHelper.getTween(this.node, "FlyEffectItem", (_tween) => {
                let v3T = new apeng.Vec3();
                let time = apeng.Maths.minToMax(5, 7) / 10;
                let time_2 = apeng.Maths.minToMax(5, 7) / 10;
                _tween
                    .call(() => {
                    if (this.count != 1) {
                        time = apeng.Maths.minToMax(5, 7) / 10;
                        time_2 = apeng.Maths.minToMax(5, 7) / 10;
                        apeng.TweenHelper.setDuration(_tween, 1, time);
                        apeng.TweenHelper.setDuration(_tween, 2, time_2);
                        let starNumx = apeng.Maths.minToMax(-100, 100);
                        let starNumy = 100 - Math.abs(starNumx);
                        let starSymbolNumy = apeng.Maths.isRandom(0.5) ? 0 - starNumy : starNumy;
                        apeng.Vector3.set(v3T, starNumx, starSymbolNumy);
                    }
                    else
                        apeng.Vector3.set(v3T);
                })
                    .by(time, { position: v3T, scale: v3TScale }, { easing: "quadOut" })
                    .to(time_2, { worldPosition: this.v3T2 }, { easing: "quadIn" })
                    .call(() => {
                    apeng._ui.pool.put(this.node);
                    this.cb();
                });
                return {};
            })
                .start();
        }
    };
    FlyEffectItem = __decorate([
        apeng.ccclass("FlyEffectItem"),
        apeng.menuUI("FlyEffectItem")
    ], FlyEffectItem);
    apeng.FlyEffectItem = FlyEffectItem;
})(apeng || (apeng = {}));

(function (apeng) {
    let LoadingScreen = class LoadingScreen extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this._isVisible = false;
            this.state = apeng.ETipWhiteState.Hide;
            this.showCb = null;
        }
        onLoad() {
            super.onLoad();
            this.setOpacity(0);
        }
        onUpdate() {
            let opacity = this.getOpacity();
            if (this._isVisible) {
                if (opacity != 1) {
                    opacity = apeng.Maths.clamp01(opacity + apeng._timer.dtDefault * 2);
                    this.setOpacity(opacity);
                }
                else {
                    if (this.state == apeng.ETipWhiteState.Showing) {
                        this.state = apeng.ETipWhiteState.Show;
                        if (this.showCb) {
                            this.showCb();
                            this.showCb = null;
                        }
                    }
                }
            }
            else {
                opacity = apeng.Maths.clamp01(opacity - apeng._timer.dtDefault);
                if (opacity < .01) {
                    opacity = 0;
                    this.node.active = false;
                    if (this.state == apeng.ETipWhiteState.Hideing)
                        this.state = apeng.ETipWhiteState.Hide;
                    return;
                }
                this.setOpacity(opacity);
            }
        }
        init(visible) {
            this.showCb = null;
            this._isVisible = visible;
            this.node.active = true;
            if (this._isVisible) {
                this.setOpacity(0);
                this.state = apeng.ETipWhiteState.Showing;
            }
            else {
                this.setOpacity(1);
                this.state = apeng.ETipWhiteState.Hideing;
            }
        }
    };
    LoadingScreen = __decorate([
        apeng.ccclass("LoadingScreen"),
        apeng.menuUI("LoadingScreen")
    ], LoadingScreen);
    apeng.LoadingScreen = LoadingScreen;
})(apeng || (apeng = {}));

(function (apeng) {
    let LoadingWait = class LoadingWait extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.isScene = false;
            this.clickClose = false;
            this.cLabelTip = null;
            this.tipIndex = 0;
            this.state = apeng.ETipWaitState.Hide;
            this.completeCb = null;
        }
        onLoad() {
            super.onLoad();
            this.setSize(apeng.winSize());
        }
        onUpdate() {
            return;
        }
        // private onLoop() {
        // 	this.tipIndex = (this.tipIndex + 1) % tips.length
        // 	this.cLabelTip.string = tips[this.tipIndex]
        // }
        /**
         *
         * @param clickClose
         * @param progress
         * @param duration 持续的时间
         */
        init(visible, clickClose = false, progress, duration) {
            this.setNodeActive(visible);
            if (!visible) {
                // TimerMgr.clear(this, this.onLoop)
                return;
            }
            if (visible)
                this.clickClose = clickClose;
            this.state = apeng.ETipWaitState.Loading;
            this.completeCb = null;
            // if (this.cLabelTip)
            // 	TimerMgr.loop(this, this.onLoop, _config_.Object.init[13][0], -1, -1)
            return;
            // if (!this.ProgressCC)
            // 	return
            // if (!progress)
            // 	progress = () => 0
            // this.ProgressCC.run(progress, duration)
            if (this.cLabelTip)
                if (this.isScene) {
                    // let ids = _config_.Object.user_related_table[22] as number[]
                    // this.cLabelTip.string = _language.get(ids[SceneMgr.enterCountAll % ids.length])
                }
        }
        setNodeActive(visible) {
            this.node.active = visible;
        }
        onClick() {
            if (this.clickClose)
                this.init(false);
        }
    };
    __decorate([
        apeng.property({
            displayName: "切换场景时 显示文字"
        })
    ], LoadingWait.prototype, "isScene", void 0);
    LoadingWait = __decorate([
        apeng.ccclass("LoadingWait"),
        apeng.menuUI("LoadingWait")
    ], LoadingWait);
    apeng.LoadingWait = LoadingWait;
})(apeng || (apeng = {}));

(function (apeng) {
    let MoveUpItem = class MoveUpItem extends apeng.BaseComponent {
        init(startWorldPosition, text, iconUrl, complete) {
            this.Label.string = text;
            if (iconUrl) {
                this.SpriteLoaderCC.node.active = true;
                this.SpriteLoaderCC.setSpriteFrameUrl(iconUrl);
            }
            else
                this.SpriteLoaderCC.node.active = false;
            this.setPositionXY(startWorldPosition, true);
            this.AnimtorCC.playDefault(complete);
        }
    };
    MoveUpItem = __decorate([
        apeng.ccclass("MoveUpItem"),
        apeng.menuUI("MoveUpItem")
    ], MoveUpItem);
    apeng.MoveUpItem = MoveUpItem;
})(apeng || (apeng = {}));

(function (apeng) {
    let Tip = class Tip extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cb = new apeng.CompleteCallBack();
        }
        onLoad() {
            super.onLoad();
            this.Label.string = "";
            this.addEvent(apeng.Node.EventType.SIZE_CHANGED, () => { this.scheduleOnceCover(this.onLabelSize); }, this, this.Label.node);
        }
        init(str, closeCb) {
            this.Label.string = str;
            this.scheduleOnceCover(this.onLabelSize);
            this.cb.set(closeCb);
            if (this.AnimtorCC) {
                this.AnimtorCC.stop();
                this.AnimtorCC.playDefault(this.put.bind(this));
            }
            else {
                if (this.AnimtorByTweenCC)
                    this.AnimtorByTweenCC.play(this.put.bind(this));
            }
        }
        put() {
            this.cb.run();
            if (!this.isVisible)
                return;
            apeng._ui.pool.put(this.node);
        }
        onLabelSize() {
            // if (NodeHelper.getUITransform(this.Label.node).height > this.Label.lineHeight)
            // 	this.Label.horizontalAlign = Label.HorizontalAlign.LEFT
            // else
            // 	this.Label.horizontalAlign = Label.HorizontalAlign.CENTER
        }
    };
    Tip = __decorate([
        apeng.ccclass("Tip"),
        apeng.menuUI("Tip")
    ], Tip);
    apeng.Tip = Tip;
})(apeng || (apeng = {}));

(function (apeng) {
    let TipClick = class TipClick extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cb = new apeng.CompleteCallBack();
        }
        onLoad() {
            super.onLoad();
            this.node.setPosition(0, 0);
            this.setSize(apeng.winSize());
            if (!apeng.EDITOR)
                this.Label.string = "";
        }
        init(str, closeCb) {
            this.Label.string = str;
            this.cb.set(closeCb);
        }
        onClick() {
            apeng._ui.pool.put(this.node);
            this.cb.run();
        }
    };
    TipClick = __decorate([
        apeng.ccclass("TipClick"),
        apeng.menuUI("TipClick")
    ], TipClick);
    apeng.TipClick = TipClick;
})(apeng || (apeng = {}));

(function (apeng) {
    let TipTitleClick = class TipTitleClick extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cLabel_downTip = null;
            this.cb = new apeng.CompleteCallBack();
        }
        get spriteEnableFadeInCC() { return this.getCacheComponent("SpriteEnableFadeInCC"); }
        onLoad() {
            super.onLoad();
            this.node.setPosition(0, 0);
            this.setSize(apeng.winSize());
        }
        init(datas, title, closeCb, showDot = true, autoClose = false, downTip = "") {
            if (downTip) {
                this.cLabel_downTip.node.active = true;
                this.cLabel_downTip.string = downTip;
            }
            else
                this.cLabel_downTip.node.active = false;
            if (title) {
                this.Label.node.parent.active = true;
                this.Label.string = title;
            }
            else
                this.Label.node.parent.active = false;
            this.CreatePrefabToEditorCC.render(datas, apeng.TipTitleClickItem, (comp, data) => {
                comp.init(data, showDot, datas.length <= 1);
            });
            this.cb.set(closeCb);
            if (autoClose) {
                this.scheduleOnceCover(this.onClick, 2.5);
                this.spriteEnableFadeInCC.node.active = false;
            }
            else
                this.spriteEnableFadeInCC.node.active = true;
        }
        onClick() {
            apeng._ui.pool.put(this.node);
            this.cb.run();
        }
    };
    TipTitleClick = __decorate([
        apeng.ccclass("TipTitleClick"),
        apeng.executeInEditMode,
        apeng.menuUI("TipTitleClick")
    ], TipTitleClick);
    apeng.TipTitleClick = TipTitleClick;
})(apeng || (apeng = {}));

(function (apeng) {
    let TipTitleClickItem = class TipTitleClickItem extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.cLabel_right = null;
        }
        init(data, dotVisible, horizontalCenter) {
            this.autoMember();
            this.Sprite.node.active = dotVisible;
            let dec = data;
            if (typeof data != "string") {
                dec = data.curStr;
                if (data.rightStr) {
                    this.cLabel_right.node.active = true;
                    this.cLabel_right.string = data.rightStr;
                    if (data.rightColor)
                        this.cLabel_right.color = data.rightColor;
                    else
                        this.cLabel_right.color = this.Label.color;
                }
                else
                    this.cLabel_right.node.active = false;
            }
            else
                this.cLabel_right.node.active = false;
            this.Label.string = dec;
            this.Label.horizontalAlign = horizontalCenter ? apeng.Label.HorizontalAlign.CENTER : apeng.Label.HorizontalAlign.LEFT;
            //--如果只有一行，不显示点
            this.Sprite.node.active = !horizontalCenter;
        }
    };
    TipTitleClickItem = __decorate([
        apeng.ccclass("TipTitleClickItem"),
        apeng.menuUI("TipTitleClickItem")
    ], TipTitleClickItem);
    apeng.TipTitleClickItem = TipTitleClickItem;
})(apeng || (apeng = {}));

(function (apeng) {
    var P2ShapeEditorCC_1;
    const sizeT = new apeng.Size();
    const v3T = new apeng.Vec3();
    let EP2ShapeTypeCC;
    (function (EP2ShapeTypeCC) {
        EP2ShapeTypeCC[EP2ShapeTypeCC["None"] = 0] = "None";
        EP2ShapeTypeCC[EP2ShapeTypeCC["Circle"] = 1] = "Circle";
        EP2ShapeTypeCC[EP2ShapeTypeCC["Point"] = 2] = "Point";
        /**只能是凸多边形 */
        EP2ShapeTypeCC[EP2ShapeTypeCC["Polygon"] = 3] = "Polygon";
        EP2ShapeTypeCC[EP2ShapeTypeCC["Box"] = 4] = "Box";
        // 未生效 不清楚原因
        EP2ShapeTypeCC[EP2ShapeTypeCC["Plane"] = 5] = "Plane";
        // 未生效 不清楚原因
        EP2ShapeTypeCC[EP2ShapeTypeCC["Line"] = 6] = "Line";
        // 未生效 不清楚原因
        EP2ShapeTypeCC[EP2ShapeTypeCC["Heightfield"] = 7] = "Heightfield";
    })(EP2ShapeTypeCC || (EP2ShapeTypeCC = {}));
    apeng.ccenum(EP2ShapeTypeCC);
    const v2T = new apeng.Vector2();
    let P2ShapeEditorCC = P2ShapeEditorCC_1 = class P2ShapeEditorCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.EventType = {
                LERP_POS_COMPLETE: "LERP_POS_COMPLETE"
            };
            this.backupDescribe = "物理形状";
            this.mass = 0;
            this.trigger = false;
            this.velocity = new apeng.Vec2();
            this.velocityScale = 0;
            this.damping = 0;
            this.fixedX = false;
            this.fixedY = false;
            this.fixedRotation = false;
            this.angularVelocity = 0;
            this.angularDamping = 0;
            this.editorColor = new apeng.Color(0, 255, 0);
            this.editorLineWidth = 6;
            this.runEditorShow = true;
            this.tag = "";
            this.shapePanle = "x无限长,大于y可移动(小于等于y物理块)";
            this.bodyNodeOffset = null;
            this.syncNodePosition = null;
            this.syncNodePositionLerp = .1;
            this.syncNodeAngle = null;
            this.receiveMaterial = false;
            this.openMaterial = false;
            this.materialFriction = .5;
            this.materialFrictionRelaxation = 4;
            this.materialFrictionStiffness = 1e6;
            this.materialRelaxation = 4;
            this.materialRestitution = 0;
            this.materialStiffness = 1e6;
            this.materialSurfaceVelocity = 0;
            this.materialContactSkinSize = .005;
            this._shapeType = EP2ShapeTypeCC.None;
            this._useNodeSize = true;
            this._circleRadius = 0;
            this._lineLength = 1;
            this._heightfieldLength = 100;
            this._circleLength = 0;
            this._boxSize = new apeng.Size();
            this._shapeOffset = new apeng.Vec2();
            this._poygonPoints = [];
            this._heightfields = [];
            this.onEditorUpdateData = this.updateCCGraphics;
            this.shape = null;
            this.body = null;
            this._lerpBodyPos = new apeng.Vector2();
            /**形状宽度 */
            this.areaWidth = 0;
            this.lerpBodyPosLowRatio = .01;
            /**很慢的插值跟随点 */
            this.lerpBodyPosLow = new apeng.Vector2();
            this.isCreateBody = false;
            this.lastBodyAngle = null;
            /**开启的所有 材质实例 */
            this.openMaterials = [];
        }
        set shapeType(value) {
            if (this._shapeType == value)
                return;
            this._shapeType = value;
            this.updateNodeSize();
            this.updateCCGraphics();
        }
        get shapeType() { return this._shapeType; }
        set heightfieldLength(value) {
            if (this._heightfieldLength == value)
                return;
            this._heightfieldLength = value;
            this.updateCCGraphics();
        }
        get heightfieldLength() { return this._heightfieldLength; }
        set heightfields(value) {
            this._heightfields = value;
            this.updateCCGraphics();
        }
        get heightfields() { return this._heightfields; }
        set lineLength(value) {
            if (this._lineLength == value)
                return;
            this._lineLength = value;
            this.updateCCGraphics();
        }
        get lineLength() { return this._lineLength; }
        set circleRadius(value) {
            if (this._circleRadius == value)
                return;
            this._circleRadius = value;
            this.updateCCGraphics();
        }
        get circleRadius() { return this._circleRadius; }
        set circleLength(value) {
            if (this._circleLength == value)
                return;
            this._circleLength = value;
            this.updateCCGraphics();
        }
        get circleLength() { return this._circleLength; }
        set boxSize(value) {
            if (this._boxSize.equals(value))
                return;
            this._boxSize.set(value);
            this.updateCCGraphics();
        }
        get boxSize() { return this._boxSize; }
        set poygonPoints(value) {
            this._poygonPoints = value;
            this.updateCCGraphics();
        }
        get poygonPoints() { return this._poygonPoints; }
        set shapeOffset(value) {
            if (this._shapeOffset.equals(value))
                return;
            this._shapeOffset.set(value);
            this.updateCCGraphics();
        }
        get shapeOffset() { return this._shapeOffset; }
        set useNodeSize(value) {
            if (this._useNodeSize == value)
                return;
            this._useNodeSize = value;
            this.updateNodeSize();
            this.updateCCGraphics();
        }
        get useNodeSize() { return this._useNodeSize; }
        onLoad() {
            super.onLoad();
            this.updateNodeSize();
            if (!apeng.EDITOR)
                this.updateCCGraphics();
        }
        updateNodeSize() {
            sizeT.set(this.UITransform.contentSize);
            switch (this._shapeType) {
                case EP2ShapeTypeCC.Circle:
                    if (this._useNodeSize || this._circleRadius == 0) {
                        if (sizeT.width == sizeT.height) {
                            this._circleLength = 0;
                            this.circleRadius = this.UITransform.width / 2;
                        }
                        else {
                            if (sizeT.width > sizeT.height) {
                                // x轴延伸
                                this._circleLength = sizeT.width - sizeT.height;
                                this.circleRadius = sizeT.height / 2;
                            }
                        }
                    }
                    break;
                case EP2ShapeTypeCC.Box:
                    if (this._useNodeSize || (this._boxSize.width == 0 && this._boxSize.height == 0))
                        this.boxSize = sizeT;
                    break;
                case EP2ShapeTypeCC.Polygon:
                    if (this._useNodeSize || this._poygonPoints.length == 0) {
                        let points = [];
                        for (let i = 0; i < 4; i++) {
                            if (i == 0)
                                points[i] = new apeng.Vec2(-sizeT.width / 2, -sizeT.height / 2);
                            else if (i == 1)
                                points[i] = new apeng.Vec2(sizeT.width / 2, -sizeT.height / 2);
                            else if (i == 2)
                                points[i] = new apeng.Vec2(sizeT.width / 2, sizeT.height / 2);
                            else if (i == 3)
                                points[i] = new apeng.Vec2(-sizeT.width / 2, sizeT.height / 2);
                        }
                        this._poygonPoints = points;
                    }
                    break;
                case EP2ShapeTypeCC.Line:
                    if (this._useNodeSize)
                        this._lineLength = sizeT.width;
                    break;
            }
        }
        onFocusInEditor() {
            this.updateCCGraphics();
        }
        onLostFocusInEditor() {
            if (this._shapeType == EP2ShapeTypeCC.None)
                return;
            this.getGraphics().clear();
        }
        onEnable() {
            super.onEnable();
            this.lastBodyAngle = null;
        }
        onUpdate() {
            if (this.body) {
                if (this.syncNodePosition) {
                    if (this.syncNodePositionLerp > 0)
                        v2T.set(this.lerpBodyPos(this.syncNodePositionLerp));
                    else
                        v2T.set(this.body.position);
                    if (this.bodyNodeOffset != this.syncNodePosition)
                        if (this.bodyNodeOffset)
                            v2T.subSelf(this.bodyNodeOffset.position);
                    apeng.NodeHelper.setPositionXY(this.syncNodePosition, v2T, false);
                }
                if (this.syncNodeAngle) {
                    if (this.lastBodyAngle != this.body.angle)
                        apeng.NodeHelper.setRotateZ(this.syncNodeAngle, apeng.Maths.toDegree(this.body.angle, false), false);
                    this.lastBodyAngle = this.body.angle;
                }
            }
        }
        updateCCGraphics() {
            if (!P2ShapeEditorCC_1.debug)
                return;
            if (!apeng.EDITOR)
                if (!this.runEditorShow)
                    return;
            if (this._shapeType == EP2ShapeTypeCC.None)
                return;
            let grap = this.getGraphics();
            grap.strokeColor = this.editorColor;
            grap.lineWidth = this.editorLineWidth;
            grap.fillColor = this.editorColor;
            grap.clear();
            let oX = this._shapeOffset.x;
            let oY = this._shapeOffset.y;
            switch (this._shapeType) {
                case EP2ShapeTypeCC.Circle:
                    if (this._circleLength > 0) {
                        let cetner = this._circleLength / 2;
                        let h = this._circleRadius;
                        grap.arc(-cetner + oX, oY, h, Math.PI / 2, Math.PI * 1.5, true);
                        grap.arc(cetner + oX, oY, h, Math.PI / 2, Math.PI * 1.5, false);
                        grap.moveTo(-cetner + oX, h + oY);
                        grap.lineTo(cetner + oX, h + oY);
                        grap.moveTo(-cetner + oX, -h + oY);
                        grap.lineTo(cetner + oX, -h + oY);
                    }
                    else
                        grap.circle(oX, oY, this._circleRadius);
                    grap.stroke();
                    break;
                case EP2ShapeTypeCC.Box:
                    grap.rect(oX - this._boxSize.width / 2, oY - this._boxSize.height / 2, this._boxSize.width, this._boxSize.height);
                    grap.stroke();
                    break;
                case EP2ShapeTypeCC.Polygon:
                    if (this._poygonPoints.length > 2) {
                        grap.moveTo(this._poygonPoints[0].x + oX, this._poygonPoints[0].y + oY);
                        for (let i = 1, length = this._poygonPoints.length + 1; i < length; i++) {
                            let index = i == (length - 1) ? 0 : i;
                            let point = this._poygonPoints[index];
                            grap.lineTo(point.x + oX, point.y + oY);
                        }
                        grap.stroke();
                    }
                    break;
                case EP2ShapeTypeCC.Point:
                    grap.circle(oX, oY, 5);
                    grap.fill();
                    break;
                case EP2ShapeTypeCC.Plane:
                    let w = 4000, h = 2000;
                    grap.rect(-w / 2, -h + oY, w, h);
                    grap.fill();
                    break;
                case EP2ShapeTypeCC.Line:
                    grap.moveTo(-this._lineLength / 2 + oX, oY);
                    grap.lineTo(this._lineLength / 2 + oX, oY);
                    grap.stroke();
                    break;
                case EP2ShapeTypeCC.Heightfield:
                    if (this._heightfields.length > 1) {
                        grap.moveTo(oX, -1000 + oY);
                        for (let i = 0; i < this._heightfields.length; i++) {
                            let x = i * this._heightfieldLength;
                            let y = this._heightfields[i];
                            grap.lineTo(x + oX, y + oY);
                        }
                        grap.lineTo((this._heightfields.length - 1) * this._heightfieldLength + oX, -1000 + oY);
                        grap.fill();
                    }
                    break;
            }
        }
        getGraphics() {
            return this.getChildByCreate(this.uuid + "graphics", (node) => {
                node.addComponent(apeng.Graphics);
            }).getComponent(apeng.Graphics);
        }
        createBody(p2Group, type) {
            this.isCreateBody = false;
            if (this.body)
                return this.body;
            if (this._shapeType == EP2ShapeTypeCC.None)
                return this.body;
            this.isCreateBody = true;
            let pos = this.getCurPos();
            let position = [pos.x, pos.y];
            if (this._shapeType == EP2ShapeTypeCC.Plane)
                position[0] = 0;
            this.body = new p2.Body({
                type: this.mass == 0 ? p2.Body.STATIC : (this.trigger ? p2.Body.KINEMATIC : p2.Body.DYNAMIC),
                mass: this.mass,
                position,
                gravityScale: this.velocityScale,
                velocity: [this.velocity.x, this.velocity.y],
                angle: apeng.Maths.toRadian(this.node.angle),
                angularVelocity: this.angularVelocity,
                fixedRotation: this.fixedRotation,
                allowSleep: false,
                collisionResponse: !this.trigger,
                angularDamping: this.angularDamping,
                damping: this.damping,
                fixedX: this.fixedX,
                fixedY: this.fixedY,
            });
            this.body.comp = this;
            let scale = this.node.scale.x;
            switch (this._shapeType) {
                case EP2ShapeTypeCC.Circle:
                    if (this._circleLength > 0) {
                        this.shape = new p2.Capsule(this.groupParam(p2Group, type, {
                            length: this._circleLength * scale,
                            radius: this._circleRadius * scale,
                        }));
                    }
                    else
                        this.shape = new p2.Circle(this.groupParam(p2Group, type, {
                            radius: this._circleRadius * scale,
                        }));
                    break;
                case EP2ShapeTypeCC.Point:
                    this.shape = new p2.Particle(this.groupParam(p2Group, type, {}));
                    break;
                case EP2ShapeTypeCC.Box:
                    this.shape = new p2.Box(this.groupParam(p2Group, type, {
                        width: this._boxSize.width * scale,
                        height: this._boxSize.height * scale,
                    }));
                    break;
                case EP2ShapeTypeCC.Polygon:
                    if (this._poygonPoints.length > 2) {
                        let vertices = [];
                        for (let v of this._poygonPoints)
                            vertices.push([v.x * scale, v.y * scale]);
                        this.shape = new p2.Convex(this.groupParam(p2Group, type, {
                            vertices,
                        }));
                    }
                    break;
                case EP2ShapeTypeCC.Plane:
                    this.shape = new p2.Plane(this.groupParam(p2Group, type, {}));
                    break;
                case EP2ShapeTypeCC.Line:
                    this.shape = new p2.Line(this.groupParam(p2Group, type, {
                        length: this._lineLength
                    }));
                    break;
                case EP2ShapeTypeCC.Heightfield:
                    this.shape = new p2.Heightfield(this.groupParam(p2Group, type, {
                        heights: this._heightfields,
                        elementWidth: this._heightfieldLength,
                    }));
                    break;
            }
            this.body.addShape(this.shape);
            this.areaWidth = Math.sqrt(this.shape.area);
            return this.body;
        }
        groupParam(p2Group, type, obj) {
            let _obj = obj;
            _obj.collisionMask = p2Group.getMask(type);
            _obj.collisionGroup = p2Group.getGroup(type);
            _obj.position = [this._shapeOffset.x, this._shapeOffset.y];
            _obj.sensor = this.trigger;
            if (this.receiveMaterial
                || this.openMaterial)
                _obj.material = new p2.Material();
            return _obj;
        }
        updateOffset(x, y) {
            this._shapeOffset.set(x, y);
            this.shape.position[0] = this._shapeOffset.x;
            this.shape.position[1] = this._shapeOffset.y;
            this.shape.updateBoundingRadius();
            this.body.updateBoundingRadius();
        }
        updateTransform(isPos, isScale, isAngle, scaleRatio = 1) {
            if (isPos) {
                let pos = this.getCurPos();
                if (this._shapeType != EP2ShapeTypeCC.Plane)
                    this.body.position[0] = pos.x;
                this.body.position[1] = pos.y;
            }
            if (isAngle) {
                let angle = apeng.Maths.toRadian(this.node.angle);
                this.body.angle = angle;
            }
            if (isScale) {
                let scale = Math.abs(this.node.scale.x) * scaleRatio;
                switch (this._shapeType) {
                    case EP2ShapeTypeCC.Circle:
                        if (this._circleLength > 0) {
                            this.shape.length = this._circleLength * scale;
                            this.shape.radius = this._circleRadius * scale;
                        }
                        else
                            this.shape.radius = this._circleRadius * scale;
                        break;
                    case EP2ShapeTypeCC.Point:
                        break;
                    case EP2ShapeTypeCC.Box:
                        this.shape.width = this._boxSize.width * scale;
                        this.shape.height = this._boxSize.height * scale;
                        break;
                    case EP2ShapeTypeCC.Polygon:
                        for (let i = 0; i < this._poygonPoints.length; i++) {
                            let vertices = this.shape.vertices;
                            let v = this._poygonPoints[i];
                            vertices[i][0] = v.x * scale;
                            vertices[i][1] = v.y * scale;
                        }
                        break;
                }
            }
            if (isPos || isAngle || isScale) {
                this.shape.updateBoundingRadius();
                this.body.updateBoundingRadius();
            }
            if (isScale)
                this.areaWidth = Math.sqrt(this.shape.area);
        }
        getCurPos() {
            if (this.bodyNodeOffset)
                return apeng.Vector2.add(v2T, this.bodyNodeOffset.position, this.node.position);
            return this.node.position;
        }
        lerpBodyPos(ratio) {
            let pos = this.body.position;
            v2T.set(pos);
            apeng.Vector2.lerp(this.lerpBodyPosLow, this.lerpBodyPosLow, v2T, this.lerpBodyPosLowRatio);
            if (apeng.Vector2.equalsZero(v2T, this._lerpBodyPos))
                return this._lerpBodyPos;
            apeng.Vector2.lerp(this._lerpBodyPos, this._lerpBodyPos, v2T, ratio * apeng._timer.dtSecond);
            if (apeng.Vector2.distance(v2T, this._lerpBodyPos) < .1) {
                this.node.emit(this.EventType.LERP_POS_COMPLETE);
                this._lerpBodyPos.set(v2T);
            }
            return this._lerpBodyPos;
        }
        setBodyVelocity(x, y) {
            this.body.velocity[0] = x;
            this.body.velocity[1] = y;
        }
        setBodyPos(x, y) {
            this.body.position[0] = x;
            this.body.position[1] = y;
            this._lerpBodyPos.x = x;
            this._lerpBodyPos.y = y;
            this.lerpBodyPosLow.x = x;
            this.lerpBodyPosLow.y = y;
        }
        setBodyAngle(angle) {
            angle = apeng.Maths.toRadian(angle);
            this.body.angle = angle;
        }
        createContackMaterial(receive) {
            if (!this.openMaterial)
                return;
            let mat = new p2.ContactMaterial(receive.shape.material, this.shape.material, {
                friction: this.materialFriction,
                frictionRelaxation: this.materialFrictionRelaxation,
                frictionStiffness: this.materialFrictionStiffness,
                relaxation: this.materialRelaxation,
                restitution: this.materialRestitution,
                stiffness: this.materialStiffness,
                surfaceVelocity: this.materialSurfaceVelocity,
            });
            mat.contactSkinSize = this.materialContactSkinSize;
            mat.comp = this;
            return mat;
        }
    };
    /**开启碰撞框调试 */
    P2ShapeEditorCC.debug = true;
    __decorate([
        apeng.property({
            displayName: "质量(0静态)",
            min: 0,
        })
    ], P2ShapeEditorCC.prototype, "mass", void 0);
    __decorate([
        apeng.property({
            displayName: "触发器(无物理)",
        })
    ], P2ShapeEditorCC.prototype, "trigger", void 0);
    __decorate([
        apeng.property({
            displayName: "线性速度",
            visible() { return this.mass != 0; },
        })
    ], P2ShapeEditorCC.prototype, "velocity", void 0);
    __decorate([
        apeng.property({
            displayName: "世界重力倍数",
            visible() { return this.mass != 0; },
            min: 0,
        })
    ], P2ShapeEditorCC.prototype, "velocityScale", void 0);
    __decorate([
        apeng.property({
            displayName: "线性速度衰减系数(摩擦力)",
            range: [0, 1, .001],
            slide: true,
        })
    ], P2ShapeEditorCC.prototype, "damping", void 0);
    __decorate([
        apeng.property({
            displayName: "固定x轴",
            visible() { return this.mass != 0; },
        })
    ], P2ShapeEditorCC.prototype, "fixedX", void 0);
    __decorate([
        apeng.property({
            displayName: "固定y轴",
            visible() { return this.mass != 0; },
        })
    ], P2ShapeEditorCC.prototype, "fixedY", void 0);
    __decorate([
        apeng.property({
            displayName: "固定角度",
            visible() { return this.mass != 0; },
        })
    ], P2ShapeEditorCC.prototype, "fixedRotation", void 0);
    __decorate([
        apeng.property({
            displayName: "角速度(旋转)",
            visible() { return this.mass != 0 && !this.fixedRotation; },
        })
    ], P2ShapeEditorCC.prototype, "angularVelocity", void 0);
    __decorate([
        apeng.property({
            displayName: "角速度衰减系数(摩擦力)",
            range: [0, 1, .001],
            slide: true,
        })
    ], P2ShapeEditorCC.prototype, "angularDamping", void 0);
    __decorate([
        apeng.property({
            displayName: "编辑框颜色"
        })
    ], P2ShapeEditorCC.prototype, "editorColor", void 0);
    __decorate([
        apeng.property({
            displayName: "编辑框线宽"
        })
    ], P2ShapeEditorCC.prototype, "editorLineWidth", void 0);
    __decorate([
        apeng.property({
            displayName: "运行时显示线框"
        })
    ], P2ShapeEditorCC.prototype, "runEditorShow", void 0);
    __decorate([
        apeng.property({
            tooltip: "当有多个组件挂在相同节点时 方便区分"
        })
    ], P2ShapeEditorCC.prototype, "tag", void 0);
    __decorate([
        apeng.property({
            type: EP2ShapeTypeCC,
            displayName: "碰撞器类型"
        })
    ], P2ShapeEditorCC.prototype, "shapeType", null);
    __decorate([
        apeng.property({
            displayName: "点间距",
            visible() { return this._shapeType == EP2ShapeTypeCC.Heightfield; }
        })
    ], P2ShapeEditorCC.prototype, "heightfieldLength", null);
    __decorate([
        apeng.property({
            type: apeng.CCFloat,
            displayName: "高度点",
            visible() { return this._shapeType == EP2ShapeTypeCC.Heightfield; }
        })
    ], P2ShapeEditorCC.prototype, "heightfields", null);
    __decorate([
        apeng.property({
            readonly: true,
            displayName: "平面",
            visible() { return this._shapeType == EP2ShapeTypeCC.Plane; }
        })
    ], P2ShapeEditorCC.prototype, "shapePanle", void 0);
    __decorate([
        apeng.property({
            displayName: "X长度",
            visible() { return this._shapeType == EP2ShapeTypeCC.Line; }
        })
    ], P2ShapeEditorCC.prototype, "lineLength", null);
    __decorate([
        apeng.property({
            displayName: "半径",
            visible() { return this._shapeType == EP2ShapeTypeCC.Circle; }
        })
    ], P2ShapeEditorCC.prototype, "circleRadius", null);
    __decorate([
        apeng.property({
            displayName: "胶囊(x轴长度 宽>高)",
            visible() { return this._shapeType == EP2ShapeTypeCC.Circle; }
        })
    ], P2ShapeEditorCC.prototype, "circleLength", null);
    __decorate([
        apeng.property({
            displayName: "宽高",
            visible() { return this._shapeType == EP2ShapeTypeCC.Box; }
        })
    ], P2ShapeEditorCC.prototype, "boxSize", null);
    __decorate([
        apeng.property({
            type: [apeng.Vec2],
            displayName: "范围点",
            visible() { return this._shapeType == EP2ShapeTypeCC.Polygon; }
        })
    ], P2ShapeEditorCC.prototype, "poygonPoints", null);
    __decorate([
        apeng.property({
            displayName: "形状偏移",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "shapeOffset", null);
    __decorate([
        apeng.property({
            displayName: "使用节点大小",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this._shapeType != EP2ShapeTypeCC.Point
                    && this._shapeType != EP2ShapeTypeCC.Plane
                    && this._shapeType != EP2ShapeTypeCC.Heightfield;
            }
        })
    ], P2ShapeEditorCC.prototype, "useNodeSize", null);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "刚体位置偏移",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "bodyNodeOffset", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "同步节点位置",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "syncNodePosition", void 0);
    __decorate([
        apeng.property({
            displayName: "同步节点位置插值",
            slide: true,
            range: [0, 1, .001],
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && !!this.syncNodePosition;
            }
        })
    ], P2ShapeEditorCC.prototype, "syncNodePositionLerp", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "同步节点旋转",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "syncNodeAngle", void 0);
    __decorate([
        apeng.property({
            tooltip: "接收其他材质属性",
            displayName: "接收材质",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "receiveMaterial", void 0);
    __decorate([
        apeng.property({
            tooltip: "开启材质属性，接受材质(与当前绑定)",
            displayName: "开启材质",
            visible() { return this._shapeType != EP2ShapeTypeCC.None; }
        })
    ], P2ShapeEditorCC.prototype, "openMaterial", void 0);
    __decorate([
        apeng.property({
            tooltip: `摩擦系数用于这两种材料的接触。
		摩擦力=1会使相关物体变得超级滑，摩擦力=0会使其变得不那么滑。
		大于1的摩擦系数将允许非常大的摩擦力，这可以方便地防止汽车轮胎在地面上打滑`,
            displayName: "摩擦力",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialFriction", void 0);
    __decorate([
        apeng.property({
            tooltip: `由此产生的摩擦力的松弛。默认值应适用于大多数模拟`,
            displayName: "摩擦松弛",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialFrictionRelaxation", void 0);
    __decorate([
        apeng.property({
            tooltip: `在大多数情况下，此属性的值应该是一个大数字。`,
            displayName: "摩擦刚度",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialFrictionStiffness", void 0);
    __decorate([
        apeng.property({
            tooltip: `此ContactMaterial生成的所得ContactEquation的松弛`,
            displayName: "松弛",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialRelaxation", void 0);
    __decorate([
        apeng.property({
            tooltip: `恢复，或“弹性”用于这两种材料的接触。
		恢复为0将不会反弹，而恢复为1将大致以与对象相同的速度反弹`,
            displayName: "弹性",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialRestitution", void 0);
    __decorate([
        apeng.property({
            tooltip: `刚度越小，物体的穿透力越大，接触的作用更像弹簧，而不是接触力`,
            displayName: "触点硬度",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialStiffness", void 0);
    __decorate([
        apeng.property({
            tooltip: `将为该材质添加曲面速度。
		如果身体A位于身体B的顶部，并且表面速度为正，身体A将向右滑动。`,
            displayName: "曲面速度",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialSurfaceVelocity", void 0);
    __decorate([
        apeng.property({
            tooltip: `正值将使实体更多地相互渗透。在需要更持久的场景中非常有用，例如在堆叠时`,
            displayName: "接触偏移大小",
            visible() {
                return this._shapeType != EP2ShapeTypeCC.None
                    && this.openMaterial;
            }
        })
    ], P2ShapeEditorCC.prototype, "materialContactSkinSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_shapeType", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_useNodeSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_circleRadius", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_lineLength", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_heightfieldLength", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_circleLength", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_boxSize", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_shapeOffset", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_poygonPoints", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ShapeEditorCC.prototype, "_heightfields", void 0);
    P2ShapeEditorCC = P2ShapeEditorCC_1 = __decorate([
        apeng.ccclass("P2ShapeEditorCC"),
        apeng.executeInEditMode,
        apeng.menuP2("P2ShapeEditorCC")
    ], P2ShapeEditorCC);
    apeng.P2ShapeEditorCC = P2ShapeEditorCC;
})(apeng || (apeng = {}));
/// <reference path="./P2ShapeEditorCC.ts" />

(function (apeng) {
    /**约束类型 */
    let EP2ConstraintType;
    (function (EP2ConstraintType) {
        EP2ConstraintType[EP2ConstraintType["None"] = 0] = "None";
        /**旋转(围绕瞄点旋转)*/
        EP2ConstraintType[EP2ConstraintType["Revolute"] = 1] = "Revolute";
        /**距离(保持固定距离) */
        EP2ConstraintType[EP2ConstraintType["Distance"] = 2] = "Distance";
        /**齿轮(使B同步A的角度) */
        EP2ConstraintType[EP2ConstraintType["Gear"] = 3] = "Gear";
        /**锁定(锁定AB的位置旋转) */
        EP2ConstraintType[EP2ConstraintType["Lock"] = 4] = "Lock";
        /**滑块(延直线移动) */
        EP2ConstraintType[EP2ConstraintType["Prismatic"] = 5] = "Prismatic";
        /**弹簧(直线) */
        EP2ConstraintType[EP2ConstraintType["SpringLinear"] = 6] = "SpringLinear";
        /**弹簧(扭力) */
        EP2ConstraintType[EP2ConstraintType["SpringRotate"] = 7] = "SpringRotate";
    })(EP2ConstraintType = apeng.EP2ConstraintType || (apeng.EP2ConstraintType = {}));
    apeng.ccenum(EP2ConstraintType);
    const v2T = new apeng.Vector2();
    /**
     * 关节
     */
    let P2ConstraintEditorCC = class P2ConstraintEditorCC extends apeng.BaseComponent {
        constructor() {
            super(...arguments);
            this.backupDescribe = "物理约束";
            this.shapeA = null;
            this.shapeB = null;
            this.collideConnected = false;
            this.revolutePivot = null;
            this.distanceLength = 0;
            this.gearAgnle = -1;
            this.gearBMul = 1;
            this.lockOffsetAngle = 0;
            this.lockOffsetPosition = new apeng.Vec2();
            this.prismaticBRotate = false;
            this.prismaticMax = 0;
            this.prismaticMin = 0;
            this.springLength = 0;
            this.springRotate = 0;
            this.springStiffness = 100;
            this.springDamping = .5;
            this._type = EP2ConstraintType.None;
            this.body = null;
        }
        set type(value) {
            if (this._type == value)
                return;
            this._type = value;
        }
        get type() { return this._type; }
        get spring() { return this.body; }
        get constraint() { return this.body; }
        createBodyAfter() {
        }
        /**创建约束 */
        createBody() {
            if (this.body
                || !this.shapeA
                || !this.shapeB
                || this._type == EP2ConstraintType.None)
                return this.body;
            switch (this._type) {
                case EP2ConstraintType.Revolute: {
                    if (this.revolutePivot) {
                        let pos = apeng.Vector2.add(v2T, this.node.position, this.revolutePivot.position);
                        this.body = new p2.RevoluteConstraint(this.shapeA.body, this.shapeB.body, this.constraintParam({
                            worldPivot: [pos.x, pos.y]
                        }));
                    }
                    break;
                }
                case EP2ConstraintType.Distance: {
                    this.body = new p2.DistanceConstraint(this.shapeA.body, this.shapeB.body, this.constraintParam({
                        distance: this.distanceLength != 0 ? this.distanceLength : undefined,
                    }));
                    break;
                }
                case EP2ConstraintType.Gear: {
                    this.body = new p2.GearConstraint(this.shapeA.body, this.shapeB.body, this.constraintParam({
                        angle: this.gearAgnle != -1 ? apeng.Maths.toRadian(this.gearAgnle) : undefined,
                        ratio: this.gearBMul,
                    }));
                    break;
                }
                case EP2ConstraintType.Lock: {
                    let localOffsetB = undefined;
                    if (this.lockOffsetPosition.x != 0 && this.lockOffsetPosition.y != 0)
                        localOffsetB = [this.lockOffsetPosition.x, this.lockOffsetPosition.y];
                    this.body = new p2.LockConstraint(this.shapeA.body, this.shapeB.body, this.constraintParam({
                        localAngleB: this.lockOffsetAngle != 0 ? apeng.Maths.toRadian(this.lockOffsetAngle) : undefined,
                        localOffsetB
                    }));
                    break;
                }
                case EP2ConstraintType.Prismatic: {
                    this.body = new p2.PrismaticConstraint(this.shapeA.body, this.shapeB.body, this.constraintParam({
                        disableRotationalLock: this.prismaticBRotate,
                        lowerLimit: this.prismaticMin,
                        upperLimit: this.prismaticMax,
                    }));
                    break;
                }
                case EP2ConstraintType.SpringLinear: {
                    this.body = new p2.LinearSpring(this.shapeA.body, this.shapeB.body, this.springParam({
                        restLength: this.springLength != 0 ? this.springLength : undefined,
                    }));
                    break;
                }
                case EP2ConstraintType.SpringRotate: {
                    this.body = new p2.RotationalSpring(this.shapeA.body, this.shapeB.body, this.springParam({
                        restAngle: this.springRotate != 0 ? apeng.Maths.toRadian(this.springRotate) : undefined,
                    }));
                    break;
                }
            }
            return this.body;
        }
        constraintParam(obj) {
            let _obj = obj;
            _obj.collideConnected = this.collideConnected;
            _obj.wakeUpBodies = true;
            return _obj;
        }
        springParam(obj) {
            let _obj = obj;
            _obj.stiffness = this.springStiffness;
            _obj.damping = this.springDamping;
            _obj.localAnchorA = [0, 0];
            _obj.localAnchorB = [0, 0];
            return _obj;
        }
    };
    __decorate([
        apeng.property({
            tooltip: "需为子节点 shapeA.node.parent = this.node",
            type: apeng.P2ShapeEditorCC,
            displayName: "刚体A",
        })
    ], P2ConstraintEditorCC.prototype, "shapeA", void 0);
    __decorate([
        apeng.property({
            tooltip: "需为子节点 shapeB.node.parent = this.node",
            type: apeng.P2ShapeEditorCC,
            displayName: "刚体B",
        })
    ], P2ConstraintEditorCC.prototype, "shapeB", void 0);
    __decorate([
        apeng.property({
            type: EP2ConstraintType,
            displayName: "关节类型",
            visible() { return !!this.shapeA && !!this.shapeB; }
        })
    ], P2ConstraintEditorCC.prototype, "type", null);
    __decorate([
        apeng.property({
            displayName: "相互产生物理",
            visible() {
                return !(this._type == EP2ConstraintType.SpringLinear
                    || this._type == EP2ConstraintType.SpringRotate
                    || this._type == EP2ConstraintType.None);
            }
        })
    ], P2ConstraintEditorCC.prototype, "collideConnected", void 0);
    __decorate([
        apeng.property({
            type: apeng.Node,
            displayName: "瞄点",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Revolute;
            }
        })
    ], P2ConstraintEditorCC.prototype, "revolutePivot", void 0);
    __decorate([
        apeng.property({
            tooltip: "0自动计算距离",
            displayName: "距离(中心点)",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Distance;
            }
        })
    ], P2ConstraintEditorCC.prototype, "distanceLength", void 0);
    __decorate([
        apeng.property({
            tooltip: "-1使用当前，>0当前平均撑开或缩小",
            displayName: "夹角度数",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Gear;
            }
        })
    ], P2ConstraintEditorCC.prototype, "gearAgnle", void 0);
    __decorate([
        apeng.property({
            displayName: "B旋转倍数",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Gear;
            }
        })
    ], P2ConstraintEditorCC.prototype, "gearBMul", void 0);
    __decorate([
        apeng.property({
            displayName: "B角度偏移",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Lock;
            }
        })
    ], P2ConstraintEditorCC.prototype, "lockOffsetAngle", void 0);
    __decorate([
        apeng.property({
            displayName: "B位置偏移",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Lock;
            }
        })
    ], P2ConstraintEditorCC.prototype, "lockOffsetPosition", void 0);
    __decorate([
        apeng.property({
            displayName: "B可旋转",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Prismatic;
            }
        })
    ], P2ConstraintEditorCC.prototype, "prismaticBRotate", void 0);
    __decorate([
        apeng.property({
            displayName: "最大距离",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Prismatic;
            }
        })
    ], P2ConstraintEditorCC.prototype, "prismaticMax", void 0);
    __decorate([
        apeng.property({
            displayName: "最小距离",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.Prismatic;
            }
        })
    ], P2ConstraintEditorCC.prototype, "prismaticMin", void 0);
    __decorate([
        apeng.property({
            tooltip: "弹簧的静止长度, 0使用AB的距离",
            displayName: "长度",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.SpringLinear;
            }
        })
    ], P2ConstraintEditorCC.prototype, "springLength", void 0);
    __decorate([
        apeng.property({
            tooltip: "弹簧的静止长度, 0使用AB的旋转角度",
            displayName: "相对夹角",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && this._type == EP2ConstraintType.SpringRotate;
            }
        })
    ], P2ConstraintEditorCC.prototype, "springRotate", void 0);
    __decorate([
        apeng.property({
            displayName: "硬度",
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && (this._type == EP2ConstraintType.SpringLinear
                        || this._type == EP2ConstraintType.SpringRotate);
            }
        })
    ], P2ConstraintEditorCC.prototype, "springStiffness", void 0);
    __decorate([
        apeng.property({
            displayName: "衰减速度",
            range: [0, 1, .001],
            slide: true,
            visible() {
                return !!this.shapeA
                    && !!this.shapeB
                    && (this._type == EP2ConstraintType.SpringLinear
                        || this._type == EP2ConstraintType.SpringRotate);
            }
        })
    ], P2ConstraintEditorCC.prototype, "springDamping", void 0);
    __decorate([
        apeng.property({ serializable: true })
    ], P2ConstraintEditorCC.prototype, "_type", void 0);
    P2ConstraintEditorCC = __decorate([
        apeng.ccclass("P2ConstraintEditorCC"),
        apeng.menuP2("P2ConstraintEditorCC")
    ], P2ConstraintEditorCC);
    apeng.P2ConstraintEditorCC = P2ConstraintEditorCC;
})(apeng || (apeng = {}));

(function (apeng) {
    class P2Group {
        constructor(_enum, config) {
            this._enum = _enum;
            this.config = config;
            this.collider = {
                types: {},
                masks: {},
            };
            this.parseCollider();
        }
        getGroup(type) {
            return this.collider.types[type];
        }
        getMask(type) {
            return this.collider.masks[type] || 0;
        }
        getShapeParam(type, obj) {
            let _obj = obj;
            _obj.collisionMask = this.getMask(type);
            _obj.collisionGroup = this.getGroup(type);
            return obj;
        }
        parseCollider() {
            let typeIds = this.collider.types;
            let typeMasks = this.collider.masks;
            apeng.JS.getEnumValue(this._enum, (type) => {
                typeIds[type] = Math.pow(2, type);
            });
            for (let key in this.config) {
                let type = Number(key);
                let types = this.config[type];
                typeMasks[type] = 0;
                for (let v of types)
                    typeMasks[type] |= typeIds[v];
            }
        }
    }
    apeng.P2Group = P2Group;
})(apeng || (apeng = {}));

(function (apeng) {
    class P2World {
        constructor(data) {
            this.data = data;
            this.id = 0;
            this._root = null;
            this.receiveMaterials = [];
            this.openMaterials = [];
            this.updateKey = "";
            this.updateFps = 1 / 30;
            P2World._idCounter++;
            this.id = P2World._idCounter;
            this.updateKey = "P2World" + this.id;
            this.setFps(data.fps);
            this._root = new p2.World({
                gravity: data.gravity,
            });
            // 摩擦力
            if (data.frictionGravity)
                this._root.frictionGravity = data.frictionGravity;
            // 使用重力长度 应用摩擦力
            this._root.useWorldGravityAsFrictionGravity = false;
            // 重力为0时 使用摩擦力
            this._root.useFrictionGravityOnZeroGravity = false;
            // 第一次碰撞触发的事件 关闭提高性能
            this._root.emitImpactEvent = false;
            // 小于一定速度后自动进入睡眠 退出循环
            this._root.sleepMode = p2.World.BODY_SLEEPING;
            // 默认材质
            if (data.friction !== undefined)
                this._root.defaultContactMaterial.friction = data.friction;
            if (data.restitution !== undefined)
                this._root.defaultContactMaterial.restitution = data.restitution;
            if (data.relaxation !== undefined)
                this._root.defaultContactMaterial.relaxation = data.relaxation;
            if (data.stiffness !== undefined)
                this._root.defaultContactMaterial.stiffness = data.stiffness;
            if (data.frictionStuffness !== undefined)
                this._root.defaultContactMaterial.frictionStuffness = data.frictionStuffness;
            if (data.frictionRelaxation !== undefined)
                this._root.defaultContactMaterial.frictionRelaxation = data.frictionRelaxation;
            if (data.contactSkinSize !== undefined)
                this._root.defaultContactMaterial.contactSkinSize = data.contactSkinSize;
            // 弹簧力
            this._root.applySpringForces = data.isSpringForces;
            // 阻力 衰减速度
            this._root.applyDamping = data.isDamping;
            // 重力
            this._root.applyGravity = data.isGravity;
            // 约束
            this._root.solveConstraints = data.isSolveConstraints;
            this._root.on(this._root.beginContactEvent.type, (data) => {
                let bodyA = data.bodyA;
                let bodyB = data.bodyB;
                this.colliderCall(bodyA, bodyB);
                this.colliderCall(bodyB, bodyA);
            });
        }
        onUpdate() {
            if (apeng._timer.hasUpdateIntervale(this.updateKey, this.updateFps, true))
                this._root.step(apeng._timer.dt);
        }
        colliderCall(bodyA, bodyB) {
            if (bodyA.enterCollider)
                bodyA.enterCollider(bodyB);
            if (bodyA.enterOnceCollider) {
                bodyA.enterOnceCollider(bodyB);
                bodyA.enterOnceCollider = null;
            }
            if (bodyA.endCollider)
                bodyA.endCollider(bodyB);
            if (bodyA.endOnceCollider) {
                bodyA.endOnceCollider(bodyB);
                bodyA.endOnceCollider = null;
            }
        }
        setFps(fps) {
            this.data.fps = fps;
            this.updateFps = 1 / this.data.fps;
        }
        aabbQuery(out, aabb, exclude) {
            let broadphase = this._root.broadphase;
            let axisList = broadphase.axisList;
            out.length = 0;
            for (let i = 0; i < axisList.length; i++) {
                let b = axisList[i];
                if (exclude)
                    if (exclude(b))
                        continue;
                if (b.aabb.overlaps(aabb))
                    out.push(b);
            }
            return out;
        }
        /**
         * 所有在圆形中的形状
         * @param out
         * @param circle
         * @returns
         */
        circleQuery(out, circle, exclude) {
            let broadphase = this._root.broadphase;
            let axisList = broadphase.axisList;
            out.length = 0;
            for (let i = 0; i < axisList.length; i++) {
                let b = axisList[i];
                if (exclude)
                    if (exclude(b))
                        continue;
                let aabb = b.aabb;
                let lower = aabb.lowerBound;
                let upper = aabb.upperBound;
                if (apeng.Circle.intersectAABB(circle, lower[0], lower[1], upper[0], upper[1]))
                    out.push(b);
            }
            return out;
        }
        createBody(comp, type) {
            if (!comp)
                return null;
            comp.createBody(this.data.group, type);
            if (comp.isCreateBody) {
                if (comp.receiveMaterial)
                    apeng.Sets.add(this.receiveMaterials, comp);
                if (comp.openMaterial)
                    apeng.Sets.add(this.openMaterials, comp);
                // 创建
                if (comp.receiveMaterial || comp.openMaterial)
                    for (let receive of this.receiveMaterials) {
                        let mats = receive.openMaterials;
                        for (let open of this.openMaterials) {
                            if (!apeng.Sets.filterValue(mats, v => v.comp != open)) {
                                mats.push(open.createContackMaterial(receive));
                            }
                        }
                    }
            }
            return comp.body;
        }
        addBody(comp) {
            if (!comp || !comp.body)
                return;
            this._root.addBody(comp.body);
            comp.isUpdate = true;
            if (comp.receiveMaterial) {
                for (let mat of comp.openMaterials) {
                    if (this._root.contactMaterials.indexOf(mat) == -1)
                        this._root.addContactMaterial(mat);
                }
            }
        }
        removeBody(comp) {
            if (!comp || !comp.body)
                return;
            comp.body.endCollider = null;
            comp.body.endOnceCollider = null;
            comp.body.enterCollider = null;
            comp.body.enterOnceCollider = null;
            this._root.removeBody(comp.body);
            comp.isUpdate = false;
            if (comp.receiveMaterial) {
                for (let mat of this.receiveMaterials) {
                    let _mat = mat;
                    this._root.removeContactMaterial(_mat);
                }
            }
        }
        createConstraint(comp, typeA, typeB) {
            if (!comp)
                return null;
            comp.createBodyAfter();
            this.createBody(comp.shapeA, typeA);
            this.createBody(comp.shapeB, typeB);
            return comp.createBody();
        }
        addConstraint(comp) {
            if (!comp || !comp.body)
                return;
            this.addBody(comp.shapeA);
            this.addBody(comp.shapeB);
            if (comp.type == apeng.EP2ConstraintType.SpringLinear
                || comp.type == apeng.EP2ConstraintType.SpringRotate)
                this._root.addSpring(comp.spring);
            else
                this._root.addConstraint(comp.constraint);
        }
        removeConstraint(comp) {
            if (!comp || !comp.body)
                return;
            this.removeBody(comp.shapeA);
            this.removeBody(comp.shapeB);
            if (comp.type == apeng.EP2ConstraintType.SpringLinear
                || comp.type == apeng.EP2ConstraintType.SpringRotate)
                this._root.removeSpring(comp.spring);
            else
                this._root.removeConstraint(comp.constraint);
        }
        createEditor(comp, type) {
            let constraint = comp.getCacheComponent(apeng.P2ConstraintEditorCC);
            let data = null;
            if (constraint) {
                data = this.createConstraint(constraint, type, type);
            }
            else {
                let shape = comp.getCacheComponent(apeng.P2ShapeEditorCC);
                if (shape)
                    data = this.createBody(shape, type);
            }
            if (data)
                data._data_ = comp;
        }
        addEditor(comp) {
            let constraint = comp.getCacheComponent(apeng.P2ConstraintEditorCC);
            if (constraint)
                this.addConstraint(constraint);
            else {
                let shape = comp.getCacheComponent(apeng.P2ShapeEditorCC);
                if (shape)
                    this.addBody(shape);
            }
        }
        removeEditor(comp) {
            let constraint = comp.getCacheComponent(apeng.P2ConstraintEditorCC);
            if (constraint)
                this.removeConstraint(constraint);
            else {
                let shape = comp.getCacheComponent(apeng.P2ShapeEditorCC);
                if (shape)
                    this.removeBody(shape);
            }
        }
    }
    P2World._idCounter = 0;
    apeng.P2World = P2World;
})(apeng || (apeng = {}));

(function (apeng) {
    class Circle {
        constructor(x, y, radius) {
            this.x = 0;
            this.y = 0;
            this.radius = 0;
            this._position = new apeng.Vector2();
            this.set(x, y, radius);
        }
        static set(self, x, y, radius) {
            if (x && typeof x === "object") {
                self.x = x.x;
                self.y = x.y;
                self.radius = x.radius || 0;
            }
            else {
                self.x = (x || 0);
                self.y = y || 0;
                self.radius = radius || 0;
            }
            return self;
        }
        static create(x, y, radius) {
            return new Circle(x, y, radius);
        }
        static clone(orgin) {
            return new Circle(orgin);
        }
        /**判断当前园是否包含指定的点 */
        static contains(self, point) {
            let distance = apeng.Vector2.distance(self, point);
            return distance < self.radius;
        }
        static intersectRect(circle, rect) {
            Circle.intersectAABB(circle, rect.xMin, rect.yMin, rect.xMax, rect.yMax);
        }
        static intersectAABB(circle, x1, y1, x2, y2) {
            let r = circle.radius, cx = circle.x, cy = circle.y;
            let abs = Math.abs, min = Math.min;
            //找出x方向与cx最接近的
            let minx = min(abs(x1 - cx), abs(x2 - cx));
            //找出y方向与cy最接近的
            let miny = min(abs(y1 - cy), abs(y2 - cy));
            if (minx * minx + miny * miny < r * r)
                return true;
            //条件2
            let x0 = (x1 + x2) / 2;
            let y0 = (y1 + y2) / 2;
            if ((abs(x0 - cx) < abs(x2 - x1) / 2 + r) && abs(cy - y0) < abs(y2 - y1) / 2)
                return true;
            if ((abs(y0 - cy) < abs(y2 - y1) / 2 + r) && abs(cx - x0) < abs(x2 - x1) / 2)
                return true;
            return false;
        }
        /**判断当前园是否与指定矩形相交 */
        static intersects(self, other) {
            let distance = apeng.Vector2.distance(self, other);
            return distance < self.radius;
        }
        /**距中心点 */
        static mul(out, value, mul) {
            out.set(value);
            out.radius *= mul;
            return out;
        }
        get position() {
            this._position.set(this.x, this.y);
            return this._position;
        }
        set position(value) {
            this.x = value.x;
            this.y = value.y;
        }
        set(x, y, radius) { Circle.set(this, x, y, radius); return this; }
        intersects(other) { return Circle.intersects(this, other); }
        contains(point) { return Circle.contains(this, point); }
        clone() { return Circle.clone(this); }
        mul(out, mul) { return Circle.mul(out, this, mul); }
        mulSelf(mul) { return Circle.mul(this, this, mul); }
    }
    Circle.TEMP = new Circle();
    apeng.Circle = Circle;
})(apeng || (apeng = {}));

(function (apeng) {
    let t1 = 0.0;
    /**曲线 */
    class Curve {
    }
    /**贝塞尔 */
    Curve.Bezier = new class {
        constructor() {
            /**一维算法 */
            this.vec1 = new class {
                /**
                 * n-1阶贝塞尔
                 * @public	static
                 * @memberof Bezier
                 */
                gets(values, ratio) {
                    let l = values.length;
                    t1 = 1 - ratio;
                    let value = 0;
                    for (let i = 0; i < l; i++) {
                        let n = l - i - 1;
                        value += values[i] * Math.pow(t1, n) * Math.pow(ratio, i) * (this.erxiangshi(l - 1, i));
                    }
                    return value;
                }
                /**
                 * 处理后半段值的缩放，
                 * 作用是 比率由大慢慢趋近于1
                 * @private
                 * @public	static
                 * @param {number} start
                 * @param {number} end
                 * @returns {number}
                 * @memberof Bezier
                 */
                erxiangshi(start, end) {
                    let cs = 1, bcs = 1;
                    while (end > 0) {
                        cs *= start;
                        bcs *= end;
                        start--;
                        end--;
                    }
                    return (cs / bcs);
                }
                /**
                 * 二阶
                 * 公式算法 获取曲线上的点
                 * @param end1 第一个端点
                 * @param end2 第二个端点
                 * @param control 控制点
                 * @param time 0~1 运行的速率
                 */
                getControlByCurve(start, end, control, ratio) {
                    // 倒数
                    t1 = 1 - ratio;
                    // 二阶贝塞尔公式
                    return t1 * t1 * start + 2 * ratio * t1 * control + ratio * ratio * end;
                }
                /**
                 * 公式 通过曲线上的点获取控制点
                 * 二阶
                 * @param end1
                 * @param end2
                 * @param curve
                 */
                getCurveByControl(start, end, curve, ratio) {
                    t1 = 1 - ratio;
                    return (curve - t1 * t1 * start - ratio * ratio * end) / (2 * ratio * t1);
                }
                /**
                 * 三阶
                 * 公式算法 获取曲线上的点
                 * @param end1 第一个端点
                 * @param end2 第二个端点
                 * @param control 控制点
                 * @param control2 控制点2
                 * @param time 0~1 运行的速率
                 */
                getControlByCurve3(end1, end2, control, control2, time) {
                    if (end1 == 0 && end2 == 0)
                        return 0;
                    // 倒数
                    t1 = 1 - time;
                    // 三阶贝塞尔公式
                    return Math.pow(t1, 3) * end1 + 3 * control * time * t1 * t1 + 3 * control2 * time * time * t1 + end2 * Math.pow(time, 3);
                }
                /**
                 * 三阶
                 * 公式 通过曲线上的点获取第一个控制点
                 * @param end1
                 * @param end2
                 * @param curve
                 * @param control2 第二个控制点
                 */
                getCurveByControl3(end1, end2, curve, control2, time) {
                    t1 = 1 - time;
                    return (curve - Math.pow(t1, 3) * end1 - 3 * t1 * time * time * control2 - end2 * Math.pow(time, 3)) / (3 * t1 * t1);
                }
                /**
                 * 三阶
                 * 公式 通过曲线上的点获取第二个控制点
                 * @param end1
                 * @param end2
                 * @param curve
                 * @param control 第一个控制点
                 */
                get3CurveByControl2(end1, end2, curve, control1, time) {
                    t1 = 1 - time;
                    return (curve - Math.pow(t1, 3) * end1 - 3 * t1 * t1 * control1 * time - end2 * Math.pow(time, 3)) / (3 * Math.pow(t1, 3) * time * time);
                }
            };
            /**二维 */
            this.vec2 = new class {
                gets(out, values, ratio) {
                    let l = values.length;
                    t1 = 1 - ratio;
                    for (let i = 0; i < l; i++) {
                        let n = l - i - 1;
                        let res = Math.pow(t1, n) * Math.pow(ratio, i) * (Curve.Bezier.vec1.erxiangshi(l - 1, i));
                        out.x += values[i].x * res;
                        out.y += values[i].y * res;
                    }
                    return out;
                }
                getControlByCurve(start, end, control, ratio, curve) {
                    curve.x = Curve.Bezier.vec1.getControlByCurve(start.x, end.x, control.x, ratio);
                    curve.y = Curve.Bezier.vec1.getControlByCurve(start.y, end.y, control.y, ratio);
                    return curve;
                }
                getCurveByControl(start, end, curve, time, control) {
                    control.x = Curve.Bezier.vec1.getCurveByControl(start.x, end.x, curve.x, time);
                    control.y = Curve.Bezier.vec1.getCurveByControl(start.y, end.y, curve.y, time);
                    return control;
                }
                /**3阶贝塞尔 */
                getControlByCurve3(start, end, control, control2, ratio, curve) {
                    curve.x = Curve.Bezier.vec1.getControlByCurve3(start.x, end.x, control.x, control2.x, ratio);
                    curve.y = Curve.Bezier.vec1.getControlByCurve3(start.y, end.y, control.y, control2.y, ratio);
                    return curve;
                }
                getCurveByControl3(start, end, curve, control2, time, control) {
                    control.x = Curve.Bezier.vec1.getCurveByControl3(start.x, end.x, curve.x, control2.x, time);
                    control.y = Curve.Bezier.vec1.getCurveByControl3(start.y, end.y, curve.y, control2.y, time);
                    return control;
                }
            };
            /**三维 */
            this.vec3 = new class {
                gets(out, values, ratio) {
                    let l = values.length;
                    t1 = 1 - ratio;
                    for (let i = 0; i < l; i++) {
                        let n = l - i - 1;
                        let res = Math.pow(t1, n) * Math.pow(ratio, i) * (Curve.Bezier.vec1.erxiangshi(l - 1, i));
                        out.x += values[i].x * res;
                        out.y += values[i].y * res;
                        out.z += values[i].z * res;
                    }
                    return out;
                }
                getControlByCurve(start, end, control, ratio, curve) {
                    curve.x = Curve.Bezier.vec1.getControlByCurve(start.x, end.x, control.x, ratio);
                    curve.y = Curve.Bezier.vec1.getControlByCurve(start.y, end.y, control.y, ratio);
                    curve.z = Curve.Bezier.vec1.getControlByCurve(start.z, end.z, control.z, ratio);
                    return curve;
                }
                getCurveByControl(start, end, curve, time, control) {
                    control.x = Curve.Bezier.vec1.getCurveByControl(start.x, end.x, curve.x, time);
                    control.y = Curve.Bezier.vec1.getCurveByControl(start.y, end.y, curve.y, time);
                    control.z = Curve.Bezier.vec1.getCurveByControl(start.z, end.z, curve.z, time);
                    return control;
                }
                /**3阶贝塞尔 */
                getControlByCurve3(start, end, control, control2, ratio, curve) {
                    curve.x = Curve.Bezier.vec1.getControlByCurve3(start.x, end.x, control.x, control2.x, ratio);
                    curve.y = Curve.Bezier.vec1.getControlByCurve3(start.y, end.y, control.y, control2.y, ratio);
                    curve.z = Curve.Bezier.vec1.getControlByCurve3(start.z, end.z, control.z, control2.z, ratio);
                    return curve;
                }
                getCurveByControl3(start, end, curve, control2, time, control) {
                    control.x = Curve.Bezier.vec1.getCurveByControl3(start.x, end.x, curve.x, control2.x, time);
                    control.y = Curve.Bezier.vec1.getCurveByControl3(start.y, end.y, curve.y, control2.y, time);
                    control.z = Curve.Bezier.vec1.getCurveByControl3(start.z, end.z, curve.z, control2.z, time);
                    return control;
                }
            };
        }
    };
    /**样条 */
    Curve.Spline = new class {
        constructor() {
            /**一维算法 */
            this.vec1 = new class {
                /**
                 * 公式算法 需4个点
                 * @param p0
                 * @param p1
                 * @param p2
                 * @param p3
                 * @param tension 弹性弯曲弧度 0（正常）， 小于0（趋紧于直线）
                 * @param ratio 0～1比率
                 * @returns
                 */
                get(p0, p1, p2, p3, tension, ratio) {
                    let p = -1;
                    if (ratio == 1)
                        p = 3;
                    else {
                        let locDT = 1 / 3;
                        p = Math.floor(ratio / locDT);
                        ratio = (ratio - locDT * p) / locDT;
                    }
                    let arr = [p0, p1, p2, p3];
                    p0 = apeng.Sets.getAt(arr, p - 1);
                    p1 = apeng.Sets.getAt(arr, p - 0);
                    p2 = apeng.Sets.getAt(arr, p + 1);
                    p3 = apeng.Sets.getAt(arr, p + 2);
                    let t2 = ratio * ratio;
                    let t3 = t2 * ratio;
                    let s = (1 - tension) / 2;
                    let b1 = s * ((-t3 + (2 * t2)) - ratio);
                    let b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
                    let b3 = s * (t3 - 2 * t2 + ratio) + (-2 * t3 + 3 * t2);
                    let b4 = s * (t3 - t2);
                    return p0 * b1 + p1 * b2 + p2 * b3 + p3 * b4;
                }
            };
            this.vec2 = new class {
                get(p0, p1, p2, p3, tension, ratio, out) {
                    out.x = Curve.Spline.vec1.get(p0.x, p1.x, p2.x, p3.x, tension, ratio);
                    out.y = Curve.Spline.vec1.get(p0.y, p1.y, p2.y, p3.y, tension, ratio);
                    return out;
                }
            };
            this.vec3 = new class {
                get(p0, p1, p2, p3, tension, ratio, out) {
                    out.x = Curve.Spline.vec1.get(p0.x, p1.x, p2.x, p3.x, tension, ratio);
                    out.y = Curve.Spline.vec1.get(p0.y, p1.y, p2.y, p3.y, tension, ratio);
                    out.z = Curve.Spline.vec1.get(p0.z, p1.z, p2.z, p3.z, tension, ratio);
                    return out;
                }
            };
        }
    };
    apeng.Curve = Curve;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     *  XMLHttpRequest 不可复用， hander重复叠加
     */
    class HttpRequest extends apeng.EventDispatcher {
        constructor(ip, path, type, 
        /**每次发送创建新的http */
        sendCreateHttp = false, encodeData, decodeData) {
            super();
            this.ip = ip;
            this.path = path;
            this.type = type;
            this.sendCreateHttp = sendCreateHttp;
            this.encodeData = encodeData;
            this.decodeData = decodeData;
            this.http = null;
            /**请求已完成 */
            this.isComplete = true;
            this.data = null;
            this.header = null;
            this.sendTime = -1;
            this.version = "";
        }
        get status() { return this.http.status; }
        send(data, header) {
            this.data = data;
            this.header = header;
            this.isComplete = false;
            this.sendTime = apeng.Times.now;
            if (this.sendCreateHttp) {
                if (this.http)
                    this.clearHttp();
                this.http = null;
            }
            let httpNull = false;
            if (!this.http) {
                httpNull = true;
                this.http = new XMLHttpRequest();
            }
            this.initHttp();
            let url = this.ip + "/" + this.path;
            if (this.type == "GET") {
                if (this.data) {
                    if (Array.isArray(this.data))
                        throw new Error("网络请求参数不能为数组");
                    if (this.type == "GET") {
                        url += "?";
                        if (typeof this.data == "object") {
                            let add = "";
                            for (let key in data)
                                add += (encodeURIComponent(key) + "=" + encodeURIComponent(data[key]) + "&");
                            if (add.length > 0)
                                url += add.substring(0, add.length - 1);
                        }
                        else
                            url += this.data;
                    }
                }
            }
            this.http.open(this.type, url);
            if (httpNull) {
                this.http.setRequestHeader("Access-Control-Allow-Origin", "*");
                this.http.setRequestHeader("Content-Type", "application/json");
            }
            if (this.version) {
                this.http.setRequestHeader("start-Time", this.sendTime + "");
                this.http.setRequestHeader("version", this.version);
            }
            if (this.header)
                for (let key in this.header)
                    this.http.setRequestHeader(key, this.header[key]);
            if (this.data && this.type == "POST") {
                // 必须为object
                if (typeof this.data != "object")
                    throw new Error("POST网络请求参数必须为对象");
                let sendData = this.encodeData ? this.encodeData(this.data) : JSON.stringify(this.data);
                this.http.send(sendData);
                console.log("request start: " + url);
            }
            else {
                this.http.send();
                console.log("request start: " + url);
            }
            this.emit(HttpRequest.EventType.START);
        }
        /**使用上一次发送数据 重新请求 */
        reSend() {
            this.send(this.data, this.header);
        }
        /**
         * @private
         * 请求错误的处理函数。
         * @param	message 错误信息。
         */
        error(message) {
            this.clearHttp();
            console.log("request error: " + this.ip + "/" + this.path + ", data:" + message);
            if (this.status === 0) {
                this.emit(HttpRequest.EventType.NONE, message);
                return;
            }
            // 能成功
            for (let _value of this.emit(HttpRequest.EventType.HAS_ERROR, message))
                if (!_value)
                    return;
            this.emit(HttpRequest.EventType.ERROR, message);
        }
        /**
         * @private
         * 请求成功完成的处理函数。
         */
        complete() {
            if (this.isComplete)
                return;
            this.isComplete = true;
            this.clearHttp();
            let completeData = null;
            if (!this.http.responseText) {
                this.error("json error [" + "responseText none" + "]");
                return;
            }
            try {
                if (this.decodeData)
                    completeData = this.decodeData(this.http.responseText);
                else
                    completeData = JSON.parse(this.http.responseText);
            }
            catch (e) {
                console.log("数据解析失败:", e);
                completeData = null;
                this.error("json error [" + "responseText" + "]");
            }
            if (completeData) {
                // 能成功
                for (let _value of this.emit(HttpRequest.EventType.HAS_COMPLETE, completeData))
                    if (!_value)
                        return;
                console.log("request complete: ", this.ip + "/" + this.path);
                this.emit(HttpRequest.EventType.COMPLETE, completeData);
                this.emit(HttpRequest.EventType.COMPLETE2, completeData);
            }
        }
        dispose() {
            this.clearEvent();
            this.clearHttp();
            this.isComplete = true;
            this.data = null;
            this.http = null;
        }
        /**
         * @private
         * 清除当前请求
         */
        clearHttp() {
            this.http.onerror = null;
            this.http.onabort = null;
            this.http.onprogress = null;
            this.http.ontimeout = null;
            this.http.onload = null;
            this.http.onreadystatechange = null;
        }
        initHttp() {
            this.http.timeout = 5000;
            this.http.onerror = (e) => {
                this.error("error status[" + this.status + "]");
            };
            this.http.onabort = (e) => {
                this.error("abort status[" + this.status + "]");
            };
            this.http.onprogress = (e) => {
                if (e && e.lengthComputable)
                    this.emit(HttpRequest.EventType.PROGRESS, e.loaded / e.total);
            };
            this.http.onload = (e) => {
                if (this.status === 200 || this.status === 204 || this.status === 0 || this.status === undefined)
                    this.complete();
                else
                    this.error("load status[" + this.status + "]");
            };
            this.http.ontimeout = (data) => {
                this.error("timeout status[" + this.status + "]");
            };
            this.http.onreadystatechange = () => {
                if (this.http.readyState === 4 && this.status >= 200 && this.status < 300)
                    this.complete();
            };
        }
    }
    HttpRequest.EventType = {
        /**请求进度 */
        PROGRESS: "PROGRESS",
        /**请求出错时 */
        ERROR: "ERROR",
        /**完成时 */
        COMPLETE: "COMPLETE",
        COMPLETE2: "COMPLETE2",
        /**校验是否派发 COMPLETE  return false 不派发*/
        HAS_COMPLETE: "HAS_COMPLETE",
        /**校验是否派发 ERROR return false 不派发*/
        HAS_ERROR: "HAS_ERROR",
        /**开始请求 */
        START: "START",
        /**服务器无响应 地址无效 */
        NONE: "NONE",
    };
    apeng.HttpRequest = HttpRequest;
})(apeng || (apeng = {}));

(function (apeng) {
    class IntervalAnim {
        constructor() {
            this.datas = null;
            this.isAnim = false;
            this.cb = null;
            this.loopCb = null;
            this.loop = 0;
            this.loopCur = 0;
            this.curIndex = 0;
            this._dt = 0;
        }
        init(datas, cb, loopCb) {
            this.datas = datas;
            this.cb = cb;
            this.loopCb = loopCb;
        }
        /**
         * 开启
         * @param loop 0循环，大于0指定次数
         * @param startIndex 开始索引
         */
        run(loop = 0, startIndex = 0) {
            this.isAnim = true;
            this.loop = loop;
            this.curIndex = startIndex;
            this._dt = 0;
            this.loopCur = 0;
            this.cb(this.curIndex, this.loopCur);
        }
        stop() {
            this.isAnim = false;
        }
        onUpdate(dt) {
            if (this.isAnim) {
                this._dt += dt;
                let interval = this.datas[this.curIndex];
                if (this._dt >= interval) {
                    this._dt = 0;
                    this.curIndex = (this.curIndex + 1) % this.datas.length;
                    this.cb(this.curIndex, this.loopCur);
                    if (this.loop > 0) {
                        if (this.curIndex == 0) {
                            this.loopCur++;
                            if (this.loopCur >= this.loop) {
                                this.isAnim = false;
                                this.loopCb();
                            }
                        }
                    }
                }
            }
        }
    }
    apeng.IntervalAnim = IntervalAnim;
})(apeng || (apeng = {}));

(function (apeng) {
    class JumpBy {
        constructor() {
            this.node = null;
            this.start = new apeng.Vector2();
            this.position = new apeng.Vector2();
            this.duration = 0;
            this.height = 0;
            this.jumps = 0;
            this.easeType = apeng.EEaseType.linear;
            this.isAnim = false;
            this._dt = 0;
        }
        init(node) {
            this.node = node;
        }
        run(position, duration, height, jumps, easeType = apeng.EEaseType.linear) {
            this.position.x = position.x;
            this.position.y = position.y;
            this.duration = duration;
            this.height = height;
            this.jumps = jumps;
            this.easeType = easeType;
            this.isAnim = true;
            this._dt = 0;
            this.start.set(this.node.position);
        }
        onUpdate(dt) {
            if (!this.isAnim)
                return;
            this._dt += dt;
            let _ratio = this._dt / this.duration;
            _ratio = apeng.easing(this.easeType, _ratio);
            if (_ratio >= 1) {
                this.isAnim = false;
                _ratio = 1;
            }
            let ratio = _ratio * this.jumps % 1;
            let y = this.height * 4 * ratio * (1 - ratio);
            y += this.position.y * _ratio;
            let x = this.position.x * _ratio;
            this.node.setPosition(x + this.start.x, y + this.start.y);
        }
    }
    apeng.JumpBy = JumpBy;
})(apeng || (apeng = {}));

(function (apeng) {
    const v2T = new apeng.Vector2();
    /**多边形 */
    class Polygon {
        /**
         * 获取多边形内的某一点
         * @param polygon 多边形
         * @param angle 角度
         * @param ratio 比率
         * @param maxDis 线段最大值
         */
        static getDot(polygon, dir, ratio, maxDis) {
            let center = apeng.Vector2.polygonByCenterPoint(new apeng.Vector2(), polygon);
            let value = new apeng.Vector2();
            let _dir = dir.normalize(new apeng.Vector2());
            let line = _dir.mul(new apeng.Vector2(), maxDis).addSelf(center);
            for (let i = 0, l = polygon.length; i < l; ++i) {
                let a1 = polygon[i];
                let a2 = polygon[(i + 1) % l];
                if (this.lineLine(a1, a2, center, line)) {
                    let dis = this.pointLineDistance(center, a1, a2, true);
                    value.set(_dir).mulSelf(dis * ratio).addSelf(center);
                    break;
                }
            }
            return value;
        }
        /**转换为椭圆 求交 */
        static elliptic(rect, circle) {
            // 有更简便的公式，暂时以 端点两个圆 中间矩形判断
            let len = Math.min(rect.width, rect.height);
            let center = rect.center;
            apeng.Rectangle.TEMP.width = len;
            apeng.Rectangle.TEMP.height = len;
            apeng.Rectangle.TEMP.center = center;
            if (this.rectCircle(apeng.Rectangle.TEMP, circle))
                return true;
            let radius = len / 2;
            apeng.Circle.TEMP.radius = radius;
            if (rect.width > rect.height) {
                apeng.Circle.TEMP.x = rect.xMin + radius;
                apeng.Circle.TEMP.y = center.y;
                if (apeng.Circle.TEMP.intersects(circle))
                    return true;
                apeng.Circle.TEMP.x = rect.xMax - radius;
                if (apeng.Circle.TEMP.intersects(circle))
                    return true;
            }
            else {
                apeng.Circle.TEMP.x = center.x;
                apeng.Circle.TEMP.y = rect.yMin + radius;
                if (apeng.Circle.TEMP.intersects(circle))
                    return true;
                apeng.Circle.TEMP.y = rect.yMax - radius;
                if (apeng.Circle.TEMP.intersects(circle))
                    return true;
            }
            return false;
        }
        /**
         * 矩形与圆是否相交
         * @param rect
         * @param circle
         */
        static rectCircle(rect, circle) {
            return this.polygonCircle(rect.polygon(), circle);
        }
        /**
         * 一维空间中 两条线段是否相交
         * @param min1
         * @param max1
         * @param min2
         * @param max2
         */
        static oneLineLine(min1, max1, min2, max2) {
            if (max1 < min2 || min1 > max2)
                return false;
            return true;
        }
        /**
          * 线段与线段是否相交
          * @param a1 第一条线段起点
          * @param a2 第一条线段终点
          * @param b1
          * @param b2
          */
        static lineLine(a1, a2, b1, b2) {
            if (!a1 || !a2 || !b1 || !b2)
                return false;
            //向量叉乘
            let ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
            let ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
            let u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
            // 方向
            if (u_b !== 0) {
                let ua = ua_t / u_b;
                let ub = ub_t / u_b;
                if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1)
                    return true;
                return false;
            }
            return false;
        }
        /**
     * 线段与矩形是否相交
     * @param a1 第一条线段起点
     * @param a2 第一条线段终点
     * @param b 矩形块
     */
        static lineRect(a1, a2, b) {
            if (!a1 || !a2 || !b)
                return false;
            let polygon = b.polygon();
            let r0 = polygon[0];
            let r1 = polygon[1];
            let r2 = polygon[2];
            let r3 = polygon[3];
            if (this.lineLine(a1, a2, r0, r1))
                return true;
            if (this.lineLine(a1, a2, r1, r2))
                return true;
            if (this.lineLine(a1, a2, r2, r3))
                return true;
            if (this.lineLine(a1, a2, r3, r0))
                return true;
            return false;
        }
        /**
         * 线段与多边形是否相交
         * @param a1
         * @param a2
         * @param b
         */
        static linePolygon(a1, a2, b) {
            if (!a1 || !a2 || !b)
                return false;
            for (let i = 0, length = b.length; i < length; ++i) {
                let b1 = b[i];
                let b2 = b[(i + 1) % length];
                if (this.lineLine(a1, a2, b1, b2))
                    return true;
            }
            return false;
        }
        /**
         * 矩形是否与线段相交
         * @param a
         * @param b
         */
        static rectPolygon(a, b) {
            if (!a || !b)
                return false;
            let i, l;
            let polygon = a.polygon();
            let r0 = polygon[0];
            let r1 = polygon[1];
            let r2 = polygon[2];
            let r3 = polygon[3];
            if (this.linePolygon(r0, r1, b))
                return true;
            if (this.linePolygon(r1, r2, b))
                return true;
            if (this.linePolygon(r2, r3, b))
                return true;
            if (this.linePolygon(r3, r0, b))
                return true;
            // 矩形包含多边形的点
            for (i = 0, l = b.length; i < l; ++i) {
                if (a.contains(b[i]))
                    return true;
                // if (this.pointInPolygon(b[i], a.polygon())) return true
            }
            // 多边形包含矩形点
            if (this.pointInPolygon(r0, b))
                return true;
            if (this.pointInPolygon(r1, b))
                return true;
            if (this.pointInPolygon(r2, b))
                return true;
            if (this.pointInPolygon(r3, b))
                return true;
            return false;
        }
        /**
         * 多边形与多边形相交
         * @param a
         * @param b
         */
        static polygonPolygon(a, b) {
            if (!a || !b)
                return false;
            let i, l;
            // a的每条边相交于b的每条边
            for (i = 0, l = a.length; i < l; ++i) {
                let a1 = a[i];
                let a2 = a[(i + 1) % l];
                if (this.linePolygon(a1, a2, b))
                    return true;
            }
            // b的每个点在a中
            for (i = 0, l = b.length; i < l; ++i) {
                if (this.pointInPolygon(b[i], a))
                    return true;
            }
            // a的每个点在b中
            for (i = 0, l = a.length; i < l; ++i) {
                if (this.pointInPolygon(a[i], b))
                    return true;
            }
            return false;
        }
        /**
     * 多边形与圆形是否相交
     * @param polygon
     * @param circle
     */
        static polygonCircle(polygon, circle) {
            if (!polygon || !circle)
                return false;
            let position = circle.position;
            if (this.pointInPolygon(position, polygon)) {
                return true;
            }
            for (let i = 0, l = polygon.length; i < l; i++) {
                let start = i === 0 ? polygon[polygon.length - 1] : polygon[i - 1];
                let end = polygon[i];
                if (this.pointLineDistance(position, start, end, true) < circle.radius) {
                    return true;
                }
            }
            return false;
        }
        /**线段与原相交 */
        static lineCircle(start, end, circle) {
            if (circle.contains(start))
                return true;
            if (circle.contains(end))
                return true;
            if (this.pointLineDistance(circle.position, start, end, true) < circle.radius)
                return true;
            return false;
        }
        /**
         * 点是否在多边形中
         * @param point
         * @param polygon
         */
        static pointInPolygon(point, polygon) {
            if (!point || !polygon)
                return false;
            let inside = false;
            let x = point.x;
            let y = point.y;
            let length = polygon.length;
            for (let i = 0, j = length - 1; i < length; j = i++) {
                let xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
                if (intersect)
                    inside = !inside;
            }
            return inside;
        }
        /**
         * 计算点到直线的距离。如果这是一条线段并且垂足不在线段内，则会计算点到线段端点的距离
         * @param point 点
         * @param start 线段起点
         * @param end 线段终点
         * @param isSegment 是否为线段
         */
        static pointLineDistance(point, start, end, isSegment) {
            if (!point || !start || !end)
                return 0;
            // 可通过 点积的方式得到
            let dx = end.x - start.x;
            let dy = end.y - start.y;
            let d = dx * dx + dy * dy;
            let t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
            // 垂足
            if (!isSegment) {
                v2T.set(start.x + t * dx, start.y + t * dy);
            }
            else {
                if (d) {
                    // 在第一个端点左边
                    if (t < 0)
                        v2T.set(start);
                    // 在第二个端点右边
                    else if (t > 1)
                        v2T.set(end);
                    // 在线段中间
                    else
                        v2T.set(start.x + t * dx, start.y + t * dy);
                }
                else {
                    v2T.set(start);
                }
            }
            //垂足与点的距离
            dx = point.x - v2T.x;
            dy = point.y - v2T.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**旋转矩形与旋转矩形 */
        static rectByAngle(a, b) {
            return this.polygonPolygon(a.angleCenter(), b.angleCenter());
        }
    }
    apeng.Polygon = Polygon;
})(apeng || (apeng = {}));

(function (apeng) {
    /**进度合并 整理为1个 */
    class ProgressDir {
        constructor(onProgress) {
            /**当前进度 */
            this.ratio = 0;
            this.ratioAll = {};
            this.progressLength = 0;
            this.onProgress = null;
            this.onProgress = onProgress;
            if (this.onProgress)
                this.onProgress(0);
        }
        progress(url) {
            if (this.ratioAll[url] == undefined)
                this.progressLength++;
            let func = (ratio, cocosRatio) => {
                //适配cocos加载进度
                if (cocosRatio != undefined)
                    ratio = ratio / cocosRatio;
                // 避免多次回调相同得值
                this.ratioAll[url] = ratio;
                let _ratio = 0;
                for (let key in this.ratioAll)
                    _ratio += this.ratioAll[key];
                this.ratio = _ratio / this.progressLength;
                if (this.onProgress)
                    this.onProgress(this.ratio);
            };
            func(0);
            return func;
        }
        getCurRatio() {
            return this.ratio;
        }
    }
    apeng.ProgressDir = ProgressDir;
})(apeng || (apeng = {}));

(function (apeng) {
    class RandomSeed {
        constructor() {
            this._data = -1;
            this.id = -1;
        }
        init(id) {
            this._data = id;
            this.id = id;
            return this;
        }
        clear() {
            this._data = this.id;
            return this;
        }
        run() {
            this._data = (this._data * 9301 + 49297) % 233280;
            return this._data / (233280.0);
        }
    }
    RandomSeed.pool = new apeng.PoolOnce(100000, () => new RandomSeed(), (data) => data.clear());
    apeng.RandomSeed = RandomSeed;
})(apeng || (apeng = {}));

(function (apeng) {
    /**
     * 动画转向 解决0~360度动画问题
     */
    class Rotate360Anim extends apeng.EventDispatcher {
        constructor(setAngle, getAngle) {
            super();
            this.setAngle = setAngle;
            this.getAngle = getAngle;
            this._start = 0;
            this._move = 0;
            this._moveCur = 0;
            this.isAnim = false;
            this.lerpRatio = -1;
        }
        /**由快到慢 插值动画 */
        lerpRun(to, ratio, cur) {
            let curAngle = this.getAngle();
            if (to == curAngle)
                return;
            this._move = 0;
            this._moveCur = 0;
            this.isAnim = true;
            this.lerpRatio = ratio;
            if (cur !== undefined)
                this.setAngle(cur);
            // 最短距离
            this._start = apeng.Maths.normalizeAngle(curAngle);
            to = apeng.Maths.normalizeAngle(to);
            let sub = this._start - to;
            let abs = Math.abs(sub);
            // 反方向
            if (abs > 180) {
                this._move = (360 - abs);
                if (sub < 0)
                    this._move *= -1;
            }
            else {
                this._move = -sub;
            }
            this.emit(apeng.ScaleAnim.EventType.START);
        }
        stop(cur) {
            this.isAnim = false;
            if (cur !== undefined)
                this.setAngle(cur);
        }
        onUpdate() {
            if (this.isAnim) {
                this._moveCur = apeng.Maths.lerp(this._moveCur, this._move, this.lerpRatio);
                if (Math.abs(this._moveCur - this._move) < .01)
                    this._moveCur = this._move;
                this.setAngle(this._start + this._moveCur);
                if (this._moveCur == this._move) {
                    this.isAnim = false;
                    this.emit(apeng.ScaleAnim.EventType.COMPLETE);
                }
            }
        }
    }
    Rotate360Anim.EventType = {
        START: "START",
        COMPLETE: "COMPLETE",
    };
    apeng.Rotate360Anim = Rotate360Anim;
})(apeng || (apeng = {}));

(function (apeng) {
    class ScaleAnim extends apeng.EventDispatcher {
        constructor() {
            super(...arguments);
            this.node = null;
            this._to = new apeng.Vector3();
            this.isAnim = false;
            this.lerpRatio = -1;
        }
        init(node) {
            this.node = node;
        }
        /**由快到慢 插值动画 */
        lerpRun(to, ratio, cur) {
            this._to.set(to);
            this.isAnim = true;
            this.lerpRatio = ratio;
            if (cur)
                apeng.NodeHelper.setScale(this.node, cur, false);
            this.emit(ScaleAnim.EventType.START);
        }
        stop(cur) {
            this.isAnim = false;
            if (cur)
                apeng.NodeHelper.setScale(this.node, cur, false);
        }
        onUpdate() {
            if (this.isAnim) {
                // 由小放大
                if (apeng.NodeHelper.lerpScaleTarget(this.node, this._to, this.lerpRatio, false)) {
                    apeng.NodeHelper.setScale(this.node, this._to, false);
                    this.isAnim = false;
                    this.emit(ScaleAnim.EventType.COMPLETE);
                }
            }
        }
    }
    ScaleAnim.EventType = {
        START: "START",
        COMPLETE: "COMPLETE",
    };
    apeng.ScaleAnim = ScaleAnim;
})(apeng || (apeng = {}));

(function (apeng) {
    let defaultArgs = [];
    class StateMackine extends apeng.EventDispatcher {
        constructor(values) {
            super();
            /**外部存储数据 */
            this.data = null;
            /**当前状态 */
            this.state = null;
            /**上一个状态 */
            this.lastState = null;
            /**保存得状态 */
            this._saveState = null;
            /**保存得上一次状态 */
            this._saveLastState = null;
            /**已添加的所有状态 */
            this.states = {};
            /**打印日志 */
            this.logPrefix = "";
            /**函数派发时得作用域 */
            this.caller = null;
            /**枚举对象 */
            this.enum = null;
            /**状态机的onUpdate执行时 会调用此update */
            this.update = null;
            this.isUpdate = true;
            if (!values)
                return;
            if (values._enum != undefined)
                this.enum = values._enum;
            if (values.caller != undefined)
                this.caller = values.caller;
            if (values.logPrefix != undefined)
                this.logPrefix = values.logPrefix;
            if (values.update != undefined)
                this.update = values.update;
            if (values.states != undefined)
                for (let state of values.states)
                    this.addState(state);
            if (values.state != undefined)
                this.state = values.state;
        }
        /**
         * 添加状态机
         * @param value
         */
        addState(value) {
            let type = value.type;
            if (!this.states[type])
                this.states[type] = value;
            else
                console.error("stateMackine add: " + type);
            return this;
        }
        getState(state) {
            return this.states[state];
        }
        getCurState() {
            return this.getState(this.state);
        }
        /**重置数据 */
        clear() {
            if (this.logPrefix)
                console.log("stateMackine clear: ", this.converEnumK());
            this.state = null;
            this.states = {};
            this.caller = null;
            this.logPrefix = "";
            this.enum = null;
            this.update = null;
            this.isUpdate = true;
            this.emit(StateMackine.EventType.CLEAR);
        }
        /**
         * 切换一个状态
         * @param state
         * @param args
         * @param emitEvent 默认派发事件
         * @param checkCur 当前状态不派发
         */
        change(state, args, emitEvent = true, checkCur = true) {
            if (checkCur)
                if (this.state === state)
                    return;
            if (emitEvent)
                this.onExit(args);
            this.lastState = this.state;
            this.state = state;
            if (emitEvent)
                this.onEnter(args);
        }
        /**
         * 外部update接口调用
         * @param dt
         */
        onUpdate() {
            if (!this.isUpdate)
                return;
            if (!this.isValid(this.state))
                return;
            let value = this.getCurState();
            if (!value)
                return;
            if (value.onUpdate)
                value.onUpdate.call(this.caller);
            if (this.update)
                this.update();
        }
        converEnumK() {
            return this.logPrefix + (this.enum ? this.enum[this.state] : this.state);
        }
        isValid(key) {
            if (key == null || key == undefined || key === false)
                return false;
            else
                return true;
        }
        /**派发进入事件 */
        onEnter(args) {
            if (!this.isValid(this.state))
                return;
            if (this.logPrefix)
                console.log("stateMackine enter: ", this.converEnumK());
            let value = this.getCurState();
            if (!value)
                return;
            if (value.isLog)
                console.log("stateMackine enter by isLog: ", this.converEnumK());
            if (!args)
                args = defaultArgs;
            this.emit(StateMackine.EventType.ENTER_BEFORE, ...args);
            if (value.onEnter)
                value.onEnter.apply(this.caller, args);
            this.emit(StateMackine.EventType.ENTER_AFTER, ...args);
            this.emit(StateMackine.EventType.ENTER_AFTER2, ...args);
        }
        /**派发退出事件 */
        onExit(args) {
            if (this.state == null)
                return;
            if (!this.isValid(this.state))
                return;
            // if (this.logPrefix)
            // 	console.log("stateMackine exit: ", this.converEnumK())
            let value = this.getCurState();
            if (!value)
                return;
            if (!args)
                args = defaultArgs;
            this.emit(StateMackine.EventType.EXIT_BEFORE, ...args);
            if (value.onExit)
                value.onExit.apply(this.caller, args);
            this.emit(StateMackine.EventType.EXIT_AFTER, ...args);
        }
    }
    StateMackine.EventType = {
        /**进入状态 回调前 state */
        ENTER_BEFORE: "ENTER_BEFORE",
        /**进入状态 回调后 state */
        ENTER_AFTER: "ENTER_AFTER",
        /**进入状态 回调后 state 防止顺序执行*/
        ENTER_AFTER2: "ENTER_AFTER2",
        /**退出状态 回调前 state */
        EXIT_BEFORE: "EXIT_BEFORE",
        /**退出状态 回调后 state */
        EXIT_AFTER: "EXIT_AFTER",
        /**清除状态机 */
        CLEAR: "CLEAR",
    };
    apeng.StateMackine = StateMackine;
})(apeng || (apeng = {}));

(function (apeng) {
    /**一些中文符号 */
    const fuhao = ['，', '。', '；', '！', '：', '【', '】', '…', '？', '“', '”', '—', '·', '、', '《', '》', '（', '）', '￥', '＠'];
    class Strings {
        static indexOf(value, str, start = 0) {
            return value.indexOf(str, start);
        }
        static lastIndexOf(value, str) {
            let index = this.indexOf(value, str);
            if (index == -1)
                return -1;
            return index + str.length;
        }
        static after(value, find) {
            return value.substring(0, this.indexOf(value, find));
        }
        static last(value, find) {
            return value.substring(this.lastIndexOf(value, find));
        }
        static converText(text) {
            return {
                after: Strings.after(text, "{"),
                last: Strings.last(text, "}"),
            };
        }
        /**
         * 计算中文字符长度
         * 中文2个长度，英文1个长度
         * @param chars
         * @returns
         */
        static chinaLength(chars) {
            let fuhao_code = [];
            for (let j = 0; j < fuhao.length; j++)
                fuhao_code.push(fuhao[j].charCodeAt(0));
            let sum = 0;
            for (let i = 0; i < chars.length; i++) {
                let c = chars.charCodeAt(i);
                if ((c >= 0x0001 && c <= 0x007e) || (0xff60 <= c && c <= 0xff9f))
                    sum++;
                //一些数字、字母、英文符号等
                else if (fuhao_code.indexOf(c) >= 0)
                    //一些中文符号
                    sum += 2;
                else
                    sum += 2;
            }
            return sum;
        }
        /**截取中文字符的长度 */
        static chinaSub(chars, length) {
            let fuhao_code = [];
            for (let j = 0; j < fuhao.length; j++)
                fuhao_code.push(fuhao[j].charCodeAt(0));
            let str = "";
            for (let i = 0; i < chars.length; i++) {
                let c = chars.charCodeAt(i);
                str += chars[i];
                let sub = 1;
                if ((c >= 0x0001 && c <= 0x007e) || (0xff60 <= c && c <= 0xff9f))
                    sub = 1;
                //一些数字、字母、英文符号等
                else if (fuhao_code.indexOf(c) >= 0)
                    //一些中文符号
                    sub = 2;
                else
                    sub = 2;
                length -= sub;
                if (length <= 0)
                    break;
            }
            return str;
        }
        /**使用*号代替后面字符 */
        static blur(value, hideCount) {
            let str = "";
            for (let i = 0; i < hideCount; i++)
                str += "*";
            return value.substr(0, value.length - hideCount) + str;
        }
        /**
         * 替换字符
         * @param value
         * @param orgin 想要替换的
         * @param now 替换成
         * @param all 全部替换，反之第一个替换
         */
        static replace(value, orgin, now, all) {
            // return value.replace(/orgin/g, now)
        }
        /**
         * 创建加密的 key
         * @param value 0~9可乱序排列，一般 使用当前毫秒时间
         * @returns
         */
        static createCodeByKey(value) {
            let nums = [];
            let arr = (value + "").split("");
            for (let _arr of arr) {
                let __arr = Number(_arr);
                if (nums.indexOf(__arr) == -1)
                    nums.push(__arr);
            }
            for (let i = 0; i < 10; i++)
                if (nums.indexOf(i) == -1)
                    nums.push(i);
            //定义密钥，36个字母和数字
            return "AECDHFIJKLQMNOBPRXSTUVZWYG" + nums.join("");
        }
        /**加密 */
        static encode(str, key) {
            if (!key)
                return str;
            key = this.createCodeByKey(key);
            //定义密钥，36个字母和数字
            let len = key.length; //获取密钥的长度
            let a = key.split(""); //把密钥字符串转换为字符数组
            let s = "", b, b1, b2, b3; //定义临时变量
            for (let i = 0, strLen = str.length; i < strLen; i++) { //遍历字符串
                b = str.charCodeAt(i); //逐个提取每个字符，并获取Unicode编码值
                b1 = b % len; //求Unicode编码值得余数
                b = (b - b1) / len; //求最大倍数
                b2 = b % len; //求最大倍数的于是
                b = (b - b2) / len; //求最大倍数
                b3 = b % len; //求最大倍数的余数
                s += a[b3] + a[b2] + a[b1]; //根据余数值映射到密钥中对应下标位置的字符
            }
            return s; //返回这些映射的字符
        }
        /**解密 */
        static decode(str, key) {
            if (!key)
                return str;
            key = this.createCodeByKey(key);
            //定义密钥，36个字母和数字
            let len = key.length; //获取密钥的长度
            let b, b1, b2, b3, d = 0, s; //定义临时变量
            b = Math.floor(str.length / 3); //获取数组的长度
            s = new Array(b); //计算加密字符串包含的字符数，并定义数组
            for (let i = 0; i < b; i++) { //以数组的长度循环次数，遍历加密字符串
                b1 = key.indexOf(str.charAt(d)); //截取周期内第一个字符串，计算在密钥中的下标值
                d++;
                b2 = key.indexOf(str.charAt(d)); //截取周期内第二个字符串，计算在密钥中的下标值
                d++;
                b3 = key.indexOf(str.charAt(d)); //截取周期内第三个字符串，计算在密钥中的下标值
                d++;
                s[i] = b1 * len * len + b2 * len + b3; //利用下标值，反推被加密字符的Unicode编码值
            }
            b = String.fromCharCode(...s); // 用fromCharCode()算出字符串
            return b; //返回被解密的字符串
        }
        /* *
         * 压缩字符串
         * 手动拷贝出来 解析不对（符合加密需求）
         */
        static compress(strNormalString) {
            let strCompressedString = "";
            let ht = new Array();
            for (let i = 0; i < 128; i++)
                ht[i] = i;
            let used = 128;
            let intLeftOver = 0;
            let intOutputCode = 0;
            let pcode = 0;
            let ccode = 0;
            let k = 0;
            for (let i = 0; i < strNormalString.length; i++) {
                ccode = strNormalString.charCodeAt(i);
                k = (pcode << 8) | ccode;
                if (ht[k] != null)
                    pcode = ht[k];
                else {
                    intLeftOver += 12;
                    intOutputCode <<= 12;
                    intOutputCode |= pcode;
                    pcode = ccode;
                    if (intLeftOver >= 16) {
                        strCompressedString += String.fromCharCode(intOutputCode >> (intLeftOver - 16));
                        intOutputCode &= (Math.pow(2, (intLeftOver - 16)) - 1);
                        intLeftOver -= 16;
                    }
                    if (used < 4096) {
                        used++;
                        ht[k] = used - 1;
                    }
                }
            }
            if (pcode != 0) {
                intLeftOver += 12;
                intOutputCode <<= 12;
                intOutputCode |= pcode;
            }
            if (intLeftOver >= 16) {
                strCompressedString += String.fromCharCode(intOutputCode >> (intLeftOver - 16));
                intOutputCode &= (Math.pow(2, (intLeftOver - 16)) - 1);
                intLeftOver -= 16;
            }
            if (intLeftOver > 0) {
                intOutputCode <<= (16 - intLeftOver);
                strCompressedString += String.fromCharCode(intOutputCode);
            }
            return strCompressedString;
        }
        /* *
         * 解压缩字符串
         */
        static decompress(strCompressedString) {
            let strNormalString = "";
            let ht = new Array();
            for (let i = 0; i < 128; i++)
                ht[i] = String.fromCharCode(i);
            let used = 128;
            let intLeftOver = 0;
            let intOutputCode = 0;
            let ccode = 0;
            let pcode = 0;
            let key = 0;
            for (let i = 0; i < strCompressedString.length; i++) {
                intLeftOver += 16;
                intOutputCode <<= 16;
                intOutputCode |= strCompressedString.charCodeAt(i);
                while (1) {
                    if (intLeftOver >= 12) {
                        ccode = intOutputCode >> (intLeftOver - 12);
                        if (typeof (key = ht[ccode]) != "undefined") {
                            strNormalString += key;
                            if (used > 128)
                                ht[ht.length] = ht[pcode] + key.substr(0, 1);
                            pcode = ccode;
                        }
                        else {
                            key = ht[pcode] + ht[pcode].substr(0, 1);
                            strNormalString += key;
                            ht[ht.length] = ht[pcode] + key.substr(0, 1);
                            pcode = ht.length - 1;
                        }
                        used++;
                        intLeftOver -= 12;
                        intOutputCode &= (Math.pow(2, intLeftOver) - 1);
                    }
                    else
                        break;
                }
            }
            return strNormalString;
        }
    }
    apeng.Strings = Strings;
})(apeng || (apeng = {}));
/// <reference path="./../Main.ts" />

(function (apeng) {
    const _date = new Date();
    /**
     * 时间处理类
     *
     * @export
     * @class Times
     */
    class Times {
        /**
         * 可传入时间戳，默认取当前时间戳
         * @param {number} [time]
         * @memberof Times
         */
        constructor(time) {
            /**类时间戳 */
            this.time = 0;
            if (time)
                this.time = time;
            else
                this.time = Times.now;
        }
        /**获取当前时间戳 外面赋值*/
        static get now() {
            return Date.now();
        }
        static getDayOfYear(time) {
            _date.setTime(time);
            const currentYear = _date.getFullYear().toString();
            // 今天减今年的第一天（xxxx年01月01日）
            const hasTimestamp = time - new Date(currentYear).getTime();
            // 86400000 = 24 * 60 * 60 * 1000
            const hasDays = Math.ceil(hasTimestamp / 86400000) + 1;
            // 结果：今天是2018年的第329天
            return hasDays;
        }
        /**
         * 格式化时间
         * 2012/2/3 00:22:33
         * @param now
         * @returns
         */
        static toLocaleString(now, hour = true, interval = " ") {
            if (!now)
                now = Times.now;
            _date.setTime(now);
            return _date.getFullYear() + "/" + (_date.getMonth() + 1) + "/" + _date.getDate() + (hour ? (interval + this.numHour(now, true)) : "");
        }
        /**
         * 格式化时间
         * 2012年2月3日 00:22:33
         * @param now
         * @returns
         */
        static toLocaleStringChina(now) {
            if (!now)
                now = Times.now;
            _date.setTime(now);
            return _date.getFullYear() + Times.texts[10001] + (_date.getMonth() + 1) + Times.texts[10002] + _date.getDate() + Times.texts[10003] + " " + this.numHour(now, true);
        }
        static getMonthOfYear(now) {
            if (!now)
                now = Times.now;
            _date.setTime(now);
            return _date.getMonth() + 1;
        }
        static getDayOfMonth(now) {
            if (!now)
                now = Times.now;
            _date.setTime(now);
            return _date.getDate();
        }
        static console(key) {
            Times._console[key] = Times.now;
        }
        static consoleEnd(key, ...args) {
            console.log(key, (Times.now - (Times._console[key] || Times.now)) / 1000, ...args);
        }
        static get Date() {
            let date2 = new Date();
            date2.setTime(Times.now);
            return date2;
        }
        /**获取本月一共有多少天 */
        static getMontyByDay() {
            let date = Times.Date;
            let year = date.getFullYear();
            let monty = date.getMonth() + 1;
            return new Date(year, monty, 0).getDate();
        }
        /**转换时间戳 utc 天 */
        static day(time) {
            return Math.floor((Times.hour(time) + 8) / 24);
        }
        /**转换时间戳 时 */
        static hour(time) {
            return Math.floor(Times.minute(time) / 60);
        }
        /**转换时间戳 分 */
        static minute(time) {
            return Math.floor(Times.second(time) / 60);
        }
        /**转换时间戳 秒 */
        static second(time) {
            if (time == null || time == undefined) {
                if (!apeng._timer)
                    return Math.floor(Times.now / 1000);
                else if (apeng._timer.dirtyMark("Times.second")) {
                    time = Times.now;
                    Times._secondCache = Math.floor(time / 1000);
                }
            }
            else
                return Math.floor(time / 1000);
            return Times._secondCache;
        }
        /**
         * 格式化时间戳 utc时间 数字显示
         * @param time
         * @param hour 当小于 1小时时，显示 00:59:12 反之 59:12
         * @returns 00:00:00
         */
        static numHour(time, hour = false) {
            let res = Times.converMinTen(Times.second(time) % 60) + "";
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time) % 60) + ":" + res;
            else
                res = "00:" + res;
            if (Times.minute(time) >= 60)
                res = Times.converMinTen((Times.hour(time) + 8) % 24) + ":" + res;
            else {
                if (hour)
                    res = "00:" + res;
            }
            return res;
        }
        /**一天中的第几小时 */
        static dayByHour(time) {
            return (Times.hour(time) + 8) % 24;
        }
        /**
         * 格式化时间戳 数字显示(无转换)适用于倒计时
         * @param time
         * @returns 00:00:00
         */
        static numHourCountDown(time, hour = false) {
            if (time && time <= 0) {
                if (hour)
                    return "00:00:00";
                else
                    return "00:00";
            }
            let res = Times.converMinTen(Times.second(time) % 60) + "";
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time) % 60) + ":" + res;
            else
                res = "00:" + res;
            if (Times.minute(time) >= 60)
                res = Times.converMinTen(Times.hour(time)) + ":" + res;
            else {
                if (hour)
                    res = "00:" + res;
            }
            return res;
        }
        /**
         * 格式化时间戳 中文显示(无转换)适用于倒计时
         * @param time
         * @returns 1小时10分3秒
         */
        static chinaHourCountDown(time, hour = false) {
            if (time && time <= 0) {
                if (hour)
                    return "0" + Times.texts[10004] + "0" + Times.texts[10006] + "0" + Times.texts[10007];
                else
                    return "0" + Times.texts[10006] + "0" + Times.texts[10007];
            }
            let res = Times.converMinTen(Times.second(time) % 60) + Times.texts[10007];
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time) % 60) + Times.texts[10006] + res;
            else
                res = "0分" + res;
            if (Times.minute(time) >= 60)
                res = Times.converMinTen(Times.hour(time)) + Times.texts[10004] + res;
            else {
                if (hour)
                    res = "0" + Times.texts[10004] + res;
            }
            return res;
        }
        /**格式化时间戳 数字显示 @requires 00:00 */
        static numMinute(time) {
            let res = Times.converMinTen(Times.second(time) % 60) + "";
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time)) + ":" + res;
            else
                res = "00:" + res;
            return res;
        }
        /**格式化时间戳 数字显示 @requires 00 */
        static numSecond(time) {
            return Times.converMinTen(Times.second(time));
        }
        /** 格式化时间戳 中文显示 @requires 09时02分03秒 */
        static chinaHour(time) {
            let res;
            res = Times.converMinTen(Times.second(time) % 60) + Times.texts[10007];
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time) % 60) + Times.texts[10006] + res;
            if (Times.minute(time) >= 60)
                res = Times.converMinTen(Times.hour(time) % 24) + Times.texts[10005] + res;
            return res;
        }
        /** 格式化时间戳 中文显示 @requires 09时02分*/
        static numHourAndMinute(time) {
            let res = Times.converMinTen(Times.minute(time) % 60) + ":00";
            if (Times.minute(time) >= 60)
                res = Times.converMinTen(Times.hour(time) % 24) + ":" + res;
            return res;
        }
        /** 格式化时间戳 中文显示 @requires 09时02分*/
        static chinaHourAndMinute(time) {
            let res;
            res = Times.converMinTen(Times.minute(time) % 60) + Times.texts[10006];
            if (Times.minute(time) >= 60)
                res = Times.converMinTen(Times.hour(time) % 24) + Times.texts[10005] + res;
            return res;
        }
        /** 格式化时间戳 中文显示 @requires 02分03秒 */
        static chinaMinute(time) {
            let res;
            res = Times.converMinTen(Times.second(time) % 60) + Times.texts[10007];
            if (Times.second(time) >= 60)
                res = Times.converMinTen(Times.minute(time) % 60) + Times.texts[10006] + res;
            return res;
        }
        /** 格式化时间戳 中文显示 @requires 03秒 */
        static chinaSecond(time) {
            return Times.converMinTen(Times.second(time)) + Times.texts[10007];
        }
        /**小于10的数字加 0 */
        static converMinTen(num) {
            return num < 10 ? ("0" + num) : num.toString();
        }
        /**获取当前天已过的时间 utc时间 */
        static getToDayNow() {
            let time = Times.now;
            let res = (Times.second(time) % 60) * 1000;
            if (Times.second(time) >= 60)
                res += (Times.minute(time) % 60) * 60 * 1000;
            if (Times.minute(time) >= 60)
                res += ((Times.hour(time) + 8) % 24) * 60 * 60 * 1000;
            return res;
        }
        /**当前天还剩余的 时间 毫秒 */
        static getToDayLeave() { return Times.dayOnce - Times.getToDayNow(); }
        /**获取时间戳的时间 到现在过了的天数 */
        static getToNowDay(lastTime) {
            return Times.day(Times.now - lastTime);
        }
        /**返回一天中剩余的时间 单位 秒 */
        static getOneDayLeftTime() {
            let curTime = Times.numHour(Times.now);
            let timeArr = curTime.split(":");
            let passHour = Number(timeArr[0]);
            let passMinute = Number(timeArr[1]);
            let passSecond = Number(timeArr[2]);
            return (23 - passHour) * 60 * 60 + (59 - passMinute) * 60 + (59 - passSecond);
        }
        /**返回 当前周 是一年中的第几周 */
        static getWeekOfTheYear() {
            _date.setTime(Times.now);
            let curTime = _date;
            let firstDay = new Date(curTime.getFullYear(), 0, 1);
            let dayOfWeek = firstDay.getDay();
            let spendDay = 1;
            if (dayOfWeek != 0) {
                spendDay = 7 - dayOfWeek + 1;
            }
            firstDay = new Date(curTime.getFullYear(), 0, 1 + spendDay);
            let d = Math.ceil((curTime.valueOf() - firstDay.valueOf()) / 86400000);
            let result = Math.ceil(d / 7);
            return result + 1;
        }
        /**时间戳是当年的第几天  */
        static getDayOfTheYear(time) {
            _date.setTime(time);
            let curTime = _date;
            let firstDay = new Date(curTime.getFullYear(), 0, 1);
            let day = Math.ceil((curTime.valueOf() - firstDay.valueOf()) / (24 * 60 * 60 * 1000));
            return day;
        }
        /**
         * 相加
         * @param {number} time 毫秒
         * @memberof Times
         */
        add(time) {
            this.time += time;
            return this;
        }
        sub(time) {
            this.time -= time;
            return this;
        }
        get now() { return this.time; }
        /**转换时间戳 天 */
        get day() { return Math.floor(this.hour / 24); }
        /**转换时间戳 时 */
        get hour() { return Math.floor(this.minute / 60); }
        /**转换时间戳 分 */
        get minute() { return Math.floor(this.second / 60); }
        /**转换时间戳 秒 */
        get second() { return Math.floor(this.time / 1000); }
        get numHour() { return Times.numHour(this.time); }
        get numMinute() { return Times.numMinute(this.time); }
        get numSecond() { return Times.numSecond(this.time); }
        get chinaHour() { return Times.chinaHour(this.time); }
        get chinaMinute() { return Times.chinaMinute(this.time); }
        get chinaSecond() { return Times.chinaSecond(this.time); }
        converMinTen() { return Times.converMinTen(this.time); }
    }
    Times.texts = {
        10001: "年",
        10002: "月",
        10003: "日",
        10004: "小时",
        10005: "时",
        10006: "分",
        10007: "秒",
    };
    /**一天的总时间 毫秒 */
    Times.dayOnce = 24 * 60 * 60 * 1000;
    Times._console = {};
    // 同帧大量调用 使用缓存
    Times._secondCache = Times.now;
    apeng.Times = Times;
})(apeng || (apeng = {}));
